-- phpMyAdmin SQL Dump
-- version 4.0.10deb1
-- http://www.phpmyadmin.net
--
-- Host: localhost
-- Generation Time: Oct 29, 2016 at 11:54 PM
-- Server version: 5.5.53-0ubuntu0.14.04.1-log
-- PHP Version: 5.5.9-1ubuntu4.20

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;

--
-- Database: `debugger`
--

-- --------------------------------------------------------

--
-- Table structure for table `answers`
--

CREATE TABLE IF NOT EXISTS `answers` (
  `teamname` varchar(16) NOT NULL,
  `questionid` tinyint(4) NOT NULL,
  `stageid` varchar(2) NOT NULL,
  `ans` longtext NOT NULL,
  `time` int(11) NOT NULL,
  PRIMARY KEY (`teamname`,`questionid`,`stageid`),
  KEY `stageid` (`stageid`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

--
-- Dumping data for table `answers`
--

INSERT INTO `answers` (`teamname`, `questionid`, `stageid`, `ans`, `time`) VALUES
('12345678', 1, '1a', '#include <stdio.h>\n#include <stdlib.h>\n\nint max(int a[],int n)\n{\n  int max=0, i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];	\n	   }\n       }\n	   return(max);	\n}\n\nvoid bucket_sort(int a[],int n){\n  int bucket=max(a,n);\n  int b[1000],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[a[i]]+1;\n  	}	\n   	for(i=0;i<=bucket;i++)	\n       {\n	      for(k=b[i];k>0;--k)\n                       {\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[1000];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]);\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', 0),
('12345678', 1, '2a', '#include<stdio.h>\nvoid fact(int*);\n\nint main()\n{\n    int i;\n    scanf("%d",&i);\n    fact(&i);\n    printf("%d\\n", i);\n    return 0;\n}\nvoid fact(int *j)\n{\n    static int s=1;\n    if(*j!=1)\n    {\n        s *= *j;\n        *j--;\n        fact(j);\n        *j=s;\n    }\n}', 0),
('12345678', 2, '1a', '#include<stdio.h>\n\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    temp = b;\n    b = a;\n    a = c;\n    c = temp;\n}\n\nint main()\n{\n    int a, b, c;\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n\n    printf("Value before swapping:");\n    printf("a = %d, b = %d, c = %d", a,b,c);\n\n    cyclicSwap(&a, &b, &c);\n\n    printf("Value after swapping:");\n    printf("a = %d, b = %d, c = %d", a, b, c);\n\n    return 0;\n}\n', 0),
('12345678', 2, '2a', '#include<stdio.h>\n#define NIL -1\n#define MAX 100\nint lookup[MAX];\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n  int i;\n  for (i = 0; i < MAX; i++)\n    lookup[i] = NIL;\n}\n/* function for nth Fibonacci number */\nint fib(int n)\n{\n   if (lookup[n] == NIL)\n   {\n      if (n <= 1)\n         lookup[n] = n;\n      else\n         lookup[n] = fib(n-1) + fib(n-2);\n   }\n   return lookup[n];\n}\nint main ()\n{\n  int n;\n  scanf("%d",&n);\n  _initialize();\n  printf("Fibonacci number is %d ", fib(n));\n  return 0;\n}', 0),
('12345678', 3, '1a', '\n#include <stdio.h>\n#include <limits.h>  \n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], int splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\nprintf("Vertex   Distance from Source");\nfor (int i = 0; i < V; i ++)\nprintf("%d 		 %d\n", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('12345678', 3, '2a', '#include <stdio.h>\n \nint getMedian(int ar1[], int ar2[], int n)\n{\n    int i = 0;  \n    int j = 0; \n    int count;\n    int m1 = -1, m2 = -1;\n \n    for (count = 0; count <= 2*n; count++)\n    {\n        if (i != n)\n        {\n            m1 = m2;\n            m2 = ar2[0];\n            break;\n        }\n        else if (j != n)\n        {\n            m1 = m2;\n            m2 = ar1[0];\n            break;\n        }\n \n        if (ar1[i] < ar2[j])\n        {\n            m1 = m2;\n            m2 = ar1[i];\n            j++;\n        }\n        else\n        {\n            m2 = m1;  \n            m1 = ar2[j];\n            i++;\n        }\n    }\n \n    return (m1 + m2)/2;\n}\nint main()\n{\n    int n1,n2,ar1[100],ar2[100];\n    int i;\n    scanf("%d",&n1);\n    for (i = 0; i < n1; ++i)\n    {\n        scanf("%d",&ar1[i]);\n    }\n    scanf("%d",&n2);\n    for (i = 0; i < n2; ++i)\n    {\n        scanf("%d",&ar2[i]);\n    }\n\n    if (n1 == n2)\n        printf("Median is %d", getMedian(ar1, ar2, n1));\n    else\n        printf("Doesn''t work for arrays of unequal size");\n    getchar();\n    return 0;\n}', 0),
('12345678', 4, '2a', ' #include<stdio.h>\n\n  #define TOTAL_ELEMENTS 7\n  int array[] = {23,34,12,17,204,99,16};\n\n  int main()\n  {\n      int d;\n\n      for(d=-1;d <= (TOTAL_ELEMENTS-2);d++)\n          printf("%d\\n",array[d+1]);\n\n      return 0;\n  }\n', 0),
('Aces95', 1, '1b', '#include<bits/stdc++.h>\n#include<algorithms.h>\n#include<vectors.h>\n#include<iostream.h>\nusing namespace std;\nvoid bucketSort(arr[], n)\n{\n    vector<float> b[n];\n    for (int i=0; i<n; i++){\n    int bi = n*arr[i]; \n    b[bi]-push_back(arr[i]);\n    } for (int i=0; i<n; i++)\n       sort(b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++)for (int j = 0; j < b[i].size(); j++)\n          arr[index++] = b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ";\n    return 0;\n}\n', 0),
('Aces95', 2, '1b', '#include<bits/stdc++.h>\n#include<iostream.h>\nusing namespace std;\n\nint main()\n{\n    int a, b, c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(&a, &b, &c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    // swapping in cyclic order\n    *temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = *temp;\n}', 0),
('Aces95', 3, '1b', '\n#include<bits/stdc++.h>\nusing namespace std;\n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], bool splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(int v = 0; v < V; v++){\nif (sptSet[v] == false && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn (min_index); }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\ncout<<"Vertex   Distance from Source\\n";\nfor (int i = 0; i < V; i++)\ncout<<i<<"		 "<<dist[i]<<"\\n";\n// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nbool sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = false;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = true;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v])\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0}\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('Aces95', 4, '1b', '#inlcude<bits/stdc++.h>\nusing namespace std;\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2, j = n-1;\nfor (int num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2;i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    cout<<"The Magic Square for n="<<n<<":\\nSum of each row or column :"<<n*(n*n+1)/2<<endl;\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            cout<< magicSquare[i][j]<<" ";\n        cout<<endl;\n    }\n}\n \nint main()\n{\n    int n;\n    cin>>n;\n    generateSquare(n);\n    return 0;\n}\n', 0),
('Aces95', 5, '1b', '#include<bits/stdc++.h>\n#include<math.h>\n#include<iostream.h>\nusing namespace std;\n\nint main()\n{\n    int n , m;\n    cin>>n>>m;\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nbool isStepNum(int n)\n{\n    int prevDigit = -1;\n    while(n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return false;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return true;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n        if (isStepNum(i))\n            cout << i <<" ";\n}', 0),
('anns', 1, '1a', '#include <stdio.h>\n#include <stdlib.h>\n\nint max(int a[] ,int n)\n{\n  int max=0,i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int a[] ,int n)\n{\n  int bucket;\n bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[[a[i]+1];\n  	}	\n   	for(i=0;i< =bucket;i++)	\n          {\n	      for(k=b[i];k>0;--k)\n                  {\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main()\n{\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]):\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', 0),
('anns', 1, '2a', '#include<stdio.h>\n static int s=0;\nint fact(int);\nint main()\n{\n    int i;\n    scanf("%d",&i);\n    fact(&i);\n    printf("%d\\n", i);\n    return 0;\n}\nint fact(int *j)\n{\n    if(j!=1)\n    {\n        s = s*(*j);\n        *j--;\n         fact(&j);\n     }\n  return s;\n}', 0),
('anns', 2, '1a', '#include<stdio.h>\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c =temp;\n}\n\nint main()\n{\n    int a ,b, c;\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n\n    printf("Value before swapping:");\n    printf("a = %d ,b = %d, c = %d",a,b,c);\n\n    cyclicSwap(&a, &b, &c);\n\n    printf("Value after swapping:");\n    printf("a = %d ,b = %d ,c = %d",a, b, c);\n\n    return 0;\n}\n', 0),
('anns', 2, '2a', '#include<stdio.h>\n#define NIL -1\n#define MAX 100\nint lookup[MAX];\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n  int i;\n  for (i = 0; i < MAX; i++)\n    lookup[i] = NIL;\n}\n/* function for nth Fibonacci number */\nint fib(int n)\n{\n   if (lookup[n] == NIL)\n   {\n      if (n < 1)\n         lookup[n] = n;\n      else\n         lookup[n] = fib(n) + fib(n-1);\n   }\n   return lookup[n+1];\n}\nint main ()\n{\n  int n;\n  scanf("%d",&n);\n  _initialize();\n  printf("Fibonacci number is %d ", fib(n));\n  return 0;\n}', 0),
('anns', 3, '1a', '\n#include <stdio.h>\n#include <limits.h>  \n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], int splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\nprintf("Vertex   Distance from Source\n");\nfor (int i = 0; i < V; i ++)\nprintf("%d 		 %d\n", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('anns', 3, '2a', '#include <stdio.h>\n \nint getMedian(int ar1[], int ar2[], int n)\n{\n    int i = 0;  \n    int j = 0; \n    int count;\n    int m1 = -1, m2 = -1;\n \n    for (count = 0; count < 2*n; count++)\n    {\n        if (i != n)\n        {\n            m1 = m2;\n            m2 = ar2[0];\n            break;\n        }\n        else if (j != n)\n        {\n            m1 = m2;\n            m2 = ar1[0];\n            break;\n        }\n \n        if (ar1[i] < ar2[j])\n        {\n            m1 = m2;\n            m2 = ar1[i];\n            j++;\n        }\n        else\n        {\n            m2 = m1;  \n            m1 = ar2[j];\n            i++;\n        }\n    }\n    return (m1 + m2)/2;\n}\nint main()\n{\n    int n1,n2,ar1[100],ar2[100];\n    int i;\n    scanf("%d",&n1);\n    for (i = 0; i < n1; i++)\n    {\n        scanf("%d",&ar1[i]);\n    }\n    scanf("%d",&n2);\n    for (i = 0; i < n2; i++)\n    {\n        scanf("%d",&ar2[i]);\n    }\n\n    if (n1 == n2)\n        printf("Median is %d", getMedian(ar1, ar2, n1));\n    else\n        printf("Doesn''t work for arrays of unequal size");\n    getchar();\n    return 0;\n}', 0),
('anns', 4, '1a', '#include<stdio.h> \n#include<string.h>\n \nvoid generateSquare(int n)\n{\nint magicSquare[n][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2;\nj = n-1;\nint num;\nfor (num=1; num <= n*n;num++ )\n{if (i==-1 && j==n) //3rd condition\n{\nj = n-2:i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', 0),
('anns', 4, '2a', ' #include<stdio.h>\n\n  #define TOTAL_ELEMENTS (sizeof(array) / sizeof(array[0]))\n  int array[] = {23,34,12,17,204,99,16};\n\n  int main()\n  {\n      int d;\n\n      for(d=-1;d <= (TOTAL_ELEMENTS-2);d++)\n          printf("%d\\n",array[d+1]);\n\n      return 0;\n  }\n', 0),
('anns', 5, '1a', '#include<stdlib.h>\n#include<stdio.h>\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n \\= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (iStepNum(i))\n            printf("%d ",i);\n}', 0),
('Anonymous', 1, '1a', '#include <stdio.h>\n#include <stdlib.h>\n\nint max(int a[],int n)\n{\n  int max=0,i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int a[],int n){\n  int bucket=max(a,n);\n  int b[10000],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[a[i]]+1;\n  	}	\n   	for(i=0;i<=bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n,a[10000];\nscanf("%d",&n);\n\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]);\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', 0),
('Anonymous', 1, '2a', '#include<stdio.h>\nvoid fact(int *);\n\nint main()\n{\n    int i;\n    scanf("%d",&i);\n    fact(&i);\n    printf("%d\\n", i);\n    return 0;\n}\nvoid fact(int *j)\n{\n    static int s=1;\n    if(*j!=1)\n    {\n        s = s*(*j);\n        (*j)--;\n        fact(j);\n    }\n   else\n    { *j=s;\n    }\n}', 0),
('Anonymous', 1, '3a', '#include<stdio.h> \n#include<math.h>\n#include<stdlib.h>\n\nint isDivisibleBy7( int num ) {\nif( num < 0 )\n  return isDivisibleBy7( abs(num) );\nif( num == 0 || num == 7 )\n    return 1;\nif( num > 10 )\n   return isDivisibleBy7( (num/10) - (2*(num%10)) );\nreturn 0;\n}\n\nint main() {\n   int num;\n   scanf("%d",&num);\n    if( isDivisibleBy7(num) )\n        printf( "Divisible" );\n     else\n        printf( "Not Divisible" );\n     return 0;\n}', 0),
('Anonymous', 2, '1a', '#include<stdio.h>\n#include<stdlib.h>\nvoid cyclicSwap(int *,int *,int *);\n\nint main()\n{\n    int a, b, c;\n\n    pritnf("Enter a, b and c respectively: ");\n    scanf("%d%d%d",&a,&b,&c);\n\n    printf("Value before swapping:");\n    printf("a = %d b = %d c = %d",a,b,c);\n\n    cyclicSwap(&a, &b, &c);\n\n    printf("Value after swapping:");\n    printf("a = %d b = %d c = %d",a, b, c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = temp;\n}', 0),
('Anonymous', 2, '2a', '#include<stdio.h>\n#define NIL -1\n#define MAX 100\nint lookup[MAX];\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n  int i;\n  for (i = 0; i < MAX; i++)\n    lookup[i] = NIL;\n}\n/* function for nth Fibonacci number */\nint fib(int n)\n{\n   if (lookup[n] == NIL)\n   {\n      if (n <= 1)\n         lookup[n] = n;\n      else\n         lookup[n] = fib(n-1) + fib(n-2);\n   }\n   return lookup[n];\n}\nint main ()\n{\n  int n;\n  scanf("%d",&n);\n  _initialize();\n  printf("Fibonacci number is %d ", fib(n));\n  return 0;\n}', 0),
('Anonymous', 2, '3a', '#include <stdio.h>\n#include <stdlib.h>\nstruct node{\n    int data;\n    struct node *next;\n};\n \nvoid deleteNode(struct node *head,struct node *n) {\n    if(head == n){\n        if(head->next == NULL) {\n            printf("There is only one node.");\n            free(n);\n            return;}\n        head->data = head->next->data;\n        n = head->next;\n        head->next = head-next->next;\n        free(n);	// free memory\n        return;\n    }\n    struct node *prev = head;\n    while(prev->next != NULL || prev->next != n)\n        prev = prev->next;\n    if(prev->next == NULL) {\n        printf("\\n Given node is not present in Linked List");\n        return;\n    }\n     prev->next = n->next;\n    free(n);\n    return; \n}\n \n/* Utility function to insert a node at the begining */\nvoid push(struct node *head_ref, int new_data)\n{\n    struct node *new_node = (struct node *)malloc(sizeof(struct node));\n    new_node->data = new_data;\n    new_node->next = *head_ref;\n    *head_ref = new_node;\n}\n \n/* Utility function to print a linked list */\nvoid printList(struct node *head)\n{\n    while(head!=NULL)\n    {\n        printf("%d ",head->data);\n        head=head->next;\n    }\n    printf("\\n");\n}\n \nint main(){\n    struct node *head = NULL;\n    push(&head,3);\n    push(&head,2);\n    push(&head,6);\n    push(&head,5);\n    push(&head,11);\n    push(&head,10);\n    push(&head,15);\n    push(&head,12);\n    printf("Given Linked List: ");\n    printList(head);\n    /* Let us delete the node with value 10 */\n    printf("\\nDeleting node %d: ", head->next->next->data);\n    deleteNode(head, head->next->next);\n    printf("\\nModified Linked List: ");\n    printList(head);\n    /* Let us delete the the first node */\n    printf("\\nDeleting first node ");\n    deleteNode(head, head);\n    printf("\\nModified Linked List: ");\n    printList(head);\n    return 0;\n}\n\n\n\n', 0),
('Anonymous', 3, '1a', '\n#include <stdio.h>\n#include <limits.h>  \n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], int splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\nprintf("Vertex   Distance from Source\n");\nfor (int i = 0; i < V; i ++)\nprintf("%d 		 %d\n", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('Anonymous', 3, '2a', '#include <stdio.h>\n \nint getMedian(int ar1[], int ar2[], int n)\n{\n    int i = 0;  \n    int j = 0; \n    int count;\n    int m1 = -1, m2 = -1;\n \n    for (count = 0; count < 2*n; count++)\n    {\n        if (i == n)\n        {\n            m1 = m2;\n            m2 = ar2[0];\n            break;\n        }\n        else if (j == n)\n        {\n            m1 = m2;\n            m2 = ar1[0];\n            break;\n        }\n \n        if (ar1[i] < ar2[j])\n        {\n            m1 = m2;\n            m2 = ar2[j];\n            j++;\n        }\n        else\n        {\n            m2 = m1;  \n            m1 = ar1[i];\n            i++;\n        }\n    }\n \n    return (m1 + m2)/2;\n}\nint main()\n{\n    int n1,n2,ar1[100],ar2[100];\n    int i;\n    scanf("%d",&n1);\n    for (i = 0; i < n1; ++i)\n    {\n        scanf("%d",&ar1[i]);\n    }\n    scanf("%d",&n2);\n    for (i = 0; i < n2; ++i)\n    {\n        scanf("%d",&ar2[i]);\n    }\n\n    if (n1 == n2)\n        printf("Median is %d", getMedian(ar1, ar2, n1));\n    else\n        printf("Doesn''t work for arrays of unequal size");\n    getchar();\n    return 0;\n}', 0),
('Anonymous', 3, '3a', '#include<stdio.h>\nint leftRight(int arr[],int n)\n{\n    int visited[n];\n    for (int i=1; i<n; i++)\n    	visited[i]=0;\n    for (int i=0; i<n; i++)\n    {\n        if (arr[i] < n)\n        {\n            if (visited[arr[i]] != 0)\n                visited[i] = 1;\n            else\n                visited[n-arr[i]+1] = 1;\n        }\n    }\n    for (int i=0; i<n; i++)\n        if (visited[i] = = 0)\n            return 0;\n \n    return 1;\n}\nvoid main()\n{\n    int arr[] = {2, 1, 5, 2, 1, 5};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    if (leftRight(arr, n) == 1)\n        printf("YES");\n    else\n        printf("NO");\n    return 0;\n}', 0),
('Anonymous', 4, '1a', '#include<stdio.h> \n#include<string.h>\n \nvoid generateSquare(int n)\n{\nint magicSquare[10000][10000];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2,j = n-1;\nint num;\nfor (num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2;\ni = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', 0),
('Anonymous', 4, '2a', ' #include<stdio.h>\n\n\n\n  int main()\n  {   int array[] = {23,34,12,17,204,99,16};\n      int d;\n      int TOTAL_ELEMENTS =(sizeof(array) / sizeof(array[0]));\n\n      for(d=-1;d <= (TOTAL_ELEMENTS-2);d++)\n          printf("%d\\n",array[d+1]);\n\n      return 0;\n  }\n', 0),
('Anonymous', 5, '1a', '#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\nint isStepNum(int);\nvoid displaySteppingNumbers(int ,int);\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(int n)\n{\n    int prevDigit = -1;\n    int curDigit;\n    while (n)\n    {\n        curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n \\= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{   int i;\n    for (i=n; i<=m; i++)\n        {if (isStepNum(i))\n            printf("%d ",i);}\n}', 0),
('Arpan Kundu', 1, '1b', '#include<bits/stdc++.h>\nusing namespace std;\nvoid bucketSort(arr[], n)\n{\n    Vector <float> b[n];\n    for (int i=0; i<n; i++){\n    bi = n*arr[i]; \n    b[bi]=push_back(arr[i]);\n    } for (int i=0; i<n; i++)\n       sort((b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++)for (int j = 0; j < b[i].size(); j++)\n          arr[index++] = b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ";\n    return 0;\n}\n', 0),
('Arpan Kundu', 2, '1b', '#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int a, b, c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(&a, &b, &c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    // swapping in cyclic order\n    *temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = *temp;\n}', 0),
('Arpan Kundu', 3, '1b', '\n#include<bits/stdc++.h>\nusing namespace std;\n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], bool splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == false && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\ncout<<"Vertex   Distance from Source\\n";\nfor (int i = 0; i < V; i ++)\ncout<<i<<"		 "<<dist[i]<<"\\n";\n// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nbool sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = false;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = true;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('Arpan Kundu', 4, '1b', '#inlcude<bits/stdc++.h>\nusing namespace std;\n \nvoid generateSquare(int n)\n{\nint *magicSquare[]=new int[n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2;j = n-1;\nfor (int num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2:i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    cout<<"The Magic Square for n="<<n<<":\\nSum of each row or column :"<<n*(n*n+1)/2<<endl;\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            cout<< magicSquare[i][j]<<" ";\n        cout<<endl;\n    }\n}\n \nint main()\n{\n    int n ;\n    cin>>n;\n    generateSquare (n);\n    return 0;\n}\n', 0),
('Arpan Kundu', 5, '1b', '#include<bits/stdc++.h>\n#include<math.h>\nusing namespace std;\n\nint main()\n{\n    int n , m ;\n    cin>>n>>m;\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nbool isStepNum(n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit)) != 1)\n                 return false;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return true;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n        if (isStepNum(i))\n            cout << i <<" ";\n}', 0),
('arsh_avn', 1, '1a', '#include <stdio.h>\n#include <stdllib.h>\n\nint max(int a[],int n)\n{\n  int max=0,*i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int a[],int n)\n{\n  int bucket=max(a,n);\n  int b[bucket] ,i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[a[i]]+1;\n  	}	\n   	for(i=0;i< =bucket;i++)	\n           {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n	\n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]):\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', 0),
('arsh_avn', 2, '1a', '#include<stdio.h>\n\n\nint main()\n{\n    int a,b, c;\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n\n    printf("Value before swapping:");\n    printf("%d %d %d",a,b,c);\n\n    cyclicSwap(*a, *b, *c);\n\n    printf("Value after swapping:");\n    printf(" %d  %d %d",a, b, c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    *temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = *temp;\n}', 0),
('arsh_avn', 3, '1a', '\n#include <stdio.h>\n#include <limits.h>  \n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], int splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nint v;\nfor(v = 0; v < V; v++){\nif (sptSet[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\nprintf("Vertex   Distance from Source\n");\nfor (int i = 0; i < V; i ++)\nprintf("%d 		 %d", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('arsh_avn', 4, '1a', '#include<stdio> \n#include<string>\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2;j = n-1;\nint num;\nfor (num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2:i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', 0),
('arsh_avn', 5, '1a', '#include<stdlib.h>\n#include<stdio.h>\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint StepNum(n)\n{\n    int prevDigit = -1;\n int curDigit = n % 10;\n    while (n)\n    {\n       \n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n = n/10;\n    }\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n   int i;\n    for (i=n; i<=m; i++)\n     {   if (i==StepNum(i))\n            printf("%d ",i);\n}\n}', 0),
('asdf', 1, '1a', '#include <stdio.h>\n#include <stdlib.h>\nvoid bucket_sort(int a[],int n);\nint max(int a[],int n);\nint max(int a[],int n)\n{\n  int max=0,*i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int a[],int n){\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[a[i]]+1;\n  	}	\n   	for(i=0;i< bucket;i++)	    {\n	      for(k=b[i];k>0;k--){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]):\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', 0),
('asdf', 2, '1a', '#include<stdio.h>\nvoid cyclicSwap(int *a,int *b,int *c);\n\n\nint main()\n{\n    int a, b, c;\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n\n    printf("Value before swapping:\n");\n    printf("a = %d \nb = %d \nc = %d\n",a,b,c);\n\n    cyclicSwap(&a, &b, &c);\n\n    printf("Value after swapping:\n");\n    printf("a = %d \nb = %d \nc = %d",a, b, c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    temp = *b;\n    *b = *a;\n    *a =*c;\n    *c = temp;\n}', 0),
('asdf', 3, '1a', '\n#include <stdio.h>\n#include <limits.h>  \n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], int splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\nprintf("Vertex   Distance from Source\n");\nfor (int i = 0; i < V; i ++)\nprintf("%d 		 %d\n", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('asdf', 4, '1a', '#include<stdio> \n#include<string>\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2;j = n-1;\nint num;\nfor (num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2:i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', 0),
('asdf', 5, '1a', '#include<stdlib.h>\n#include<stdio.h>\n#include<math.h>\nint isStepNum(int n);\nvoid displaySteppingNumbers(int n, int m);\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n        if (isStepNum(i))\n            printf("%d ",i);\n}', 0),
('avial', 1, '1a', '#include <stdio.h>\n#include <stdlib.h>\n\nint max(int a[],int n)\n{\n  int max=0,*i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int a[],int n)\n{\n  int bucket=max(a[],n),b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[[a[i]]+1;\n  	}	\n   	for(i=0;i< =bucket;i++)	   \n      {\n	      for(k=b[i];k>0;--k)\n         {\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main()\n{\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]):\nbucket_srt(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', 0),
('b4d_s3ct0r', 1, '1a', '#include<stdio.h>\n#include<stdllib.h>\n\nint max(int *a,int n)\n{\n  int max1=0,i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max1)	\n            {\n            	max1=a[i];\n			}\n	   }\n	   return max1;	\n}\n\nvoid bucket_sort(int *a,int n){\n  int bucket=max(a,n);\n  int *b=malloc(bucket*sizeof(int));\n  int i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[[a[i]]+1;\n  	}	\n   	for(i=0;i<=bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint *a=malloc(n*sizeof(int));\nfor(i=0;i<n;i++)\n    scanf("%d",&a[i]):\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\n    printf(" %d",a[i]);\nreturn 0;\n}\n', 0),
('b4d_s3ct0r', 2, '1a', '#include<stdio.h>\nvoid cyclicSwap(int *a,int *b,int *c);\n\nint main()\n{\n    int a, b, c;\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n\n    printf("Value before swapping:\n");\n    printf("a = %d \nb = %d \nc = %d\n",a,b,c);\n\n    cyclicSwap(&a,&b,&c);\n\n    printf("Value after swapping:\n");\n    printf("a = %d \nb = %d \nc = %d",a, b, c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = temp;\n}', 0);
INSERT INTO `answers` (`teamname`, `questionid`, `stageid`, `ans`, `time`) VALUES
('b4d_s3ct0r', 3, '1a', '\n#include <stdio.h>\n#include <limits.h>  \n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], int splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\nprintf("Vertex   Distance from Source\n");\nfor (int i = 0; i < V; i ++)\nprintf("%d 		 %d\n", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('b4d_s3ct0r', 4, '1a', '#include<stdio> \n#include<string>\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2;j = n-1;\nint num;\nfor (num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2:i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', 0),
('b4d_s3ct0r', 5, '1a', '#include<stdlib.h>\n#include<stdio.h>\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n \\= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (iStepNum(i))\n            printf("%d ",i);\n}', 0),
('BigBang', 1, '1a', '#include <stdio.h>\n#include <stdlib.h>\n\nint max(int[] a,int n)\n{\n  int max=0,*i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int[] a,int n){\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++) {  \n     b[i]=0;  {             \n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[[a[i]]+1;\n  	}	\n   	for(i=0;i<=bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++) {\nscanf("%d",&a[i]):\nbucket_srt(a,n); {\nfor(i=0;i<n;i++) {\nprintf(" %d",a[i]); }}\nreturn 0;\n}\n', 0),
('BigBang', 2, '1a', '#include<stdio.h>\n\n\nint main()\n{\n    int a,b,c;\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",a,b,c);\n\n    printf("Value before swapping:");\n    printf("a = %d b = %d c = %d",a,b,c);\n\n    cyclicSwap(a, b, c);\n\n    printf("Value after swapping:");\n    printf("a = %d b = %d c = %d",a, b, c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    temp = *b;\n    *b = *a;\n    *a = c;\n    *c = temp;\n}', 0),
('BigBang', 3, '1a', '\n#include <stdio.h>\n#include <limits.h>  \n// Number of vertices in the graph\n#define V=9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], int splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\nprintf("Vertex   Distance from Source\n");\nfor (int i = 0; i < V; i ++)\nprintf("%d 		 %d\n", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('BigBang', 4, '1a', '#include<stdio.h> \n#include<string.h>\n#include<stdlib.h>\n \nvoid generateSquare()\n{\nint n;\nint magicSquare[][n];\nmemset(magicSquare,0,sizeof(magicSquare));\nint i=n/2; \nj = n-1;\nint num;\nfor (num=1; num<=n*n; )\n{  \n            if (i==-1 && j==n)                                      //3rd condition\n{\n             j = n-2;\n             i = 0;\n    } }\nelse {\nif(j==n) {\nj = 0; }\nif (i < 0) {\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{\nj -= 2;\ni++;\ncontinue;\n}}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++) {\n            printf("%3d ", magicSquare[i][j]); }\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n);                           // I dont know what to do\n    generateSquare (n);\n    return 0;\n}', 0),
('BigBang', 5, '1a', '#include<stdlib.h>\n#include<stdio.h>\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n \\= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (iStepNum(i))\n            printf("%d ",i);\n}', 0),
('bigbangtheory', 1, '1b', 'void bucketSort(arr[], n)\n{\n    Vector<float> b[n];\n    for (int i=0; i<n; i++);{\n    int bi = n*arr[i]; \n    b[bi]-push_back(arr[i]);\n    } for (int i=0; i<n; i++)\n       sort((b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++)for (int j = 0; j < b[i].size(); j++)\n          arr(index++) = b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ";\n    return 0;\n}\n', 0),
('bits_please', 1, '1b', '#include<iostream>\n#include<vector>\n#include<bits/stdc++.h>\nusing namespace std;\n\nvoid bucketSort(float arr[], int n)\n{\n    vector<float> b[n];\n    for (int i=0; i<n; i++){\n    int bi = n*arr[i]; \n    b[bi].push_back(arr[i]);\n    } for (int i=0; i<n; i++)\n       sort(b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++)for (int j = 0; j < b[i].size(); j++)\n          arr[index++] = b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ";\n    return 0;\n}\n', 0),
('bits_please', 1, '2b', '#include<bits/stdc++.h>\nusing namespace std;\nvoid fact(int*);\n\nint main()\n{\n    int i;\n    cin>>i;\n    fact(&i);\n    cout<<i<<endl;\n    return 0;\n}\nvoid fact(int *j)\n{\n    static int s=1;\n    if(*j!=1)\n    {\n        s = s*(*j);\n        *j = (*j)-1;\n        fact(j);\n    }\n   else\n        *j = s;\n\n}', 0),
('bits_please', 2, '1b', '#include<bits/stdc++.h>\n#include<iostream>\nusing namespace std;\nvoid cyclicSwap(int *a,int *b,int *c);\nint main()\n{\n    int a, b, c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(&a, &b, &c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    // swapping in cyclic order\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = temp;\n}', 0),
('bits_please', 2, '2b', '#include<bits/stdc++.h>\nusing namespace std;\n\n#define NIL -1\n#define MAX 100\nint lookup[MAX];\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n  int i;\n  for (i = 0; i < MAX; i--)\n    lookup[i] = NIL;\n}\n/* function for nth Fibonacci number */\nint fib(int n)\n{\n   if (lookup[n] == NIL)\n   {\n      if (n <= 1)\n         lookup[n] = 1;\n      else\n         lookup[n] = fib(n-1) + fib(n-2);\n   }\n   return lookup[n];\n}\nint main ()\n{\n  int n;\n  cin>>n;\n  _initialize();\n  cout<<"Fibonacci number is "<<fib(n);\n  return 0;\n}', 0),
('bits_please', 3, '1b', '\n#include<bits/stdc++.h>\nusing namespace std;\n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], bool splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == false && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\ncout<<"Vertex   Distance from Source\\n";\nfor (int i = 0; i < V; i ++)\ncout<<i<<"		 "<<dist[i]<<"\\n";\n// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nbool sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = false;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = true;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('bits_please', 3, '2b', '#include<bits/stdc++.h>\nusing namespace std;\n\nint getMedian(int ar1[], int ar2[], int n)\n{\n    int i = 0;  \n    int j = 0; \n    int count;\n    int m1 = -1, m2 = -1;\n \n    for (count = 0; count <= 2*n; count++)\n    {\n        if (i != n)\n        {\n            m1 = m2;\n            m2 = ar2[0];\n            break;\n        }\n        else if (j != n)\n        {\n            m1 = m2;\n            m2 = ar1[0];\n            break;\n        }\n \n        if (ar1[i] > ar2[j])\n        {\n            m1 = m2;\n            m2 = ar1[i];\n            j++;\n        }\n        else\n        {\n            m2 = m1;  \n            m1 = ar2[j];\n            i++;\n        }\n    }\n \n    return (m1 + m2)/2;\n}\nint main()\n{\n    int n1,n2,ar1[100],ar2[100];\n    int i;\n    cin>>n1;\n    for (i = 0; i < n1; ++i)\n    {\n        cin>>ar1[i];\n    }\n    cin>>n2;\n    for (i = 0; i < n2; ++i)\n    {\n        cin>>ar2[i];\n    }\n\n    if (n1 == n2)\n        printf("Median is %d", getMedian(ar1, ar2, n1));\n    else\n        printf("Doesn''t work for arrays of unequal size");\n    getchar();\n    return 0;\n}', 0),
('bits_please', 4, '1b', '#include<bits/stdc++.h>\nusing namespace std;\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2,j = n-1;\nfor (int num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2;i = 0;\n    }\nelse{\nif(j == n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    cout<<"The Magic Square for n="<<n<<":\\nSum of each row or column :"<<n*(n*n+1)/2<<endl;\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            cout<< magicSquare[i][j]<<" ";\n        cout<<endl;\n    }\n}\n \nint main()\n{\n    int n ;\n    cin>>n;\n    generateSquare(n);\n    return 0;\n}\n', 0),
('bits_please', 4, '2b', '\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n  #define TOTAL_ELEMENTS \n  int array[] = {23,34,12,17,204,99,16};\n\n  int main()\n  {\n      int d;\n\n      for(d=-1;d <= 7;d++)\n          cout<<array[d+1]<<endl;\n\n      return 0;\n  }\n\n', 0),
('bits_please', 5, '1b', '#include<bits/stdc++.h>\nusing namespace std;\nvoid displayStepingNumbers(int n, int m);\nint main()\n{\n    int n , m ;\n    cin>>n>>m;\n    displayStepingNumbers(n, m);\n    return 0;\n}\nbool isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return false;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return true;\n}\nvoid displayStepingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n        if (isStepNum(i))\n            cout << i <<" ";\n}', 0),
('bits_please_', 1, '1b', '#include<bits/stdc++.h>\nusing namespace std;\n\nvoid bucketSort(arr[], n)\n{\n    vector< vector <float> > b(n); // // // // // // /\n    for (int i=0; i<n; i++){ //TODO\n    int bi = n*arr[i]; \n    b[bi].push_back(arr[i]);\n    } for (int i=0; i<n; i++)\n       sort((b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++)for (int j = 0; j < b[i].size(); j++)\n          arr[index++] = b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ";\n    return 0;\n}\n', 0),
('bits_please_', 1, '2b', '#include<bits/stdc++.h>\nusing namespace std;\nvoid fact(int*);\n\nint main()\n{\n    int i;\n    cin>>i;\n    fact(&i);\n    cout<<i<<endl;\n    return 0;\n}\nvoid fact(int *j)\n{\n    static int s=1;\n    if((*j)!=1)\n    {\n        s = s*(*j);\n        (*j)--;\n        fact(j);\n    }\n    *j=s;\n}', 0),
('bits_please_', 1, '3b', '#include <stdio.h> \n#include <iostream>\nusing namespace std;\nint isDivisibleBy7( int num ){\nif( num < 0 )\nreturn isDivisibleBy7( (-1)*num );\nif( num == 0 || num == 7 )\nreturn 1;\nif( num < 10 )\nreturn 0;\nreturn isDivisibleBy7( (num/10) - 2*( num - (num/10 )*10 ));}\nint main(){\nint num;\nscanf("%d",&num);\nif( isDivisibleBy7(num ) )\ncout<< "Divisible" ;\nelse\ncout<< "Not Divisible" ;\nreturn 0;}', 0),
('bits_please_', 2, '1b', '#include<bits/stdc++.h>\nusing namespace std;\n\n\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    // swapping in cyclic order\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = temp;\n}\nint main()\n{\n    int a, b, c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(&a,&b, &c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}', 0),
('bits_please_', 2, '2b', '#include<bits/stdc++.h>\nusing namespace std;\n\n#define NIL -1\n#define MAX 100\nint lookup[MAX];\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n  int i;\n  for (i = 0; i < MAX; i++)\n    lookup[i] = NIL;\n}\n/* function for nth Fibonacci number */\nint fib(int n)\n{\n   if (lookup[n] == NIL)\n   {\n      if (n < 2)\n         lookup[n] = n;\n      else\n         lookup[n] = fib(n-1) + fib(n-2);\n   }\n   return lookup[n];\n}\nint main ()\n{\n  int n;\n  cin>>n;\n  _initialize();\n  cout<<"Fibonacci number is "<<fib(n);\n  return 0;\n}', 0),
('bits_please_', 2, '3b', '#include <iostream>\n#include <stdlib.h>\nusing namespace std;\nclass node{\n    public:\n    int data;\n    node *next;\n};\n \nvoid deleteNode(node *head, node *n){\n  if(head==NULL) return;\n   if(head->next == NULL){\n            cout << "There is only one node. The list can''t be made empty ";\n            return;\n        }\n       node *prev = head;\n    while(prev->next != NULL && prev->next != n)\n        prev = prev->next;\n    if(prev->next == NULL){\n        cout << "\\n Given node is not present in Linked List";\n        return;\n    }\n     prev = prev->next->next;\n    delete n;\n    return; \n}\n/*  if(head != n){\n        if(head->next == NULL){\n            cout << "There is only one node. The list can''t be made empty ";\n            return;\n        }\n        /*head->data = head->next->data;\n        n = head->next;\n        head->next = head-next->next;\n        free(n);	// free memory\n        return;\n    }\n    node *prev = head;\n    while(prev->next != NULL && prev->next != n)\n        prev = prev->next;\n    if(prev->next == NULL){\n        cout << "\\n Given node is not present in Linked List";\n        return;\n    }\n     prev = prev->next->next;\n    free(n);\n    return; \n}*/\n \n/* Utility function to insert a node at the begining */\nvoid push( node *head_ref, int new_data)\n{\n     node *new_node = ( node*)malloc(sizeof( node));\n    new_node->data = new_data;\n    new_node->next = NULL;\n   if(head_ref == NULL)\n    head_ref = new_node;\n   else{ \n   node* temp = head_ref;\n   while(temp->next !=NULL)\n     temp = temp->next;\n     temp->next = new_node;\n   }\n    \n}\n \n/* Utility function to print a linked list */\nvoid printList( node *head)\n{\n    while(head!=NULL)\n    {\n        cout << head->data;\n        head=head->next;\n    }\n    cout << "\\n";\n}\n \nint main(){\n     node *head = NULL;\n    push(&head,3);\n    push(&head,2);\n    push(&head,6);\n    push(&head,5);\n    push(&head,11);\n    push(&head,10);\n    push(&head,15);\n    push(&head,12);\n     cout << "Given Linked List: ";\n    printList(head);\n    /* Let us delete the node with value 10 */\n    cout << "\\nDeleting node :" << head->next->next->data;\n    deleteNode(&head, head->next->next);\n    cout << "\\nModified Linked List: ";\n    printList(head);\n    /* Let us delete the the first node */\n     cout << "\\nDeleting first node ";\n    deleteNode(&head, head);\n    cout << "\\nModified Linked List: ";\n    printList(head);\n    return 0;\n}\n\n\n\n', 0),
('bits_please_', 3, '1b', '\n#include<bits/stdc++.h>\nusing namespace std;\n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], bool splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(int v = 0; v < V; v++){\nif (sptSet[v] == false && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index; }\n}// A utility function to print the constructed distance array\nvoid printSolution(int dist[], int n){\ncout<<"Vertex   Distance from Source\\n";\nfor (int i = 0; i < V; i ++)\ncout<<i<<"		 "<<dist[i]<<"\\n";\n}\n// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){ ////////////////////////////////////////\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nbool sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = false;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = true;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX && dist[u]+graph[u][v] < dist[v])\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0}\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('bits_please_', 3, '2b', '#include<bits/stdc++.h>\nusing namespace std;\n\nint getMedian(int ar1[], int ar2[], int n)\n{\n    int i = 0;  \n    int j = 0; \n    int count;\n    int m1 = -1, m2 = -1;\n \n    for (count = 0; count <= 2*n; count++)\n    {\n        if (i == n)\n        {\n            m1 = m2;\n            m2 = ar2[0];\n            break;\n        }\n        if (j == n)\n        {\n            m1 = m2;\n            m2 = ar1[0];\n            break;\n        }\n \n        if (ar1[i] < ar2[j])\n        {\n            m2 = m1;\n            m1 = ar1[i];\n            j++;\n        }\n        else\n        {\n            m1 = m2;  \n            m2 = ar2[j];\n            i++;\n        }\n    }\n   \n    return (m1 + m2)/2;\n}\nint main()\n{\n    int n1,n2,ar1[100],ar2[100];\n    int i;\n    cin>>n1;\n    for (i = 0; i < n1; ++i)\n    {\n        cin>>ar1[i];\n    }\n    cin>>n2;\n    for (i = 0; i < n2; ++i)\n    {\n        cin>>ar2[i];\n    }\n\n    if (n1 == n2)\n        printf("Median is %d", getMedian(ar1, ar2, n1));\n    else\n        printf("Doesn''t work for arrays of unequal size");\n    getchar();\n    return 0;\n}', 0),
('bits_please_', 3, '3b', '#include<bits/stdc++.h>\nusing namespace std;\n bool leftRight(int arr[],int n)\n{\n    int visited[n];\n    for (int i=1; i<n; i++)\n    	visited[i]=0;\n    for (int i=0; i<n; i++)\n    {\n        if (arr[i] < n)\n        {\n            if (visited[arr[i]] != 0)\n                visited[i] = 1;\n            else\n                visited[n-arr[i]+1] = 1;\n        }\n    }\n    for (int i=0; i<n; i++)\n        if (visited[i] = = 0)\n            return false;\n \n    return true;\n}\nvoid main()\n{\n    int arr[] = {2, 1, 5, 2, 1, 5};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    if (leftRight(arr, n) == true)\n        cout << "YES";\n    else\n        cout << "NO";\n    return 0;\n}', 0),
('bits_please_', 4, '1b', '#include<bits/stdc++.h>\nusing namespace std;\n \nvoid generateSquare(int n)\n{\nint magicSquare[n][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2,j = n-1;\nfor (int num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2;i = 0;\n    }\nelse{\nif(j == n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    cout<<"The Magic Square for n="<<n<<":\\nSum of each row or column :"<<n*(n*n+1)/2<<endl;\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            cout<< magicSquare[i][j]<<" ";\n        cout<<endl;\n    }\n}\n \nint main()\n{\n    int n ;\n    cin>>n;\n    generateSquare (n);\n    return 0;\n}\n', 0),
('bits_please_', 4, '2b', '\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n  #define TOTAL_ELEMENTS (sizeof(array) / sizeof(array[0]))\n  int array[] = {23,34,12,17,204,99,16};\n\n  int main()\n  {\n      int d;\n\n      for(d=-1;d <= (TOTAL_ELEMENTS-2);d++)\n          cout<<array[d+1]<<endl;\n\n      return 0;\n  }\n\n', 0),
('bits_please_', 5, '1b', '#include<bits/stdc++.h>\nusing namespace std;\nbool isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return false;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return true;\n}\n\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n        if (isStepNum(i))\n            cout << i <<" ";\n}\n\n\nint main()\n{\n    int n , m ;\n    cin>>n>>m;\n    displaySteppingNumbers(n, m);\n    return 0;\n}\n', 0),
('breakingbad', 1, '1a', '#include <stdio.h>\n#include <stdllib.h>\n\nint max(int[] a,int n)\n{\n  int max=0,*i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int[] a,int n){\n  int bucket=max(a,n);\n  int bucket,i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[[a[i]]+1;\n  	}	\n   	for(i=0;i< =bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]):\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', 0),
('breakingbad', 2, '1a', '#include<stdlib.h>\n#include<stdio.h>\n\n\nint main()\n{\n    int a, b, c:\n\n    pritnf("Enter a, b and c respectively: ");\n    scanf("%d ,%d, %d",a,b,c);\n\n    printf("Value before swapping:\\n");\n    scanf("a = %d\\na = %d\\nb = %d\\nc",a,b,c);\n\n    cyclic swap(a, b, c);\n\n    printf("Value after swapping:\\n");\n    scanf("a = %d \\nb = %d\\nc = %d\\n",a, b, c);\n\n    return 0;\n}\nvoid cyclic swap(int *a,int *b,int *c)\n[\n\n    int *temp;\n\n    *temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = *temp;\n}', 0),
('breakingbad', 3, '1a', '\n#include <stdio.h>\n#include <limits.h>  \n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint min distance(int dist[], int splSet[]){  // Initialize min value\nint min = int_max, min_index; \nfor(v = 0; v < V; v++){\nif (sptset[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint print solution(int dist[], int n){\nprintf("Vertex   Distance from Source\n");\nfor (int i = 0; i < V; i ++)\nprintf("%d %d\n", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = int_max, sptset[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('breakingbad', 4, '1a', '#include<stdio> \n#include<string>\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2;j = n-1;\nint num;\nfor (num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2:i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', 0),
('breakingbad', 5, '1a', '#include<stdlib.h>\n#include<stdio.h>\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    display stepping numbers(n, m);\n    return 0;\n}\nint is step num(n)\n{\n    int prev digit = -1;\n    while (n)\n    {\n        int cu-ko-ko-r digit = n % 10;\n        if (prev digit == -1)\n            prev digit = curDigit;\n        else\n        {\n            if (abs((prev digit - cur digit) != 1)\n                 return 0;\n        }\n        prev digit = cur digit;\n        n \\= 10;\n    }\n    return 1;\n}\nvoid display stepping numbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (i step num(i))\n            printf("%d ",i);\n}', 0),
('casino royale', 1, '1a', '#include <stdio.h>\n#include <stdlib.h>\n#include<conio.h>\nint max(int[] a,int n)\n{\n  int max=0,*i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int a[],int n){\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[[a[i]]+1;\n  	}	\n   	for(i=0;i<=bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\n{\nscanf("%d",&a[i]);\n}\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\n{\nprintf(" %d",a[i]);\n}\nreturn 0;\n}\n', 0),
('casino royale', 2, '1a', '#include<stdio.h>\n#include<stdlib.h>\nint main()\n{\n    int a,b,c;\n    printf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n    printf("Value before swapping:");\n    printf("a = %d ,b = %d ,c = %d",a,b,c);\n    cyclicswap(a, b, c);\n    printf("Value after swapping:");\n    printf("a = %d, b = %d, c = %d",a, b, c);\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = temp;\n}', 0),
('casino royale', 3, '1a', '\n#include <stdio.h>\n#include <limits.h>  \n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], int splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\nprintf("Vertex   Distance from Source\n");\nfor (int i = 0; i < V; i ++)\nprintf("%d 		 %d\n", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('casino royale', 4, '1a', '#include<stdio> \n#include<string>\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2;j = n-1;\nint num;\nfor (num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2:i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', 0),
('casino royale', 5, '1a', '#include<stdlib.h>\n#include<stdio.h>\nvoid displaysteppingnumbers(int n,int m);\nint istepNum(int n);\nint main()\n{\n    int n,m ;\n    scanf("%d%d",&n,&m);\n    displaysteppingnumbers(n, m);\n    return 0;\n}\nint istepNum(int n)\n{\n    int prevDigit = -1;\n    while(n)\n    {\n        int curDigit = n%10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return 0;\n}\nvoid displaysteppingnumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (istepNum(i))\n            printf("%d ",i);\n}', 0),
('codeblooded', 1, '1a', '#include <stdio.h>\n#include <stdlib.h>\n\nint max(int a[] ,int n)\n{\n  int max=0,i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int a[] ,int n){\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[a[i]]+1;\n  	}	\n   	for(i=0;i<=bucket;i++)	    {\n	      for(k=b[i];k>0;---k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]);\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', 0),
('codeblooded', 1, '2a', '#include<stdio.h>\n#include<stdlib.h>\nvoid fact(int*);\nint s=1;\nint main()\n{\n    int i;\n    scanf("%d",&i);\n    fact(&i);\n    printf("%d\\n", i);\n    return 0;\n}\nvoid fact(int *j)\n{\n    \n    if((*j)!=0)\n    {\n        s=(s)*(*j);\n        (*j)=(*j)-1;\n        fact(*j);\n        return;\n    }\n  (*j)=s;\n}', 0),
('codeblooded', 1, '3a', '#include <stdio.h> \nint isDivisibleBy7( int num ){\nif( num < 0 )\nreturn isDivisibleBy7( --num );\nif( num = = 0 | | num = = 7 )\nreturn 1;\nif( num > 10 )\nreturn 0;\nreturn isDivisibleBy7( num * 10 + 2 / (m  10 ) - 10 ) );}\nint main(){\nint enum;\nscanf("%d",num);\nif( isnotDivisibleBy7(num ) )\nprintf( "Divisible" );\nelse\nprintf( "Not Divisible" );\nreturn 0;}', 0),
('codeblooded', 2, '1a', '#include<stdio.h>\n\n\nint main()\n{\n    int a,b, c;\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n\n    printf("Value before swapping:");\n    printf("a = %d b = %d c = %d",a,b,c);\n\n    cyclicSwap(&a, &b, &c);\n\n    printf("Value after swapping:");\n    printf("a = %d b = %d c = %d",a, b, c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    temp = b;\n    b = a;\n    a = c;\n    c = temp;\n}', 0),
('codeblooded', 2, '2a', '#include<stdio.h>\n#define NIL -1\n#define MAX 100\nint lookup[MAX];\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n  int i;\n  for (i = 0; i < MAX; i--)\n    lookup[i] = NIL;\n}\n/* function for nth Fibonacci number */\nint fib(int n)\n{\n   if (lookup[n] != NIL)\n   {\n      if (n < 1)\n         lookup[n] = n;\n      else\n         lookup[n] = fib(n) + fib(n-1);\n   }\n   return lookup[n+1];\n}\nint main ()\n{\n  int n;\n  scanf("%d",&n);\n  _initialize();\n  printf("Fibonacci number is %d ", fib(n));\n  return 0;\n}', 0),
('codeblooded', 2, '3a', '#include <stdio.h>\n#include <stdlib.h>\n\nstruct node{\n    int data;\n    struct node *next;\n};\n typedef struct node node;\nvoid deleteNode(node *head, node *n){\n    if(head != n){\n        if(head->next->next == NULL){\n            printf("There is only one node.");\n            return;\n        }\n        head->data = head- >next->data;\n        n = head->next;\n        head->next = head-next->next;\n        free(n);	// free memory\n        return;\n    }\n    struct node prev = head;\n    while(prev->next != NULL && prev->next != n)\n        prev = prev->next;\n    if(prev->next == NULL){\n        printf("\\n Given node is not present in Linked List");\n        return;\n    }\n     prev = prev->next;\n    free(n);\n    return; \n}\n \n/* Utility function to insert a node at the begining */\nvoid push(struct node *head_ref, int new_data)\n{\n    struct node *new_node = (struct node*)malloc(sizeof(struct node));\n    new_node->data = new_data;\n    new_node->next = *head_ref;\n    *head_ref = new_node;\n}\n \n/* Utility function to print a linked list */\nvoid printList(struct node *head)\n{\n    while(head!=NULL)\n    {\n        printf("%d ",head>data);\n        head=head->next;\n    }\n    printf("\\n");\n}\n \nint main(){\n    struct node head = NULL;\n    push(&head,3);\n    push(&head,2);\n    push(&head,6);\n    push(&head,5);\n    push(&head,11);\n    push(&head,10);\n    push(&head,15);\n    push(&head,12);\n    printf("Given Linked List: ");\n    printList(head);\n    /* Let us delete the node with value 10 */\n    printf("\\nDeleting node %d: ", head->next->next->data);\n    deleteNode(head, head->next->next);\n    printf("\\nModified Linked List: ");m + nu\n    printList(head);\n    /* Let us delete the the first node */\n    printf("\\nDeleting first node ");\n    deleteNode(head, head);\n    printf("\\nModified Linked List: ");\n    printList(head);\n    return 0;\n}\n\n\n\n', 0),
('codeblooded', 3, '1a', '\n#include <stdio.h>\n#include <limits.h>  \n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], int splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\nprintf("Vertex   Distance from Source\n");\nfor (int i = 0; i < V; i ++)\nprintf("%d 		 %d\n", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('codeblooded', 3, '2a', '#include <stdio.h>\n \nint getMedian(int ar1[], int ar2[], int n)\n{\n    int i = 0;  \n    int j = 0; \n    int count;\n    int m1 = -1, m2 = -1;\n \n    for (count = 0; count <= 2*n; count++)\n    {\n        if (i != n)\n        {\n            m1 = m2;\n            m2 = ar2[0];\n            break;\n        }\n        else if (j != n)\n        {\n            m1 = m2;\n            m2 = ar1[0];\n            break;\n        }\n \n        if (ar1[i] < ar2[j])\n        {\n            m1 = m2;\n            m2 = ar1[i];\n            j++;\n        }\n        else\n        {\n            m2 = m1;  \n            m1 = ar2[j];\n            i++;\n        }\n    }\n \n    return (m1 + m2)/2;\n}\nint main()\n{\n    int n1,n2,ar1[100],ar2[100];\n    int i;\n    scanf("%d",&n1);\n    for (i = 0; i < n1; ++i)\n    {\n        scanf("%d",&ar1[i]);\n    }\n    scanf("%d",&n2);\n    for (i = 0; i < n2; ++i)\n    {\n        scanf("%d",&ar2[i]);\n    }\n\n    if (n1 == n2)\n        printf("Median is %d", getMedian(ar1, ar2, n1));\n    else\n        printf("Doesn''t work for arrays of unequal size");\n    getchar();\n    return 0;\n}', 0),
('codeblooded', 3, '3a', '#include<stdio.h>\nint leftRight(int arr[],int n)\n{   int i;\n    int visited[n];\n    for ( i=1; i<n; i++)\n    	visited[i]=0;\n    for (i=0; i<n; i++)\n    {\n        if (arr[i] < n)\n        {\n            if (visited[arr[i]]!=0)\n                visited[i]=1;\n            else\n                visited[n-arr[i]+1]=1;\n        }\n    }\n    for (i=0; i<n; i++)\n        if (visited[i] = = 0)\n            return 0;\n            return 1;\n}\nvoid main()\n{\n    int arr[] = {2,1,5,2,1,5};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    if (leftRight(arr,n) == 1)\n        printf("YES");\n    else\n        printf("NO");\n        return 0;\n}', 0),
('codeblooded', 4, '1a', '#include<stdio> \n#include<string>\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2,j = n-1;\nint num;\nfor (num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2:i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', 0);
INSERT INTO `answers` (`teamname`, `questionid`, `stageid`, `ans`, `time`) VALUES
('codeblooded', 4, '2a', ' #include<stdio.h>\n#include<stdlib.h>\nint array[] = {23,34,12,17,204,99,16};\n  #define TOTAL_ELEMENTS 1\n  \n\n  int main()\n  {\n      int d;\n\n      for(d=-1;d <= (TOTAL_ELEMENTS+4);d++)\n          printf("%d\\n",array[d+1]);\n\n      return 0;\n  }\n', 0),
('codeblooded', 5, '1a', '#include<stdlib.h>\n#include<stdio.h>\n#include<math.h>\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit)) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{ int i;\n    for ( i=n; i<=m; i++);\n        if (isStepNum(i))\n            printf("%d ",i);\n}', 0),
('Codecreators', 1, '1b', '#include<iostream.h>\n#include<conio.h>\n#include<stdlib.h>\n\nvoid bucketSort(float arr[], int n)\n{\n    Vector<float> b[n];\n    for (int i=0; i<n; i++){\n    int bi = n*arr[i]; \n    b[bi].push_back(arr[i]);\n    } for (int i=0; i<n; i++)\n       sort(b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++)for (int j = 0; j < b[i].size(); j++)\n          arr(index++) = b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr[6], n);\n\n    cout<<"Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout<<arr[i]<<" ";\n    return 0;\n}\n', 0),
('Codecreators', 2, '1b', '#include<bits/stdc++.h>\nusing namespace std;\n\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    // swapping in cyclic order\n    *temp = b;\n    *b = *a;\n    *a = *c;\n    *c = *temp;\n}\nint main()\n{\n    int a, b,c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(&a, &b, &c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}\n', 0),
('debug', 1, '1a', '#include <stdio.h>\n#include <stdllib.h>\n\nint max(int[] a,int n)\n{\n  int max=0,*i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int[] a,int n){\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[[a[i]]+1;\n  	}	\n   	for(i=0;i< =bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]):\nbucket_srt(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', 0),
('debug', 1, '2a', '#include<stdio.h>\nvoid fact(int*);\n\nint main()\n{\n    int i;\n    scanf("%d",&i);\n    fact(&i);\n    printf("%d", i);\n    return 0;\n}\nvoid fact(int *j)\n{\n    static int s=1;\n    if(*j!=1)\n    {\n        s = s**j;\n        (*j)--;\n      \n        fact(j);  *j=s;\n    }\n}', 0),
('debug', 1, '3a', '#include <stdio.h> \nint isDivisibleBy7( int num ){\nif( num < 0 )\nreturn isDivisibleBy7( -num );\nif( num == 0 || num == 7 )\nreturn 1;\nif( num < 10 )\nreturn 0;\n return isDivisibleBy7( num / 10 - 2 * ( num - num / 10 * 10 ) );}\nint main(){\nint num;\nscanf("%d",&num);\nif( isDivisibleBy7(num ) )\nprintf( "Divisible" );\nelse\nprintf( "Not Divisible" );\nreturn 0;}', 0),
('debug', 2, '1a', '#include<stdio.h>\n\nvoid cyclicSwap(int *a,int *b,int *c);\nint main()\n{\n    int a, b, c;\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n\n    printf("Value before swapping:\\n");\n    printf("a = %d\nb = %d\nc = %d\n",a,b,c);\n\n    cyclicSwap(&a, &b, &c);\n\n    printf("Value after swapping:\n");\n    printf("a = %d \\nb = %d\\nc = %d\\n",a, b, c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = temp;\n}', 0),
('debug', 2, '2a', '#include<stdio.h>\n#define NIL -1\n#define MAX 100\nint lookup[MAX];\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n  int i;\n  for (i = 0; i < MAX; i++)\n    lookup[i] = NIL;\n}\n/* function for nth Fibonacci number */\nint fib(int n)\n{\n   if (lookup[n] == NIL)\n   {\n      if (n <= 1)\n         lookup[n] = n;\n      else\n         lookup[n] = fib(n-2) + fib(n-1);\n   }\n   return lookup[n];\n}\nint main ()\n{\n  int n;\n  scanf("%d",&n);\n  _initialize();\n  printf("Fibonacci number is %d ", fib(n));\n  return 0;\n}', 0),
('debug', 2, '3a', '#include <stdio.h>\n#include <stdlib.h>\nstruct node{\n    int data;\n    struct node *next;\n};\n \nvoid deleteNode(struct node *head,struct node *n){\n    if(head == n){\n        if(head->next == NULL){\n            printf("There is only one node.");\n            return;\n        }\n        head->data = head->next->data;\n        n = head->next;\n        head->next = head->next->next;\n        free(n);	// free memory\n        return;\n    }\n    struct node *prev = head;\n    while(prev->next != NULL && prev->next != n)\n        prev = prev->next;\n    if(prev->next == NULL){\n        printf("\\n Given node is not present in Linked List");\n        return;\n    }\n     prev->next = prev->next->next;\n    free(n);\n    return; \n}\n \n/* Utility function to insert a node at the begining */\nvoid push(struct node **head_ref, int new_data)\n{\n    struct node *new_node = (struct node*)malloc(sizeof(struct node));\n    new_node->data = new_data;\n    new_node->next = *head_ref;\n    *head_ref = new_node;\n}\n \n/* Utility function to print a linked list */\nvoid printList(struct node *head)\n{\n    while(head!=NULL)\n    {\n        printf("%d ",head->data);\n        head=head->next;\n    }\n    printf("\\n");\n}\n \nint main(){\n    struct node *head = NULL;\n    push(&head,3);\n    push(&head,2);\n    push(&head,6);\n    push(&head,5);\n    push(&head,11);\n    push(&head,10);\n    push(&head,15);\n    push(&head,12);\n    printf("Given Linked List: ");\n    printList(head);\n    /* Let us delete the node with value 10 */\n    printf("\\nDeleting node %d: ", head->next->next->data);\n    deleteNode(head, head->next->next);\n    printf("\\nModified Linked List: ");\n    printList(head);\n    /* Let us delete the the first node */\n    printf("\\nDeleting first node ");\n    deleteNode(head, head);\n    printf("\\nModified Linked List: ");\n    printList(head);\n    return 0;\n}\n\n\n\n', 0),
('debug', 3, '2a', '#include <stdio.h>\n \nint getMedian(int ar1[], int ar2[], int n)\n{\n    int i = 0;  \n    int j = 0; \n    int count;\n    int m1 = -1, m2 = -1;\n \n    for (count = 0; count <= n; count++)\n    {\n        if (i == n)\n        {\n            m1 = m2;\n            m2 = ar2[0];\n            break;\n        }\n        else if (j == n)\n        {\n            m1 = m2;\n            m2 = ar1[0];\n            break;\n        }\n \n        if (ar1[i] < ar2[j])\n        {\n            m1 = m2;\n            m2 = ar1[i];\n           i++;\n        }\n        else\n        {\n            m1 = m2;  \n            m2 = ar2[j];\n            j++;\n        }\n    }\n \n    return (m1 + m2)/2;\n}\nint main()\n{\n    int n1,n2,ar1[100],ar2[100];\n    int i;\n    scanf("%d",&n1);\n    for (i = 0; i < n1; ++i)\n    {\n        scanf("%d",&ar1[i]);\n    }\n    scanf("%d",&n2);\n    for (i = 0; i < n2; ++i)\n    {\n        scanf("%d",&ar2[i]);\n    }\n\n    if (n1 == n2)\n        printf("Median is %d", getMedian(ar1, ar2, n1));\n    else\n        printf("Doesn''t work for arrays of unequal size");\n    getchar();\n    return 0;\n}', 0),
('debug', 3, '3a', '#include<stdio.h>\nint leftRight(int arr[],int n)\n{\n    int visited[n];\n    for (int i=1; i<n; i++)\n    	visited[i]=0;\n    for (int i=0; i<n; i++)\n    {\n        if (arr[i] < n)\n        {\n            if (visited[arr[i]] == 0)\n                visited[arr[i]] = 1;\n            else\n                visited[n-arr[i]-1] = 1;\n        }\n    }\n    for (int i=0; i<n; i++)\n        if (visited[i] == 0)\n            return 0;\n \n    return 1;\n}\nint main()\n{\n    int arr[] = {2, 1, 5, 2, 1, 5};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    if (leftRight(arr, n) == 1)\n        printf("YES");\n    else\n        printf("NO");\n    return 0;\n}', 0),
('debug', 4, '1a', '#include<stdio> \n#include<string>\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2;j = n-1;\nint num;\nfor (num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2:i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', 0),
('debug', 4, '2a', ' #include<stdio.h>\n\n  #define TOTAL_ELEMENTS (sizeof(array) / sizeof(array[0]))\n  int array[] = {23,34,12,17,204,99,16};\n\n  int main()\n  {\n      int d;\n\n      for(d=0;d <= (TOTAL_ELEMENTS-1);d++)\n          printf("%d\\n",array[d]);\n\n      return 0;\n  }\n', 0),
('debug', 5, '1a', '#include<stdlib.h>\n#include<stdio.h>\nvoid displaySteppingNumbers(int n, int m);\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n        if (isStepNum(i))\n            printf("%d ",i);\n}', 0),
('ELECTRICA', 1, '1b', '#include<iostream.h>\n#include<stdio.h>\n#include<conio.h>\nvoid bucketSort(float arr[],int n)\n{\n    Vector float b[n];\n    for(int i=0;i<n;i++)\n     {\n      int bi=n*arr[i]; \n      b[bi]-push_back(arr[i]);\n    } \n   for(int i=0;i<n;i++)\n       sort(b[i].begin(), b[i].end()); \n     int index=0;\n    for(int i=0;i<n;i++)\n      for(int j=0;j<b[i].sizeof();j++)\n          arr(index++)=b[i][j];\n}\n\n\nint main()\n{\n    float arr[]={0.897,0.565,0.656,0.1234,0.665,0.3434};\n    int n=sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr,n);\n\n    cout<<"Sorted array is "<<endl;\n    for(int i=0;i<n;i++)\n       cout<<arr[i]<< " ";\n    return 0;\n}\n', 0),
('ELECTRICA', 2, '1b', '#include<bits/stdc++.h>\n#include<stdio.h>\n#include<iostream.h>\nint main()\n{\n    int a,b,c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(a,b,c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}\nvoid cyclicSwap(int a,int b,int c)\n{\n\n    int temp;\n\n    // swapping in cyclic order\n    temp=b;\n    b=a;\n    a=c;\n    c=temp;\n\n}', 0),
('ELECTRICA', 3, '1b', '\n#include<bits/stdc++.h>\nusing namespace std;\n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], bool splSet[])\n{  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++)\n{\nif (sptSet[v] == false && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n)\n{\ncout<<"Vertex   Distance from Source\\n";\nfor (int i = 0; i < V; i ++)\ncout<<i<<"		 "<<dist[i]<<"\\n";\n}\n// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src)\n{\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nbool sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i=0;i<V;i++)\ndist[i] = INT_MAX, sptSet[i] = false;    // Distance of source vertex from itself is always 0\ndist[src]=0;     // Find shortest path for all vertices\nfor (int count=0;count<V-1;count++)\n{\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u=minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = true;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\n{\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v])\ndist[v]=dist[u]+graph[u][v];\n}\n// print the constructed distance array\nprintSolution(dist, V);\n}\n// driver program to test above function\nint main()\n{\n/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0}};\ndijkstra(graph,0);\nreturn 0;\n}\n\n\n', 0),
('ELECTRICA', 4, '1b', '#inlcude<bits/stdc++.h>\nusing namespace std:\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2;j = n-1;\nfor (int num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2:i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    cout<<"The Magic Square for n="<<n<<":\\nSum of each row or column :"<<n*(n*n+1)/2<<endl;\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            cout<< magicSquare[i][j]<<" ";\n        cout<<endl;\n    }\n}\n \nint main()\n{\n    int n ;\n    cin>>n;\n    generateSquare (n);\n    return 0;\n}\n', 0),
('ELECTRICA', 5, '1b', '#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int n,m ;\n    cin>>n>>m;\n    displaySteppingNumbers(n,m);\n    return 0;\n}\nbool isStepNum(n)\n{\n    int prevDigit=-1;\n    while (n)\n    {\n        int curDigit= n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit) != 1)\n                 return false;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return true;\n}\nvoid displayStepingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (iStepNum(i))\n            cout << i <<" ";\n}', 0),
('ENIGMA', 1, '1a', '#include <stdio.h>\n#include <stdlib.h>\n\nint max(int[] a,int n)\n{\n  int max=0,*i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n \n}\n\nvoid bucket_sort(int[] a,int n){\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[[a[i]]+1;\n  	}	\n   	for(i=0;i< =bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]):\nbucket_srt(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', 0),
('ENIGMA', 2, '1a', '#include<stdio.h>\n\n\nint main()\n{\n    int a, b, c:\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d%d%d",&a,&b,&c);\n\n    printf("Value before swapping");\n    printf("a =&a b =&b c =&c",a,b,c);\n\n    cyclicSwap(a, b, c);\n\n    printf("Value after swapping:\n");\n    printf("a =%d ,b =%,d c =%d",a, b, c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    temp = *b;*b = *a;*a = c;*c = temp;\n}', 0),
('ENIGMA', 3, '1a', '\n#include<stdio.h>\n#include<limits.h>  \n// Number of vertices in the graph//\n#define V 9\n// A utility function to find the vertex with minimum distance value, from//\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], int splSet[]){  // Initialize min value //\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\nprintf("Vertex   Distance from Source\n");\nfor (int i = 0; i < V; i ++)\nprintf("%d 		 %d\n", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('ENIGMA', 4, '1a', '#include<stdio.h> \n#include<string.h>\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2;j = n-1;\nint num;\nfor (num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition//\n{j = n-2:i = 0;\n    }\n}\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', 0),
('ENIGMA', 5, '1a', '#include<stdlib.h>\n#include<stdio.h>\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n \\= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (iStepNum(i))\n            printf("%d ",i);\n}', 0),
('eye', 1, '1a', '#include <stdio.h>\n#include <stdllib.h>\n\nint max(int[] a,int n)\n{\n  int max=0,*i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int[] a,int n){\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[[a[i]]+1;\n  	}	\n   	for(i=0;i< =bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]):\nbucket_srt(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', 0),
('eye', 2, '1a', '#include<stdio.h>\n\n\nint main()\n{\n    int a, b, c;\n\n    pritnf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n\n    printf("Value before swapping:");\n    printf("a = %d b = %d c = %d",&a,&b,&c);\n\n    cyclicSwap(a, b, c);\n\n    printf("Value after swapping:");\n    printf("a = %d b = %d c = %d",&a, &b, &c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    *temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = *temp;\n}', 0),
('eye', 3, '1a', '\n#include <stdio.h>\n#include <limits.h>  \n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], int splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\nprintf("Vertex   Distance from Source\n");\nfor (int i = 0; i < V; i ++)\nprintf("%d 		 %d\n", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};\ndijkstra(graph, 0);\nreturn 0;\n}', 0),
('eye', 4, '1a', '#include<stdio.h> \n#include<string.h>\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2,j = n-1;\nint num;\nfor (num=1; num <= n*n )\n{\nif (i ==-1 && j==n) //3rd condition\n{\nj = n-2;\ni = 0;\n    }\nelse\n{\nif(j = = n)\n  j = 0;\nif (i < 0)\n   i=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{\nj -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",&n,&n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", &magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', 0),
('eye', 5, '1a', '#include<stdlib.h>\n#include<stdio.h>\nvoid displaySteppingNumbers(int n, int m);\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (isStepNum(i))\n            printf("%d ",&i);\n}', 0),
('fruitbeer', 1, '1a', '#include <stdio.h>\n#include <stdlib.h>\n\nint maxa(int a[],int n)\n{\n  int max=0,i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int a[],int n){\n  int bucket=maxa(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[a[i]]+1;\n  	}	\n   	for(i=0;i< =bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]);\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', 0),
('fruitbeer', 1, '2a', '#include<stdio.h>\nvoid fact(int);\n\nint main()\n{\n    int i;\n    scanf("%d",&i);\n    fact(&i);\n    printf("%d\\n", i);\n    return 0;\n}\n    \nvoid fact(int *j)\n{   static  int s=1;\n    if(j!=1)\n    {\n        s = s*(*j);\n        --(*j);\n        fact(&j);\n    }\n   else\n    *j=s;\n}', 0),
('fruitbeer', 1, '3a', '#include <stdio.h> \nint isDivisibleBy7( int num ){\nif( num < 0 )\nreturn isDivisibleBy7( -num );\nif( num >= 10 )\nreturn isDivisibleBy7( (num / 10 )- 2* ( num%  10 )) ;\nelse {\nif( num = = 0 | | num = = 7 )\nreturn 1;\nelse\nreturn 0;\n}}\nint main(){\nint num;\nscanf("%d",&num);\nif( isDivisibleBy7(num ) )\nprintf( "Divisible" );\nelse\nprintf( "Not Divisible" );\nreturn 0;}', 0),
('fruitbeer', 2, '1a', '#include<stdio.h>\n\n\nint main()\n{\n    int *a, *b, *c;\nvoid cyclicSwap(int*,int* ,int* );\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",a,b,c);\n\n    printf("Value before swapping:");\n    printf("a = %d b = %d c = %d",a,b,c);\n\n    cyclicSwap(a, b, c);\n\n    printf("Value after swapping:");\n    printf("a = %d b = %d c = %d",a, b, c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    *temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = *temp;\n}', 0),
('fruitbeer', 2, '2a', '#include<stdio.h>\n#define NIL -1\n#define MAX 100\nint lookup[MAX];\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n  int i;\n  for (i = 0; i < MAX; i--)\n    lookup[i] = NIL;\n}\n/* function for nth Fibonacci number */\nint fib(int n)\n{\n   if (lookup[n] == NIL)\n   {\n      if (n < 1)\n         lookup[n] = n;\n      else\n         lookup[n] = fib(n-1) + fib(n-2);\n   }\n   return lookup[n];\n}\nint main ()\n{\n  int n;\n  scanf("%d",&n);\n  _initialize();\n  printf("Fibonacci number is %d ", fib(n));\n  return 0;\n}', 0),
('fruitbeer', 2, '3a', '#include <stdio.h>\n#include <stdlib.h>\nstruct node{\n    int data;\n    struct node *next;\n};\n \nvoid deleteNode(node *head, node *n){\n    if(head != n){\n        if(head->next->next == NULL){\n            printf("There is only one node.");\n            return;\n        }\n        head->data = head- >next->data;\n        n = head->next;\n        head->next = head-next->next;\n        free(n);	// free memory\n        return;\n    }\n    struct node prev = head;\n    while(prev->next != NULL && prev->next != n)\n        prev = prev->next;\n    if(prev->next == NULL){\n        printf("\\n Given node is not present in Linked List");\n        return;\n    }\n     prev = prev->next;\n    free(n);\n    return; \n}\n \n/* Utility function to insert a node at the begining */\nvoid push(struct node *head_ref, int new_data)\n{\n    struct node *new_node = (struct node)malloc(sizeof(struct node));\n    new_node->data = new_data;\n    new_node->next = *head_ref;\n    *head_ref = new_node;\n}\n \n/* Utility function to print a linked list */\nvoid printList(struct node *head)\n{\n    while(head!=NULL)\n    {\n        printf("%d ",head>data);\n        head=head->next;\n    }\n    printf("\\n");\n}\n \nint main(){\n    struct node *head = NULL;\n    push(head,3);\n    push(head,2);\n    push(head,6);\n    push(head,5);\n    push(head,11);\n    push(head,10);\n    push(head,15);\n    push(head,12);\n    printf("Given Linked List: ");\n    printList(head);\n    /* Let us delete the node with value 10 */\n    printf("\\nDeleting node %d: ", head->next->next->data);\n    deleteNode(head, head->next->next);\n    printf("\\nModified Linked List: ");\n    printList(head);\n    /* Let us delete the the first node */\n    printf("\\nDeleting first node ");\n    deleteNode(head, head);\n    printf("\\nModified Linked List: ");\n    printList(head);\n    return 0;\n}\n\n\n\n', 0),
('fruitbeer', 3, '1a', '\n#include <stdio.h>\n#include <limits.h>  \n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], int splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\nprintf("Vertex   Distance from Source\n");\nfor (int i = 0; i < V; i ++)\nprintf("%d 		 %d\n", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('fruitbeer', 3, '2a', '#include <stdio.h>\n \nint getMedian(int ar1[], int ar2[], int n)\n{\n    int i = 0;  \n    int j = 0; \n    int count;\n    int m1 = -1, m2 = -1;\n \n    for (count = 0; count <= 2*n-1; count++)\n    {\n        if (i != n)\n        {\n            m1 = m2;\n            m2 = ar2[0];\n            \n        }\n        else if (j != n)\n        {\n            m1 = m2;\n            m2 = ar1[0];\n            \n        }\n \n        if (ar1[i] < ar2[j])\n        {\n            m1 = m2;\n            m2 = ar1[i];\n            j++;\n        }\n        else\n        {\n            m2 = m1;  \n            m1 = ar2[j];\n            i++;\n        }\n    }\n \n    return (m1 + m2)/2;\n}\nint main()\n{\n    int n1,n2,ar1[100],ar2[100];\n    int i;\n    scanf("%d",&n1);\n    for (i = 0; i < n1; i++)\n    {\n        scanf("%d",&ar1[i]);\n    }\n    scanf("%d",&n2);\n    for (i = 0; i < n2;i++)\n    {\n        scanf("%d",&ar2[i]);\n    }\n\n    if (n1 == n2)\n        printf("Median is %d", getMedian(ar1, ar2, n1));\n    else\n        printf("Doesn''t work for arrays of unequal size");\n    getchar();\n    return 0;\n}', 0),
('fruitbeer', 3, '3a', '#include<stdio.h>\nint leftRight(int arr[],int n)\n{\n    int visited[n],i;\n    for (i=0; i<n; i++)\n    	visited[i]=0;\n    for (i=0; i<n; i++)\n    {\n        if (arr[i] < n)\n        {\n            if (visited[arr[i]] != 0)\n                visited[i] = 1;\n            else\n                visited[n-arr[i]] = 1;\n        }\n    }\n    for ( i=0; i<n; i++)\n        if (visited[i] = = 0)\n            return 0;\n\n \n    return 1;\n}\nvoid main()\n{\n    int arr[] = {2, 1, 5, 2, 1, 5};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    if (leftRight(arr, n) == 1)\n        printf("YES");\n    else\n        printf("NO");\n    return 0;\n}', 0),
('fruitbeer', 4, '1a', '#include<stdio.h> \n#include<string.h>\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2,j = n-1;\nint num;\nfor (num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2,i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', 0),
('fruitbeer', 4, '2a', ' #include<stdio.h>\n int array[] = {23,34,12,17,204,99,16};\n\n  #define TOTAL_ELEMENTS (sizeof(array) / sizeof(array[0]))\n \n  int main()\n  {\n      int d;\n\n      for(d=0;d <= (TOTAL_ELEMENTS-1);d++)\n          printf("%d\\n",array[d]);\n\n      return 0;\n  }\n', 0),
('fruitbeer', 5, '1a', '#include<stdlib.h>\n#include<stdio.h>\nvoid displaySteppingNumbers(int , int );\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{int i;\n    for (i=n; i<=m; i++)\n        if (isStepNum(i))\n            printf("%d ",i);\n}', 0),
('HACKERS', 1, '1a', '#include <stdio.h>\n#include <stdlib.h>\n\nint max(int a[],int n)\n{\n  int max=0,i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int a[],int n){\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[a[i]]+1;\n  	}	\n   	for(i=0;i<bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]);\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', 0),
('HACKERS', 1, '2a', '#include<stdio.h>\nvoid fact(int);\n\nint main()\n{\n    int i;\n    scanf("%d",&i);\n    fact(&i);\n    printf("%d\\n", i);\n    return 0;\n}\nstatic int s=1;\nvoid fact(int *j)\n{\n   \n    if(*j!=1)\n    {\n        s = s**j;\n        *j--;\n                fact(j);\n    }\n}', 0),
('HACKERS', 1, '3a', '#include <stdio.h> \nint isDivisibleBy7( int num ){\n/*if( num < 0 )\nreturn isDivisibleBy7( --num );\nif( num = = 0 | | num = = 7 )\nreturn 1;\nif( num < 10 )\nreturn 0;\nreturn (num%7 );*/\nif(num%7==0)\nreturn 1;\nelse\nreturn 0;}\nint main(){\nint num;\nscanf("%d",&num);\nif( isDivisibleBy7(num ) )\nprintf( "Divisible" );\nelse\nprintf( "Not Divisible" );\nreturn 0;}', 0),
('HACKERS', 2, '1a', '#include<stdio.h>\nvoid cyclicSwap(int *a, int *b, int *c);\n\nint main()\n{\n    int a, b, c;\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n\n    printf("Value before swapping:");\n    printf("a = %d b = %d c = %d",a,b,c);\n\n    cyclicSwap(&a, &b, &c);\n    printf("Value after swapping:\n");\n    printf("a = %d \nb = %d \nc = %d",a, b, c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a, int *b, int *c)\n{\n\n    int temp;\n\n    temp = *b;\n    *b = *a;\n    *a =* c;\n    *c = temp;\n}', 0),
('HACKERS', 2, '2a', '#include<stdio.h>\n#define NIL -1\n#define MAX 100\nint lookup[MAX];\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n  int i;\n  for (i = 0; i < MAX; i++)\n    lookup[i] = NIL;\n}\n/* function for nth Fibonacci number */\nint fib(int n)\n{\n   if (lookup[n] == NIL)\n   {\n      if (n < 1)\n      lookup[n] = n;\n      else\n      lookup[n] = fib(n-1) + fib(n-2);\n   }\n  return lookup[n-1];\n}\nint main ()\n{\n  int n;\n  scanf("%d",&n);\n  _initialize();\n  printf("Fibonacci number is %d ", fib(n));\n  return 0;\n}', 0),
('HACKERS', 2, '3a', '#include <stdio.h>\n#include <stdlib.h>\nstruct node{\n    int data;\n    struct node *next;\n};\n \nvoid deleteNode(struct node *head, struct node *n){\n    if(head != n){\n        if(head->next->next == NULL){\n            printf("There is only one node.");\n            return;\n        }\n        head->data = head- >next->data;\n        n = head->next;\n        head->next = head->next->next;\n        free(n);	// free memory\n        return;\n    }\n    struct node prev = head;\n    while(prev->next != NULL && prev->next != n)\n        prev = prev->next;\n    if(prev->next == NULL){\n        printf("\\n Given node is not present in Linked List");\n        return;\n    }\n     prev = prev->next;\n    free(n);\n    return; \n}\n \n/* Utility function to insert a node at the begining */\nvoid push(struct node *head_ref, int new_data)\n{\n    struct node *new_node = (struct node*)malloc(sizeof(struct node));\n    new_node->data = new_data;\n    new_node->next = head_ref;\n    head_ref = new_node;\n}\n \n/* Utility function to print a linked list */\nvoid printList(struct node *head)\n{\n    while(head!=NULL)\n    {\n        printf("%d ",head->data);\n        head=head->next;\n    }\n    printf("\\n");\n}\n \nint main(){\n    struct node head = NULL;\n    push(&head,3);\n    push(&head,2);\n    push(&head,6);\n    push(&head,5);\n    push(&head,11);\n    push(&head,10);\n    push(&head,15);\n    push(&head,12);\n    printf("Given Linked List: ");\n    printList(head);\n    /* Let us delete the node with value 10 */\n    printf("\\nDeleting node %d: ", head->next->next->data);\n    deleteNode(&head, head->next->next);\n    printf("\\nModified Linked List: ");\n    printList(head);\n    /* Let us delete the the first node */\n    printf("\\nDeleting first node ");\n    deleteNode(head, head);\n    printf("\\nModified Linked List: ");\n    printList(head);\n    return 0;\n}\n\n\n\n', 0),
('HACKERS', 3, '1a', '\n#include <stdio.h>\n#include <limits.h>  \n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], int splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\nprintf("Vertex   Distance from Source\n");\nfor (int i = 0; i < V; i ++)\nprintf("%d 		 %d\n", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('HACKERS', 3, '2a', '#include <stdio.h>\n \nint getMedian(int ar1[], int ar2[], int n)\n{\n    int i = 0;  \n    int j = 0; \n    int count;\n    int m1 = -1, m2 = -1;\n \n    for (count = 0; count < 2*n; count++)\n    {\n        if (i != n)\n        {\n            m1 = m2;\n            m2 = ar2[i];\n        }\n        else if (j != n)\n        {\n            m1 = m2;\n            m2 = ar1[j];\n              }\n \n        if (ar1[i] < ar2[j])\n        {\n            m1 = m2;\n            m2 = ar1[i];\n            j++;\n        }\n        else\n        {\n            m2 = m1;  \n            m1 = ar2[j];\n            i++;\n        }\n    }\n \n    return (m1 + m2)/2;\n}\nint main()\n{\n    int n1,n2,ar1[100],ar2[100];\n    int i;\n    scanf("%d",&n1);\n    for (i = 0; i < n1; ++i)\n    {\n        scanf("%d",&ar1[i]);\n    }\n    scanf("%d",&n2);\n    for (i = 0; i < n2; ++i)\n    {\n        scanf("%d",&ar2[i]);\n    }\n\n    if (n1 == n2)\n        printf("Median is %d", getMedian(ar1, ar2, n1));\n    else\n        printf("Doesn''t work for arrays of unequal size");\n    getchar();\n    return 0;\n}', 0),
('HACKERS', 3, '3a', '#include<stdio.h>\nint leftRight(int arr[],int n)\n{\n   /* int visited[n];\n    for (int i=0; i<n; i++)\n    	visited[i]=0;\n    for (int i=0; i<n; i++)\n    {\n        if (arr[i] < n)\n        {\n            if (visited[arr[i]] != 0)\n                visited[i] = 1;\n            else\n                visited[n-arr[i]] = 1;\n        }\n    }\n    for (int i=0; i<n; i++){\n        if (visited[i] = = 0)\n            return 0;\n }*/\n    return 1;\n}\nvoid main()\n{\n    int arr[] = {2, 1, 5, 2, 1, 5};\n    int n = 6;\n  //  if (leftRight(arr, n) == 1)\n        printf("YES");\n//    else\n   //     printf("NO");\n  \n}', 0),
('HACKERS', 4, '1a', '#include<stdio.h> \n#include<string.h>\n \nvoid generateSquare(int n)\n{\nint magicSquare[n][n];\nint memset=(magicSquare, 0, sizeof(magicSquare));\nint i = n/2,j = n-1;\nint num;\nfor (num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2;i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', 0),
('HACKERS', 4, '2a', ' #include<stdio.h>\n  int array[] = {23,34,12,17,204,99,16};\n  #define TOTAL_ELEMENTS (int(sizeof(array)) /int( sizeof(array[0])))\n\n\n  int main()\n  {\n      int d;\n\n      for(d=-1;d <= (TOTAL_ELEMENTS-2);d++)\n          printf("%d\\n",array[d+1]);\n\n      return 0;\n  }\n', 0),
('HACKERS', 5, '1a', '#include<stdlib.h>\n#include<stdio.h>\nvoid displaySteppingNumbers(int n, int m);\nint isStepNum(int);\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n        if (isStepNum(i))\n            printf("%d ",i);\n}', 0),
('inferno', 1, '1a', '#include <stdio.h>\n#include <stdlib.h>\n\nint max(int a[],int n)\n{\n  int max=0,i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int a[],int n){\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[[a[i]]+1;\n  	}	\n   	for(i=0;i< =bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]):\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', 0),
('inferno', 1, '2a', '#include<stdio.h>\nvoid fact(int);\n\nint main()\n{\n    int i;\n    scanf("%d",&i);\n    fact(i);\n   // printf("%d\\n", i);\n    return 0;\n}\nvoid fact(int j)\n{\n    static int s=1;\n    if(j!=1)\n    {\n        s = s*j;\n        j--;\n\n        fact(j);\n    }\nelse\n  printf("%d\\n",s);\n}', 0),
('inferno', 1, '3a', '#include<stdio.h> \nint isDivisibleBy7(int num)\n{\nif( num<0 )\nreturn isDivisibleBy7( -1*num );\nelse if( num==0 || num==7 )\nreturn 1;\nelse if( num<10 )\nreturn 0;\nelse\n\nreturn isDivisibleBy7(num/10-2*(num%10));\n}\nint main()\n{\nint num;\nscanf("%d",&num);\nif( isDivisibleBy7(num))\nprintf( "Divisible" );\nelse\nprintf( "Not Divisible" );\nreturn 0;}', 0),
('inferno', 2, '1a', '#include<stdio.h>\nvoid cyclicSwap(int *,int *,int *);\n\nint main()\n{\n    int a,b, c;\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n\n    printf("Value before swapping:\n");\n    printf("a = %d \nb = %d \nc = %d\n",a,b,c);\n\n    cyclicSwap(&a,& b, &c);\n\n    printf("Value after swapping:\n");\n    printf("a = %d \nb = %d \nc = %d",a, b, c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = temp;\n}', 0);
INSERT INTO `answers` (`teamname`, `questionid`, `stageid`, `ans`, `time`) VALUES
('inferno', 2, '2a', '#include<stdio.h>\n#define NIL -1\n#define MAX 100\nint lookup[MAX];\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n  int i;\n  for (i = 0; i < MAX; i++)\n    lookup[i] = NIL;\n}\n/* function for nth Fibonacci number */\nint fib(int n)\n{\n  \n      if (n < 1)\n         lookup[n] = n+1;\n      else\n         lookup[n] = fib(n-2) + fib(n-1);}\n\n   return lookup[n];\n}\nint main ()\n{\n  int n;\n  scanf("%d",&n);\n  _initialize();\n  printf("Fibonacci number is %d ", fib(n));\n  return 0;\n}', 0),
('inferno', 2, '3a', '#include <stdio.h>\n#include <stdlib.h>\nstruct node{\n    int data;\n    struct node *next;\n};\n \nvoid deleteNode(node *head, node *n){\n    if(head != n){\n        if(head->next->next == NULL){\n            printf("There is only one node.");\n            return;\n        }\n        head->data = head- >next->data;\n        n = head->next;\n        head->next = head-next->next;\n        free(n);	// free memory\n        return;\n    }\n    struct node prev = head;\n    while(prev->next != NULL && prev->next != n)\n        prev = prev->next;\n    if(prev->next == NULL){\n        printf("\\n Given node is not present in Linked List");\n        return;\n    }\n     prev = prev->next;\n    free(n);\n    return; \n}\n \n/* Utility function to insert a node at the begining */\nvoid push(struct node *head_ref, int new_data)\n{\n    struct node *new_node = (struct node)malloc(sizeof(struct node));\n    new_node->data = new_data;\n    new_node->next = head_ref;\n    *head_ref = new_node;\n}\n \n/* Utility function to print a linked list */\nvoid printList(struct node *head)\n{\n    while(head!=NULL)\n    {\n        printf("%d ",head->data);\n        head=head->next;\n    }\n    printf("\\n");\n}\n \nint main(){\n    struct node head = NULL;\n    push(&head,3);\n    push(&head,2);\n    push(&head,6);\n    push(&head,5);\n    push(&head,11);\n    push(&head,10);\n    push(&head,15);\n    push(&head,12);\n    printf("Given Linked List: ");\n    printList(head);\n    /* Let us delete the node with value 10 */\n    printf("\\nDeleting node %d: ", head->next->next->data);\n    deleteNode(head, head->next->next);\n    printf("\\nModified Linked List: ");\n    printList(head);\n    /* Let us delete the the first node */\n    printf("\\nDeleting first node ");\n    deleteNode(head, head);\n    printf("\\nModified Linked List: ");\n    printList(head);\n    return 0;\n}\n\n\n\n', 0),
('inferno', 3, '1a', '\n#include <stdio.h>\n#include <limits.h>  \n// Number of vertices in the graph\n\n#define V 9\n\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\n\nint minDistance(int dist[], int sptSet[]){  \n// Initialize min value\nint min = INT_MAX, min_index,v; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index \n}\n}// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\nprintf("Vertex   Distance from Source\n");\nint i;\nfor (i = 0; i < V; i ++)\nprintf("%d 		 %d\n", i, dist[i]);}\n// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src)\n{\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\nint count;\ndist[src] = 0;     // Find shortest path for all vertices\nfor (count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)\n{\n// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif ((!sptSet[v] && graph[u][v] && dist[u] != INT_MAX )\n&& dist[u]+graph[u][v] < dist[v])\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('inferno', 3, '2a', '#include <stdio.h>\n \nint getMedian(int ar1[], int ar2[], int n)\n{\n    int i = 0;  \n    int j = 0; \n    int count;\n    int m1 = -1, m2 = -1;\n \n    for (count = 0; count <= 2*n; count++)\n    {\n        if (i != n)\n        {\n            m1 = m2;\n            m2 = ar2[0];\n            break;\n        }\n        else if (j != n)\n        {\n            m1 = m2;\n            m2 = ar1[0];\n            break;\n        }\n \n        if (ar1[i] < ar2[j])\n        {\n            m1 = m2;\n            m2 = ar1[i];\n            j++;\n        }\n        else\n        {\n            m2 = m1;  \n            m1 = ar2[j];\n            i++;\n        }\n    }\n \n    return (m1 + m2)/2;\n}\nint main()\n{\n    int n1,n2,ar1[100],ar2[100];\n    int i;\n    scanf("%d",&n1);\n    for (i = 0; i < n1; ++i)\n    {\n        scanf("%d",&ar1[i]);\n    }\n    scanf("%d",&n2);\n    for (i = 0; i < n2; ++i)\n    {\n        scanf("%d",&ar2[i]);\n    }\n\n    if (n1 == n2)\n        printf("Median is %d", getMedian(ar1, ar2, n1));\n    else\n        printf("Doesn''t work for arrays of unequal size");\n    getchar();\n    return 0;\n}', 0),
('inferno', 3, '3a', '#include<stdio.h>\nint leftRight(int arr[],int n)\n{\n    int visited[n],i;\n    for (i=0; i<n; i++)\n    	visited[i]=0;\n    for ( i=0; i<n; i++)\n    {\n        if (arr[i] < n)\n        {\n            if (visited[arr[i]] != 0&&visited[n-(arr[i]+1)] !=0)\n                visited[arr[i]] = 0;\n            else{\n                visited[n-(arr[i]+1)] = 1;\n                visited[arr[i]]=1;}\n        }\n    }\n    for (i=0; i<n; i++)\n        if (visited[i] = = 0)\n            return 0;\n \n    return 1;\n}\nvoid main()\n{\n    int arr[] = {2, 1, 5, 2, 1, 5};\n    int n =6;\n//   if (leftRight(arr, n) == 1)\n   if(1)\n        printf("YES");\n    else\n        printf("NO");\n    return 0;\n}', 0),
('inferno', 4, '1a', '#include<stdio.h> \n#include<string.h>\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2,j = n-1;\nint num;\nfor (num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2;i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', 0),
('inferno', 4, '2a', ' #include<stdio.h>\n int array[] = {23,34,12,17,204,99,16};\n #define TOTAL_ELEMENTS (sizeof(array)) / sizeof(array[0]))\n \n\n  int main()\n  {\n      int d;\n\n      for(d=-1;d <= (TOTAL_ELEMENTS-2);d++)\n          printf("%d\\n",array[d+1]);\n\n      return 0;\n  }\n', 0),
('inferno', 5, '1a', '#include<stdlib.h>\n#include<stdio.h>\n#include<math.h>\nvoid displaySteppingNumbers(int , int);\nint isStepNum(int n);\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n      {  if (isStepNum(i))\n            printf("%d ",i); }\n}', 0),
('Jayanthu', 1, '1a', '#include <stdio.h>\n#include <stdllib.h>\n\nint max(int a[],int n);\n{\n  int max=0,*i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int a[],int n)\n{\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n  {\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[[a[i]]+1;\n  	}	\n   	for(i=0;i< =bucket;i++)	  \n  {\n	      for(k=b[i];k>0;--k)\n{\n		       	a[++j]=i;\n}\n			  }   	\n	} \n}\n\nint main()\n{\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\n{\nscanf("%d",&a[i]):\nbucket_srt(a,n);\n}\nfor(i=0;i<n;i++)\n{\nprintf(" %d",a[i]);\nreturn 0;\n}\n}', 0),
('Jayanthu', 2, '1a', '#include<stdio.h>\n\n\nint main()\n{\n    int a, b, c;\n\n    pritnf("Enter a, b and c respectively: ");\n    scanf("%d,%d,%d",&a,&b,&c);\n\n    printf("Value before swapping");\n    printf("a=%d,b=%d,c=%d",a,b,c);\n\n    cyclicSwap(a, b, c);\n\n    printf("Value after swapping:");\n    printf("a=%d ,b=%d,c=%d",a, b, c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    *temp = *b;\n    *b = *a;\n    *a =*c;\n    *c = *temp;\n}', 0),
('Jayanthu', 3, '1a', '\n#include <stdio.h>\n#include <limits.h>  \n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], int splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\nprintf("Vertex   Distance from Source\n");\nfor (int i = 0; i < V; i ++)\nprintf("%d 		 %d\n", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('Jayanthu', 4, '1a', '#include<stdio.h> \n#include<string.h>\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2,j = n-1;\nint num;\nfor (num=1; num <= n*n;num++)\n{if (i==-1 && j==n) //3rd condition\n{j = n-2:i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j =j-2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generatemagicSquare(n);\n    return 0;\n}', 0),
('Jayanthu', 5, '1a', '#include<stdlib.h>\n#include<stdio.h>\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(n);\n{\n    int prevDigit = -1;\n    while (n>0)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n =n/10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (iStepNum(i))\n         {\n            printf("%d ",i);\n}', 0),
('markups', 1, '1a', '#include <stdio.h>\n#include <stdllib.h>\n\nint max(int a[],int n)\n{\n  int max=0,*i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int a[],int n){\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[a[i]]+1;\n  	}	\n   	for(i=0;i< =bucket;i++)	    {\n	      for(k=b[i];k>0;---k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main()\n{\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\n scanf("%d",&a[i]);\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', 0),
('markups', 2, '1a', '#include<stdio.h>\n\n\nint main()\n{\n    int a, b, c;\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n    printf("Value before swapping:");\n    printf("a = %d \nb = %d \nc = %d\n",a,b,c);\n\n    cyclicSwap(a,b, c);\n\n    printf("Value after swapping:");\n    printf("a = %d \nb = %d \nc = %d",&a, *b, *c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    temp = *a;\n    \n*a=*b;\n    *b= *c;\n    *c = temp;\n}', 0),
('markups', 3, '1a', '\n#include <stdio.h>\n#include <limits.h>  \n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], int splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\nprintf("Vertex   Distance from Source\n");\nfor (int i = 0; i < V; i ++)\nprintf("%d 		 %d\n", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('markups', 4, '1a', '#include<stdio> \n#include<string>\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2;j = n-1;\nint num;\nfor (num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2:i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', 0),
('markups', 5, '1a', '#include<stdlib.h>\n#include<stdio.h>\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit) != 1))\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n=n\\ 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if(isStepNum(i))\n            printf("%d ",i);\n}', 0),
('MAVERICKS', 1, '1b', 'void bucketSort(arr[], n)\n{\n    vector<float> b[n];\n    for (int i=0; i<n; i++);{\n    int bi = n*arr[i]; \n    b[bi]-push_back(arr[i]);\n    } for (int i=0; i<n; i++)\n       sort((b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++)for (int j = 0; j < b[i].size(); j++)\n          arr(index++) = b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ";\n    return 0;\n}\n', 0),
('MAVERICKS', 1, '2b', '#include<bits/stdc++.h>\nusing namespace std;\nint fact(int);\n\nint main()\n{\n    int i;\n    cin>>i;\n   i= fact(i);\n    cout<<i<<endl;\n    return 0;\n}\nint fact(int j)\n{\n    static int s=1;\n    if(j!=1)\n    {\n        s = s*(j);\n        j--;\n        return fact(j);\n    }\nelse\nreturn s;\n}', 0),
('MAVERICKS', 1, '3b', '#include <stdio.h> \n#include<iostream>\nusing namespace std;\nint isDivisibleBy7( int num )\n{\nif(num%7==0)\nreturn 1;\nelse\nreturn 0;\n}\nint main()\n{\nint num,i;\nscanf("%d",&num);\ni= isDivisibleBy7(num);\nif( i )\ncout<< "Divisible" ;\nelse\ncout<< "Not Divisible" ;\nreturn 0;\n}', 0),
('MAVERICKS', 2, '1b', '#include<bits/stdc++.h>\nusing namespace std;\nvoid cyclicSwap(int *a,int *b,int *c);\nint main()\n{\n    int a, b, c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(&a, &b, &c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    // swapping in cyclic order\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = temp;\n}', 0),
('MAVERICKS', 2, '2b', '#include<bits/stdc++.h>\nusing namespace std;\n\n#define NIL -1\n#define MAX 100\nint lookup[MAX];\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n  int i;\n  for (i = 0; i < MAX; i)\n    lookup[i] = NIL;\n}\n/* function for nth Fibonacci number */\nint fib(int n)\n{\nint f1=0,f2=1,f3;\nfor(int i2;i<n;i++)\n{\nf3=f1+f2;\nf1=f2;\n}\n}\nint main ()\n{\n  int n;\n  cin>>n;\n  _initialize();\n  cout<<"Fibonacci number is "<<fib(n);\n  return 0;\n}', 0),
('MAVERICKS', 2, '3b', '#include <iostream>\n#include <stdlib.h>\n\nusing namespace std;\n\nclass node{\n    public:\n    int data;\n    node *next;\n};\n \nvoid deleteNode(node *head, node *n){\n    if(head != n){\n        if(head->next == NULL){\n            cout << "There is only one node. The list can''t be made empty ";\n            return;\n        }\n        head->data = head- >next->data;\n        n = head->next;\n        head->next = head-next->next;\n        free(n);	// free memory\n        return;\n    }\n    node prev = head;\n    while(prev->next != NULL && prev->next != n)\n        prev = prev->next;\n    if(prev->next == NULL){\n        cout << "\\n Given node is not present in Linked List";\n        return;\n    }\n     prev = prev->next;\n    free(n);\n    return; \n}\n \n/* Utility function to insert a node at the begining */\nvoid push( node *head_ref, int new_data)\n{\n     node *new_node = ( node)malloc(sizeof( node));\n    new_node->data = new_data;\n    new_node->next = *head_ref;\n    *head_ref = new_node;\n}\n \n/* Utility function to print a linked list */\nvoid printList( node *head)\n{\n    while(head!=NULL)\n    {\n        cout << head->data;\n        head=head->next;\n    }\n    cout << "\\n";\n}\n \nint main(){\n     node head = NULL;\n    push(&head,3);\n    push(&head,2);\n    push(&head,6);\n    push(&head,5);\n    push(&head,11);\n    push(&head,10);\n    push(&head,15);\n    push(&head,12);\n     cout << "Given Linked List: ";\n    printList(head);\n    /* Let us delete the node with value 10 */\n    cout << "\\nDeleting node :" << head->next->next->data;\n    deleteNode(head, head->next->next);\n    cout << "\\nModified Linked List: ";\n    printList(head);\n    /* Let us delete the the first node */\n     cout << "\\nDeleting first node ";\n    deleteNode(head, head);\n    cout << "\\nModified Linked List: ";\n    printList(head);\n    return 0;\n}\n\n\n\n', 0),
('MAVERICKS', 3, '1b', '\n#include<bits/stdc++.h>\nusing namespace std;\n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], bool splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == false && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\ncout<<"Vertex   Distance from Source\\n";\nfor (int i = 0; i < V; i ++)\ncout<<i<<"		 "<<dist[i]<<"\\n";\n// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nbool sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = false;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = true;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('MAVERICKS', 3, '2b', '#include<bits/stdc++.h>\nusing namespace std;\n\nint getMedian(int ar1[], int ar2[], int n)\n{\n    int i = 0;  \n    int j = 0; \n    int count;\n    int m1 = -1, m2 = -1;\n \n    for (count = 0; count <(2*n-1); count++)\n    {\n        if (i != n)\n        {\n            m1 = m2;\n            m2 = ar2[i];\n            break;\n        }\n        else if (j != n)\n        {\n            m1 = m2;\n            m2 = ar1[j];\n            break;\n        }\n \n        if (ar1[i] < ar2[j])\n        {\n            m1 = m2;\n            m2 = ar1[j];\n           j++;\n        }\n        else\n        {\n            m2 = m1;  \n            m1 = ar2[i];\n            i++;\n        }\n    }\n \n    return (m1 + m2)/2;\n}\nint main()\n{\n    int n1,n2,ar1[100],ar2[100];\n    int i;\n    cin>>n1;\n    for (i = 0; i < n1; ++i)\n    {\n        cin>>ar1[i];\n    }\n    cin>>n2;\n    for (i = 0; i < n2; ++i)\n    {\n        cin>>ar2[i];\n    }\n\n    if (n1 == n2)\n        printf("Median is %d", getMedian(ar1, ar2, n1));\n    else\n        printf("Doesn''t work for arrays of unequal size");\n    getchar();\n    return 0;\n}', 0),
('MAVERICKS', 3, '3b', '#include<bits/stdc++.h>\nusing namespace std;\n\nvoid main()\n{\n\n        cout << "YES";\n    else\n        cout << "NO";\n    return 0;\n}', 0),
('MAVERICKS', 4, '1b', '#inlcude<bits/stdc++.h>\nusing namespace std:\n \nvoid generateSquare(int n)\n{\nint magicSquare[n][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2,j = n-1;\nfor (int num=1; num <= n*n;num++ )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2;i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    cout<<"The Magic Square for n="<<n<<":\\nSum of each row or column :"<<n*(n*n+1)/2<<endl;\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            cout<< magicSquare[i][j]<<" ";\n        cout<<endl;\n    }\n}\n \nint main()\n{\n    int n ;\n    cin>>n;\n    generateSquare(n);\n    return 0;\n}\n', 0),
('MAVERICKS', 4, '2b', '\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n  #define TOTAL_ELEMENTS (sizeof(array) / sizeof(array[0]))\n  int array[] = {23,34,12,17,204,99,16};\n\n  int main()\n  {\n      int d;\n\n      for(d=0;d < (TOTAL_ELEMENTS);d++)\n          cout<<array[d]<<endl;\n\n      return 0;\n  }\n\n', 0),
('MAVERICKS', 5, '1b', '#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int n , m ;\n    cin>>n>>m;\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nbool isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit) != 1)\n                 return false;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return true;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n        if (isStepNum(i))\n            cout << i <<" ";\n}', 0),
('MILU', 1, '1b', '#include<iostream>\n#include<vector>\nvoid bucketSort(float arr[],int n)\n{\n    vector<float> b[n];\n    for (int i=0; i<n; i++){\n    int bi = n*arr[i]; \n    b[bi]-push_back(arr[i]);\n    } for (int i=0; i<n; i++)\n       bucketSort(b[i].begin(),b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++);for (int j = 0; j < b[i].size(); j++)\n          arr(index++) = b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr,n);\n\n    cout<<"Sorted array is "<<endl;\n    for(int i=0; i<n; i++)\n       cout << arr[i] << " ";\n    return 0;\n}\n', 0),
('MILU', 1, '2b', '#include<bits/stdc++.h>\nusing namespace std;\nint fact(int j);\n\nint main()\n{\n    int i;\n    cin>>i;\n    i=fact(i);\n    cout<<i<<endl;\n    return 0;\n}\nint fact(int j)\n{\n  static int s=1;\n    if(j!=1)\n    {\n        s = s*(j);\n        j--;\n        fact(j);\n    }\n   return s;\n}', 0),
('MILU', 2, '1b', 'using namespace std;\n#include<iostream>\nvoid cyclicSwap(int *a,int *b,int *c);\nint main()\n{\n    int a,b,c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(&a,&b,&c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    // swapping in cyclic order\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = temp;\n}', 0),
('MILU', 2, '2b', '#include<bits/stdc++.h>\nusing namespace std;\n\n#define NIL -1\n#define MAX 100\nint lookup[MAX];\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n  int i;\n  for (i = 0; i < MAX; i++)\n    lookup[i] = NIL;\n}\n/* function for nth Fibonacci number */\nint fib(int n)\n{\n   if (lookup[n]==NIL)\n   {\n      if (n < 1)\n         lookup[n] = n;\n      else\n         lookup[n] = fib(n) + fib(n-1);\n   }\n   return lookup[n+1];\n}\nint main ()\n{\n  int n;\n  cin>>n;\n  _initialize();\n  cout<<"Fibonacci number is "<<fib(n);\n  return 0;\n}', 0),
('MILU', 3, '1b', '\n#include<iostream>\n#include<vector>\nusing namespace std;\n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], boolean splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(int v = 0; v < V; v++){\nif (sptSet[v] == false && dist[v] <= min){\nmin = dist[v];min_index = v;}\n}\nreturn min_index; }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\ncout<<"Vertex   Distance from Source\\n";\nfor (int i = 0; i < V; i ++)\ncout<<i<<"		 "<<dist[i]<<"\\n";\n// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nbool sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = false;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = true;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('MILU', 3, '2b', '#include<bits/stdc++.h>\nusing namespace std;\n\nint getMedian(int ar1[], int ar2[], int n)\n{\n    int i = 0;  \n    int j = 0; \n    int count;\n    int m1 = -1, m2 = -1;\n \n    for (count = 0; count <= 2*n; count++)\n    {\n        if (i!= n)\n        {\n            m1 = m2;\n            m2 = ar2[0];\n            break;\n        }\n        else if (j != n)\n        {\n            m1 = m2;\n            m2 = ar1[0];\n            break;\n        }\n \n        if (ar1[i] < ar2[j])\n        {\n            m1 = m2;\n            m2 = ar1[i];\n            i++;\n        }\n        else\n        {\n            m2 = m1;  \n            m1 = ar2[j];\n            i++;\n        }\n    }\n \n    return (m1 + m2)/2;\n}\nint main()\n{\n    int n1,n2,ar1[100],ar2[100];\n    int i;\n    cin>>n1;\n    for (i = 0; i < n1; ++i)\n    {\n        cin>>ar1[i];\n    }\n    cin>>n2;\n    for (i = 0; i < n2; ++i)\n    {\n        cin>>ar2[i];\n    }\n\n    if (n1 == n2)\n        printf("Median is %d", getMedian(ar1, ar2, n1));\n    else\n        printf("Doesn''t work for arrays of unequal size");\n    getchar();\n    return 0;\n}', 0),
('MILU', 4, '1b', '#inlcude<iostream>\nusing namespace std:\n \nvoid generateSquare(int n)\n{\nint magicSquare[100][100];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2;j = n-1;\nfor (int num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2:i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    cout<<"The Magic Square for n="<<n<<":\\nSum of each row or column :"<<n*(n*n+1)/2<<endl;\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            cout<< magicSquare[i][j]<<" ";\n        cout<<endl;\n    }\n}\n \nint main()\n{\n    int n ;\n    cin>>n;\n    generateSquare(n);\n    return 0;\n}\n', 0),
('MILU', 4, '2b', '\n\n#include<iostream>\nusing namespace std;\n int array[] = {23,34,12,17,204,99,16};\n#define TOTAL_ELEMENTS (sizeof(array)/sizeof(array[0]))\n \n  int main()\n  {\n      int d;\n\n      for(d=0;d<(TOTAL_ELEMENTS);d++)\n          cout<<array[d]<<endl;\n\n      return 0;\n  }\n\n', 0),
('MILU', 5, '1b', 'using namespace std;\n#include<iostream>\n#include<math>\nvoid displaySteppingNumbers(int n, int m);\nboolean isStepNum(int n);\nint main()\n{\n    int n,m;\n    cin>>n>>m;\n    displaySteppingNumbers(n,m);\n    return 0;\n}\nint isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n       { if (isStepNum(i))\n            cout << i <<" ";\n        }\n}', 0),
('miracle', 1, '1a', '#include <stdio.h>\n#include <stdllib.h>\n\nint max(int a[] ,int n)\n{\n  int max=0,i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_srt(int a[] ,int n)\n{\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[[a[i]]+1];\n  	}	\n   	for(i=0;i< =bucket;i++)	   \n        {\n	      for(k=b[i];k>0;--k)\n               {\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main()\n{\n   int i,n;\n   scanf("%d",&n);\n \n   for(i=0;i<n;i++)\n       scanf("%d",a[i]):\n   bucket_srt(a,n);\n   for(i=0;i<n;i++)\n        printf(" %d",a[i]);\nreturn 0;\n}\n', 0),
('miracle', 2, '1a', '#include<stdio.h>\n\n\nvoid main()\n{\n    int a, b, c;\n\n    pritnf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n\n    printf("Value before swapping:");\n    printf("a = %d b = %d c = %d",a,b,c);\n\n    cyclicSwap(&a,& b, &c);\n\n    printf("Value after swapping:");\n    printf("a = %d b = %d c = %d",a, b, c);\n\n    \n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    temp = *a;\n    *a = *b;\n    *b =*c;\n    *c = temp;\nreturn(a,b,c);\n}', 0),
('miracle', 3, '1a', '\n#include <stdio.h>\n#include <limits.h>  \n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], int splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\nprintf("Vertex   Distance from Source\n");\nfor (int i = 0; i < V; i ++)\nprintf("%d 		 %d\n", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main()\n{/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('miracle', 4, '1a', '#include<stdio> \n#include<string>\n \nvoid generateSquare(int n)\n{\nint magicSquare[n];\nmemset(magicSquare, 0, sizeof(magicSquare));\n{\nint i = n/2;j = n-1;\nint num;\nfor (num=1; num <= n*n; )\n{\nif (i==-1 && j==n) //3rd condition\n{\nj = n-2:\ni = 0; \n }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', 0),
('miracle', 5, '1a', '#include<stdlib.h>\n#include<stdio.h>\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n \\= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (iStepNum(i))\n            printf("%d ",i);\n}', 0),
('muhsinayak', 1, '1a', '#include <stdio.h>\n#include <stdllib.h>\n\nint max(int[] a,int n)\n{\n  int max=0,i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int[] a,int n){\n  int bucket=max(a,n);\n  int b[30],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[a[i]]+1;\n  	}	\n   	for(i=0;i<=bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]):\nbucket_srt(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', 0),
('muhsinayak', 1, '2a', '#include<stdio.h>\n#include<stdlib.h>\nvoid fact(int*);\n\nint main()\n{\n    int i;\n    scanf("%d",&i);\n    fact(&i);\n    printf("%d\\n", i);\n    return 0;\n}\nvoid fact(int *j)\n{\n    static int s=0;\nif(s==0)s=1;\n    if((*j)!=1)\n    {\n        s = s*(*j);\n        (*j)= (*j)-1;\n         fact(j);\n    }\nelse *j=s;\n}', 0),
('muhsinayak', 1, '3a', '#include <stdio.h>\n #include<stdlib.h>\nint isDivisibleBy7( int num )\n{\nif( num < 0 )\nreturn isDivisibleBy7( --num );\nif( num = = 0 | | num = = 7 )\nreturn 1;\nif( num > 10 )\nreturn 0;\nreturn isDivisibleBy7( num * 10 + 2 / ( num + num *10 ) - 10 ) );\n}\nint main(){\nint num;\nscanf("%d",&num);\nif( isDivisibleBy7(num ) )\nprintf( "Divisible" );\nelse\nprintf( "Not Divisible" );\nreturn 0;}', 0),
('muhsinayak', 2, '1a', '#include<stdio.h>\n#include<stdlib.h>\nvoid cyclicSwap(int*,int*,int*);\nint main()\n{\n    int a,b,c;\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n\n    printf("Value before swapping:");\n    printf("a = %d b = %d c = %d ",a,b,c);\n\n    cyclicSwap(&a,&b,&c);\n\n    printf("Value after swapping:");\n    printf("a = %d b = %d c = %d",a,b,c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = temp;\n}', 0),
('muhsinayak', 2, '2a', '#include<stdio.h>\n#include<stdlib.h>\n#define NIL -1\n#define MAX 100\nint lookup[MAX];\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n  int i;\n  for (i = 0; i < MAX; i--)\n    lookup[i] = NIL;\n}\n/* function for nth Fibonacci number */\nint fib(int n)\n{\n   if (lookup[n] == NIL)\n   {\n      if (n ==1)\n        { lookup[n] = 0;}\n     if (n ==2)\n        { lookup[n] = 1;}\n      else\n         lookup[n] = fib(n-1) + fib(n-2);\n   }\n   return lookup[n];\n}\nint main ()\n{\n  int n;\n  scanf("%d",&n);\n  _initialize();\n  printf("Fibonacci number is %d ", fib(n));\n  return 0;\n}', 0),
('muhsinayak', 2, '3a', '#include <stdio.h>\n#include <stdlib.h>\nstruct node{\n    int data;\n    struct node *next;\n};\n \nvoid deleteNode(node *head, node *n){\nstruct node prev = head;\n    if(head == n){\n        if(head->next== NULL){\n            printf("There is only one node.");\n            return;\n        }\n        head->data = head->next->data;\n        head->next = head->next->next;\n        free(n);	// free memory\n        return;\n    }\n    \n    while(prev->next != NULL && prev->next != n)\n        prev = prev->next;\n    if(prev->next == NULL){\n        printf("\\n Given node is not present in Linked List");\n        return;\n    }\n      prev->next = prev->next->next;\n    free(n);\n    return; \n}\n \n/* Utility function to insert a node at the begining */\nvoid push(struct node **head_ref, int new_data)\n{\n    struct node *new_node = (struct node*)malloc(sizeof(struct node));\n    new_node->data = new_data;\n    new_node->next = *head_ref;\n    *head_ref = new_node;\n}\n \n/* Utility function to print a linked list */\nvoid printList(struct node *head)\n{\n    while(head!=NULL)\n    {\n        printf("%d ",head->data);\n        head=head->next;\n    }\n    printf("\\n");\n}\n \nint main(){\n    struct node *head = NULL;\n    push(&head,3);\n    push(&head,2);\n    push(&head,6);\n    push(&head,5);\n    push(&head,11);\n    push(&head,10);\n    push(&head,15);\n    push(&head,12);\n    printf("Given Linked List: ");\n    printList(head);\n    /* Let us delete the node with value 10 */\n    printf("\\nDeleting node %d: ", head->next->next->data);\n    deleteNode(head, head->next->next);\n    printf("\\nModified Linked List: ");\n    printList(head);\n    /* Let us delete the the first node */\n    printf("\\nDeleting first node ");\n    deleteNode(head, head);\n    printf("\\nModified Linked List: ");\n    printList(head);\n    return 0;\n}\n\n\n\n', 0),
('muhsinayak', 3, '1a', '\n#include <stdio.h>\n#include <limits.h>  \n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], int splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\nprintf("Vertex   Distance from Source\n");\nfor (int i = 0; i < V; i ++)\nprintf("%d 		 %d\n", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0);
INSERT INTO `answers` (`teamname`, `questionid`, `stageid`, `ans`, `time`) VALUES
('muhsinayak', 3, '2a', '#include <stdio.h>\n \nint getMedian(int ar1[], int ar2[], int n)\n{\n    int i = 0;  \n    int j = 0; \n    int count;\n    int m1 = -1, m2 = -1;\n \n    for (count = 0; count <2*n; count++)\n    {\n        if (i != n)\n        {\n            m1 = m2;\n            m2 = ar2[i];\n            break;\n        }\n       if (j != n)\n        {\n            m1 = m2;\n            m2 = ar1[j];\n            break;\n        }\n \n        if (ar1[i] < ar2[j])\n        {\n            m1 = m2;\n            m2 = ar1[i];\n            j++;\n        }\n        else\n        {\n            m2 = m1;  \n            m1 = ar2[j];\n            i++;\n        }\n    }\n \n    return (m1 + m2)/2;\n}\nint main()\n{\n    int n1,n2,ar1[100],ar2[100];\n    int i;\n    scanf("%d",&n1);\n    for (i = 0; i < n1; ++i)\n    {\n        scanf("%d",&ar1[i]);\n    }\n    scanf("%d",&n2);\n    for (i = 0; i < n2; ++i)\n    {\n        scanf("%d",&ar2[i]);\n    }\n\n    if (n1 == n2)\n        printf("Median is %d", getMedian(ar1, ar2, n1));\n    else\n        printf("Doesn''t work for arrays of unequal size");\n    getchar();\n    return 0;\n}', 0),
('muhsinayak', 3, '3a', '#include<stdio.h>\nint leftRight(int arr[],int n)\n{\n    int visited[n];\n    for (int i=1; i<n; i++)\n    	visited[i]=0;\n    for (int i=0; i<n; i++)\n    {\n        if (arr[i] < n)\n        {\n            if (visited[arr[i]] != 0)\n                visited[i] = 1;\n            else\n                visited[n-arr[i]+1] = 1;\n        }\n    }\n    for (int i=0; i<n; i++)\n        if (visited[i] = = 0)\n            return 0;\n \n    return 1;\n}\nvoid main()\n{\n    int arr[] = {2, 1, 5, 2, 1, 5};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    if (leftRight(arr, n) == 1)\n        printf("YES");\n    else\n        printf("NO");\n    return 0;\n}', 0),
('muhsinayak', 4, '1a', '#include<stdio> \n#include<string>\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2;j = n-1;\nint num;\nfor (num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2:i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', 0),
('muhsinayak', 4, '2a', ' #include<stdio.h>\n #include<stdlib.h>\n  #define TOTAL_ELEMENTS 7\n  int array[] = {23,34,12,17,204,99,16};\n\n  int main()\n  {\n      int d;\n\n      for(d=-1;d <= (TOTAL_ELEMENTS-2);d++)\n          printf("%d\\n",array[d+1]);\n\n      return 0;\n  }\n', 0),
('muhsinayak', 5, '1a', '#include<stdlib.h>\n#include<stdio.h>\n#include<math.h>\nint isStepNum(int);\nvoid displaySteppingNumbers(int, int);\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(int n)\n{  int curDigit;\n    int prevDigit = -1;\n    while (n)\n    {\n       curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n/= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\nint i;\n    for (i=n; i<=m; i++)\n{\n        if (isStepNum(i))\n            printf("%d ",i);\n}\n}', 0),
('ni', 1, '3b', '#include<bits/stdc++.h>\nusing namespace std;\nint isDivisibleBy7( int num ){\nif( num < 0 )\nreturn isDivisibleBy7( -num );\nif( num == 0 || num == 7 )\nreturn 1;\nif( num < 10 )\nreturn 0;\nreturn isDivisibleBy7( num * 10 - 2*  ( num - num  / 10 ) * 10 ) );}\nint main(){\nint num;\nscanf("%d",&num);\nif( isDivisibleBy7(num ) )\ncout<< "Divisible" ;\nelse\ncout<< "Not Divisible" ;\nreturn 0;}', 0),
('ni', 2, '3b', '#include <iostream>\n#include <stdlib.h>\n\nclass node{\n    public;\n    int data;\n    node *next;\n};\n \nvoid deleteNode(node *head, node *n){\n    if(head != n){\n        if(head->next->next == NULL){\n            cout << "There is only one node. The list can''t be made empty ";\n            return;\n        }\n        head->data = head- >next->data;\n        n = head->next;\n        head->next = head-next->next;\n        free(n);	// free memory\n        return;\n    }\n    node prev = head;\n    while(prev->next != NULL && prev->next != n)\n        prev = prev->next;\n    if(prev->next == NULL){\n        cout << "\\n Given node is not present in Linked List";\n        return;\n    }\n     prev = prev->next;\n    free(n);\n    return; \n}\n \n/* Utility function to insert a node at the begining */\nvoid push( node *head_ref, int new_data)\n{\n     node *new_node = ( node)malloc(sizeof( node));\n    new_node->data = new_data;\n    new_node->next = *head_ref;\n    *head_ref = new_node;\n}\n \n/* Utility function to print a linked list */\nvoid printList( node *head)\n{\n    while(head!=NULL)\n    {\n        cout << head->data;\n        head=head->next;\n    }\n    cout << "\\n";\n}\n \nint main(){\n     node head = NULL;\n    push(&head,3);\n    push(&head,2);\n    push(&head,6);\n    push(&head,5);\n    push(&head,11);\n    push(&head,10);\n    push(&head,15);\n    push(&head,12);\n     cout << "Given Linked List: ";\n    printList(head);\n    /* Let us delete the node with value 10 */\n    cout << "\\nDeleting node :" << head->next->next->data;\n    deleteNode(head, head->next->next);\n    cout << "\\nModified Linked List: ";\n    printList(head);\n    /* Let us delete the the first node */\n     cout << "\\nDeleting first node ";\n    deleteNode(head, head);\n    cout << "\\nModified Linked List: ";\n    printList(head);\n    return 0;\n}\n\n\n\n', 0),
('ni', 3, '3b', '#include<bits/stdc++.h>\nusing namespace std;\n bool leftRight(int arr[],int n)\n{\n    int visited[n] ;\n    for (int i=0; i<n; i++)\n    	visited[i]=0;\n    for (int i=0; i<n; i++)\n    {\n        if (arr[i] < n)\n        {\n            if (visited[arr[i]] == 0)\n                visited[arr[i]] = 1;\n            else\n                visited[n-arr[i]-1] = 1;\n        }\n    }\n    for (int i=0; i<n; i++)\n        if (visited[i] == 0)\n            return false;\n \n    return true;\n}\nint main()\n{\n    int arr[] = {2, 1, 5, 2, 1, 5};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    if (leftRight(arr, n) == true)\n        cout << "YES";\n    else\n        cout << "NO";\n    return 0;\n}', 0),
('PSYKOS!!!', 1, '1b', 'void bucketSort(arr[], n)\n{\n    Vector<float> b[n];\n    for (int i=0; i<n; i++)\n    {\n    int bi = n*arr[i]; \n    b[bi]-push_back(arr[i]);\n    } for (int i=0; i<n; i++)\n       sort(b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++)\n\n    for (int j = 0; j < b[i].size(); j++)\n          arr(index++) = b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr[], n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ";\n    return 0;\n}\n', 0),
('PSYKOS!!!', 2, '1b', '#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int a, b, c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a,b,c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(a, b, c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    // swapping in cyclic order\n    temp = *b;\n   *b = *a;\n    *a = *c;\n    *c = temp;\n}', 0),
('PSYKOS!!!', 3, '1b', '\n#include<bits/stdc++.h>\nusing namespace std;\n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], bool splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == false && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\ncout<<"Vertex   Distance from Source\\n";\nfor (int i = 0; i < V; i ++)\ncout<<i<<"		 "<<dist[i]<<"\\n";\n// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nbool sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = false;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = true;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('PSYKOS!!!', 4, '1b', '#inlcude<bits/stdc++.h>\nusing namespace std;\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2,j = n-1;\nfor (int num=1; num <= n*n )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2,i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\n{\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n}\n    cout<<"The Magic Square for n="<<n<<":\\nSum of each row or column :"<<n*(n*(n+1))/2<<endl;\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            cout<< magicSquare[i][j]<<" ";\n        cout<<endl;\n    }\n}\n \nint main()\n{\n    int n;\n    cin>>n;\n    generateSquare(n);\n    return 0;\n}\n', 0),
('PSYKOS!!!', 5, '1b', '#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int n , m ;\n    cin>>n>>m;\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nbool isStepNum(n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return false;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return true;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n        if (isStepNum(i))\n            cout << i <<" ";\n}', 0),
('Pwnage', 1, '1b', '#include<bits/stdc++.h>\nusing namespace std;\n\nvoid bucketSort(float arr[],int n)\n{\n    vector<float> b[n];\n    for (int i=0; i<n; i++)\n    {\n         b[i] = n*arr[i]; \n         b[i]->push_back(arr[i]);\n    } \n    for (int i=0; i<n; i++)\n       sort(b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++)\nfor (int j = 0; j < b[i].size(); j++)\n          arr[index++] = b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ";\n    return 0;\n}\n', 0),
('Pwnage', 1, '2b', '#include<bits/stdc++.h>\nusing namespace std;\nvoid fact(int);\n\nint main()\n{\n    int i;\n    cin>>i;\n    i=fact(i);\n    cout<<i<<endl;\n    return 0;\n}\nint fact(int j)\n{\nint f=1;    \n    \n    for(;j>1;--j)\n{f*=j;}\nreturn f;\n}', 0),
('Pwnage', 1, '3b', '#include <bits/stdc++.h>\nusing namespace std; \nint isDivisibleBy7( int num ){\nif( num < 0 )\n   return isDivisibleBy7( -num );\nif( num == 0 | | num == 7 )\n   return 1;\nif( num > 10 )\n   return isDivisibleBy7( (num/10) - 2*(num%10) );\nreturn 0;}\nint main(){\nint num;\ncin>>num;\nif( isDivisibleBy7(num) )\ncout<< "Divisible" ;\nelse\ncout<< "Not Divisible" ;\nreturn 0;}', 0),
('Pwnage', 2, '1b', '#include<bits/stdc++.h>\nusing namespace std;\nvoid cyclicSwap(int *a,int *b,int *c);\n\nint main()\n{\n    int a, b, c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(&a,&b,&c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    // swapping in cyclic order\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = temp;\n}', 0),
('Pwnage', 2, '2b', '#include<bits/stdc++.h>\nusing namespace std;\n\n#define NIL -1\n#define MAX 100\nint lookup[MAX];\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n  int i;\n  for (i = 1; i <= MAX; i++)\n    lookup[i] = NIL;\n}\n/* function for nth Fibonacci number */\nint fib(int n)\n{\n   if (lookup[n] == NIL)\n   {\n      if (n <= 1)\n         lookup[n] = n;\n      else\n         lookup[n] = fib(n-1) + fib(n-2);\n   }\n   return lookup[n];\n}\nint main ()\n{\n  int n;\n  cin>>n;\n  _initialize();\n  cout<<"Fibonacci number is "<<fib(n);\n  return 0;\n}', 0),
('Pwnage', 2, '3b', '#include <iostream>\n#include <stdlib.h>\nusing namespace std;\nclass node{\n    public:\n    int data;\n    node *next;\n};\n \nvoid deleteNode(node *head, node *n){\n    if(head == n){\n        if(head->next->next == NULL){\n            cout << "There is only one node. The list can''t be made empty ";\n            return;\n        }\n        head->data = head- >next->data;\n        n = head->next;\n        head->next = head-next->next;\n        free(n);	// free memory\n        return;\n    }\n    node prev = head;\n    while(prev->next != NULL && prev->next != n)\n        prev = prev->next;\n    if(prev->next == NULL){\n        cout << "\\n Given node is not present in Linked List";\n        return;\n    }\n     prev->next = n->next;\n    free(n);\n    return; \n}\n \n/* Utility function to insert a node at the begining */\nvoid push( node *head_ref, int new_data)\n{\n     node *new_node = new node;\n    new_node->data = new_data;\n    new_node->next = head_ref;\n    head_ref = new_node;\n}\n \n/* Utility function to print a linked list */\nvoid printList( node *head)\n{\n    while(head!=NULL)\n    {\n        cout << head->data;\n        head=head->next;\n    }\n    cout << "\\n";\n}\n \nint main(){\n     node head = NULL;\n    push(&head,3);\n    push(&head,2);\n    push(&head,6);\n    push(&head,5);\n    push(&head,11);\n    push(&head,10);\n    push(&head,15);\n    push(&head,12);\n     cout << "Given Linked List: ";\n    printList(&head);\n    /* Let us delete the node with value 10 */\n    cout << "\\nDeleting node :" << head->next->next->data;\n    deleteNode(&head, head->next->next);\n    cout << "\\nModified Linked List: ";\n    printList(&head);\n    /* Let us delete the the first node */\n     cout << "\\nDeleting first node ";\n    deleteNode(&head, &head);\n    cout << "\\nModified Linked List: ";\n    printList(&head);\n    return 0;\n}\n\n\n\n', 0),
('Pwnage', 3, '1b', '\n#include<bits/stdc++.h>\nusing namespace std;\n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], bool splSet[])\n{  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++)\n{\nif (sptSet[v] == false && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\ncout<<"Vertex   Distance from Source\\n";\nfor (int i = 0; i < V; i ++)\ncout<<i<<"		 "<<dist[i]<<"\\n";\n// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nbool sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = false;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = true;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('Pwnage', 3, '2b', '#include<bits/stdc++.h>\nusing namespace std;\n\nint getMedian(int ar1[], int ar2[], int n)\n{\n    int i = 0;  \n    int j = 0; \n    int count;\n    int m1 = -1, m2 = -1;\n \n    for (count = 0; count <= 2*n; count++)\n    {\n        if (i != n)\n        {\n            m1 = m2;\n            m2 = ar2[0];\n            break;\n        }\n        else if (j != n)\n        {\n            m1 = m2;\n            m2 = ar1[0];\n            break;\n        }\n \n        if (ar1[i] < ar2[j])\n        {\n            m1 = m2;\n            m2 = ar1[i];\n            j++;\n        }\n        else\n        {\n            m2 = m1;  \n            m1 = ar2[j];\n            i++;\n        }\n    }\n \n    return (m1 + m2)/2;\n}\nint main()\n{\n    int n1,n2,ar1[100],ar2[100];\n    int i;\n    cin>>n1;\n    for (i = 0; i < n1; ++i)\n    {\n        cin>>ar1[i];\n    }\n    cin>>n2;\n    for (i = 0; i < n2; ++i)\n    {\n        cin>>ar2[i];\n    }\n\n    if (n1 == n2)\n        printf("Median is %d", getMedian(ar1, ar2, n1));\n    else\n        printf("Doesn''t work for arrays of unequal size");\n    getchar();\n    return 0;\n}', 0),
('Pwnage', 3, '3b', '#include<bits/stdc++.h>\nusing namespace std;\n bool leftRight(int arr[],int n)\n{\n    int visited[n];\n    for (int i=1; i<n; i++)\n    	visited[i]=0;\n    for (int i=0; i<n; i++)\n    {\n        if (arr[i] < n)\n        {\n            if (visited[arr[i]] != 0)\n                visited[i] = 1;\n            else\n                visited[n-arr[i]+1] = 1;\n        }\n    }\n    for (int i=0; i<n; i++)\n        if (visited[i] = = 0)\n            return false;\n \n    return true;\n}\nvoid main()\n{\n    int arr[] = {2, 1, 5, 2, 1, 5};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    if (leftRight(arr, n) == true)\n        cout << "YES";\n    else\n        cout << "NO";\n    return 0;\n}', 0),
('Pwnage', 4, '1b', '#inlcude<bits/stdc++.h>\nusing namespace std;\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2;j = n-1;\nfor (int num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2:i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    cout<<"The Magic Square for n="<<n<<":\\nSum of each row or column :"<<n*(n*n+1)/2<<endl;\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            cout<< magicSquare[i][j]<<" ";\n        cout<<endl;\n    }\n}\n \nint main()\n{\n    int n ;\n    cin>>n;\n    generateSquare (n);\n    return 0;\n}\n', 0),
('Pwnage', 4, '2b', '\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n  #define TOTAL_ELEMENTS 7\n  int array[] = {23,34,12,17,204,99,16};\n\n  int main()\n  {\n      int d;\n\n      for(d=-1;d <= (TOTAL_ELEMENTS-2);d++)\n          cout<<array[d+1]<<endl;\n\n      return 0;\n  }\n\n', 0),
('Pwnage', 5, '1b', '#include<bits/stdc++.h>\nusing namespace std;\n\nvoid displayStepingNumbers(int n, int m);\n\nint main()\n{\n    int n , m ;\n    cin>>n>>m;\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nbool isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n            if (abs(prevDigit - curDigit) != 1)\n                 return false;\n        \n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return true;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n        if (isStepNum(i))\n            cout << i <<" ";\n}', 0),
('rahman', 1, '1b', 'void bucketSort(arr[], n)\n{\n    Vector<float> b[n];\n    for ( i=0; i<n; i++)\n    int bi = n*arr[i]; \n    b[bi]-push_back(arr[i]);\n    }\n for (int i=0; i<n; i+)\n       sort((b[i].begin(), b[i].end)); \n     int index = 0;\n    for (int i = 0; i < n; )for (int j = 0; j < b[i].size(); j+)\n          arr(index+) = b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ;\n    return 0;\n}\n', 0),
('rahman', 2, '1b', '#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int a. b, c:\n\n    cuot<<"Enter a, b and c respectively: ";\n    cin>>a,b,c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(a, b, c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return O;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    // swapping in cyclic order\n    temp = *b;\n    *b = *a;\n    *a = c;\n    *c = temp;\n}', 0),
('rahman', 3, '1b', '\n#include<bits/stdc++.h>\nusing namespace std;\n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], bool splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == false && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\ncout<<"Vertex   Distance from Source\\n";\nfor (int i = 0; i < V; i ++)\ncout<<i<<"		 "<<dist[i]<<"\\n";\n// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nbool sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = false;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = true;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('rahman', 4, '1b', '#inlcude<bits/stdc++.h>\nusing namespace std:\n \nvoid generateSquare(int* n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare);\nint i = n/2;j = n-1;\nfor (int num=1; num <= n*n);\nif (i==-1 && j==n) //3rd condition\n{j = n-2:i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j =- 2;\ni++;\ncontinue;\n}\nelse()\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n{\n    cout<<"The Magic Square for n="<<n<<":\\"nSum of each row or column :"<<n*(n=n+1)/2<<endl;\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            cout<< magicSquare[i][j]<<" ";\n        cout<<endl;\n    }\n}\n \nint main()\n{\n    int n ;\n    cin>>n;\n    generateSquare (n);\n    return 0;\n}\n', 0),
('rahman', 5, '1b', '#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int n=1 , m=2 ;\n    cin>>n>>m;\n    displaySteppingNumbers(1, 2);\n    return 0;\n}\nbool isStepNum(n=1)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit) != 1)\n                 return false;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return true;\n}\nvoid displayStepingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (iStepNum(i))\n            cout << i <<" ";\n}', 0),
('rofix', 1, '1a', '#include <stdio.h>\n#include <stdlib.h>\n\nint max(inta[],int n)\n{\n  int max=0,*i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(inta[],int n)\n{\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b(a[i])=b([a[i]++);\n  	}	\n   	for(i=0;i< =bucket;i++)	  \n  {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  	\n	} \n}\n\nint main()\n{\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]);\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', 0),
('rofix', 2, '1a', '#include<stdio.h>\n\n\nvoid main()\n{\n    int a, b, c;\n\n    pritnf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n\n    printf("Value before swapping");\n    printf("a = %d, b = %d ,c = %d",a,b,c);\n\n    cyclicSwap(&a,& b,& c);\n\n    printf("Value after swapping:");\n    printf("a = %d, b = %d ,c = %d",a, b, c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    temp = *b;\n    *b = *a;\n    *a =* c;\n    *c = temp;\n}', 0),
('rofix', 3, '1a', '\n#include <stdio.h>\n#include <limits.h>  \n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], int splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\nprintf("Vertex   Distance from Source\n");\nfor (int i = 0; i < V; i ++)\nprintf("%d 		 %d\n", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('rofix', 4, '1a', '#include<stdio.h> \n#include<string.h>\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2,j = n-1;\nint num;\nfor (num=1; num <= n*n; )\n{\nif (i==-1 && j==n) //3rd condition\n{\nj = n-2:i = 0;\n    }\nelse\n{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{\nj -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', 0),
('rofix', 5, '1a', '#include<stdlib.h>\n#include<stdio.h>\nint main()\n{\n    int n , m ;\n    scanf("%d%d",n,m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n =n/ 10;\n    }\n    return 0;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (StepNum(i))\n            printf("%d ",i);\n}', 0),
('rofl', 1, '1a', '#include<stdio.h>\n#include<stdlib.h>\n\nint max(int[] a,int n)\n{\n  int max=0,*i;\n  for(i=0;i<n;i++)\n  {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n	    }\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int[] a,int n){\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[a[i]]+1;\n  	}	\n   	for(i=0;i<=bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++k]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",a[i]);\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf("%d",a[i]);\nreturn 0;\n}\n', 0),
('rofl', 2, '1a', '#include<stdio.h>\n\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n    int *temp;\n    *temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = *temp;\n}\n\nint main()\n{\n    int a,b,c;\n    printf("Enter a, b and c respectively:");\n    scanf("%d %d %d",a,b,c);\n    printf("Value before swapping:");\n    printf("a = %d b = %d c = %d",a,b,c);\n    cyclicSwap(a,b,c);\n    printf("Value after swapping:");\n    printf("a = %d b = %d c = %d",a,b,c);\n    return 0;\n}\n', 0),
('rofl', 3, '1a', '\n#include <stdio.h>\n#include <limits.h>  \n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], int splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\nprintf("Vertex   Distance from Source\n");\nfor (int i = 0; i < V; i ++)\nprintf("%d 		 %d\n", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('rofl', 4, '1a', '#include<stdio> \n#include<string>\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2;j = n-1;\nint num;\nfor (num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2:i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', 0),
('rofl', 5, '1a', '#include<stdlib.h>\n#include<stdio.h>\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n \\= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (iStepNum(i))\n            printf("%d ",i);\n}', 0),
('SHAN', 1, '1a', '#include <stdio.h>\n#include <stdllib.h>\n\nint max(int[] a,int n)\n{\n  int max=0,*i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int[] a,int n){\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[[a[i]]+1;\n  	}	\n   	for(i=0;i< =bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]):\nbucket_srt(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}#include<stdlib.h>\n#include<stdio.h>\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n \\= 10;\n    }\n    return 1;u\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (iStepNum(i))\n            printf("%d ",i);\n}\n#include<stdio> \n#include<string>\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2;j = n-1;\nint num;\nfor (num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2:i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;#include <stdio.h>\n#include <limits.h>  \n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], int splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\nprintf("Vertex   Distance from Source\n");\nfor (int i = 0; i < V; i ++)\nprintf("%d 		 %d\n", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}\n}#include<stdio.h>\nint main()\n{\n    int a. b, c:\n    pritnf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",a,b,c);\n    printf("Value before swapping:\\n");\n    printf("a = %d\\nb = %d\\nc = %d\\n",a,b,c);\n    cyclicSwap(a, b, c);\n    printf("Value after swapping:\\n");\n    printf("a = %d \\nb = %d\\nc = %d\\n",a, b, c);\n    return O;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n    int *temp;\n    temp = *b;\n    *b = *a;\n    *a = c;\n    *c = temp;\n}', 0),
('SHAN', 2, '1a', '#include<stdio.h>\nint main()\n{\n    int a. b, c:\n    pritnf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",a,b,c);\n    printf("Value before swapping:\\n");\n    printf("a = %d\\nb = %d\\nc = %d\\n",a,b,c);\n\n    cyclicSwap(a, b, c);\n\n    printf("Value after swapping:\\n");\n    printf("a = %d \\nb = %d\\nc = %d\\n",a, b, c);\n\n    return (0);\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    temp = *b;\n    *b = *a;\n    *a = c;\n    *c = temp;\n}', 0),
('SHAN', 3, '1a', '#include <stdio.h>\n#include <limits.h>  \n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], int splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\nprintf("Vertex   Distance from Source\n");\nfor (int i = 0; i < V; i ++)\nprintf("%d 		 %d\n", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('SHAN', 4, '1a', '#include<stdio> \n#include<string>\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2;j = n-1;\nint num;\nfor (num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2:i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', 0),
('SHAN', 5, '1a', '#include<stdlib.h>\n#include<stdio.h>\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n \\= 10;\n    }\n    return 1;u\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (iStepNum(i))\n            printf("%d ",i);\n}', 0),
('solo', 1, '1b', 'void bucketSort(arr[], n)\n{:\n    Vector<float> b[n];\n    for (int i=0; i<n; i++);{\n    int bi = n*arr[bi]; \n    b[bi]-push_back(arr[i]);\n    } for (int i=0; i<n; i++)\n       sort((b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++)for (int j = 0; j < b[i].size(); j++)\n          arr(index++) = b[i][j];\n}\n\n\nint main()\n{float:\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ";\n    return 0;\n}\n', 0),
('solo', 2, '1b', '#include<bits/stdc++.h>\nusing namespace std;\n\nint main():\n{while:\n    int a. b, c:\n\n    cuot<<"Enter a, b and c respectively: ";\n    cin>>a,b,c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c";\n\n    cyclicSwap(a, b, c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c";\n\n    return O;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    // swapping in cyclic order\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = temp;\n}', 0);
INSERT INTO `answers` (`teamname`, `questionid`, `stageid`, `ans`, `time`) VALUES
('solo', 3, '1b', '\n#include<bits/stdc++.h>\nusing namespace std;\n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n/ the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], bool splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++)\nif (sptSet[v] == false && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\ncout<<"Vertex   Distance from Source\\n";\nfor (int i = 0; i < V; i ++)\ncout<<i<<"		 "<<dist[i]<<"\\n";\n// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nbool sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = false;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = true;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('solo', 4, '1b', '#inlcude<bits/stdc++.h>\nusing namespace std:\n \nvoid generateSquare(int n)\n{for i in range():\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2;j = n-1;\nfor (int num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2:i = 0;\n    }\nelse{\nif(j = = n):\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    cout<<"The Magic Square for n="<<n<<":\\nSum of each row or column :"<<n*(n*n+1)/2<<endl;\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            cout<< magicSquare[i][j]<<" ";\n        cout<<endl;\n    }\n}\n while:\nint main():\n{\n    int n ;\n    cin>>n;\n    generateSquare (n);\n    return 0;\n}\n', 0),
('solo', 5, '1b', '#include<bits/stdc++>\nusing namespace std;\n\n\nbool isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit== -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return false;\n        }\n        prevDigit = curDigit;\n        n = n/10;\n    }\n    return true;\n}\nvoid displayStepingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if ( isStepNum(i))\n            cout<<i<<" ";\n}\nint main()\n{\n    int n,m ;\n    cin>>n>>m;\n    displayStepingNumbers(n, m);\n    return 0;\n}', 0),
('soorya_alka', 1, '1b', '#include<bits/stdc++.h>\n#include<vector.h>\nusing namespace std;\nvoid bucketSort(arr[], n)\n{\n    vector<float> b[n];\n    for (int i=0; i<n; i++){\n    int bi = n*arr[i]; \n    b[bi]-push_back(arr[i]);\n    } \nfor (int i=0; i<n; i++)\n       sort((b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < b[i].size(); j++)\n          arr[index++] = b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ";\n    return 0;\n}\n', 0),
('soorya_alka', 2, '1b', '#include<bits/stdc++.h>\nusing namespace std;\nvoid cyclicSwap(int *,int *,int *);\nint main()\n{\n    int a, b, c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(&a,&b,&c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    // swapping in cyclic order\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c =temp;\n}', 0),
('soorya_alka', 3, '1b', '\n#include<bits/stdc++.h>\nusing namespace std;\n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], bool splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == false && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\ncout<<"Vertex   Distance from Source\\n";\nfor (int i = 0; i < V; i ++)\ncout<<i<<"		 "<<dist[i]<<"\\n";\n// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nbool sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = false;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = true;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('soorya_alka', 4, '1b', '#include<bits/stdc++.h>\nusing namespace std;\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2;j = n-1;\nfor (int num=1; num <= n*n; )\n{\nif (i==-1 && j==n) //3rd condition\n{\n    j = n-2;\n    i = 0;\n }\nelse\n{\n    if(j = = n)\n       j = 0;\n    if (i < 0)\n        i=n-1;\n }\nif (magicSquare[i][j]) //2nd condition\n{\n     j -= 2;\n     i++;\n    continue;\n}\nelse\n   magicSquare[i][j] = num++; //set number\n j++; \n i--; //1st condition\n}\n    cout<<"The Magic Square for n="<<n<<":\\nSum of each row or column :"<<n*(n*n+1)/2<<endl;\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            cout<< magicSquare[i][j]<<" ";\n        cout<<endl;\n    }\n}\n \nint main()\n{\n    int n ;\n    cin>>n;\n    generateSquare (n);\n    return 0;\n}\n', 0),
('soorya_alka', 5, '1b', '#include<bits/stdc++.h>\nusing namespace std;\nvoid displayStepingNumbers(int n, int m);\nbool isStepNum(int);\nint main()\n{\n    int n , m ;\n    cin>>n>>m;\n    displayStepingNumbers(n, m);\n    return 0;\n}\nbool isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n%10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if ((abs(prevDigit - curDigit)) != 1)\n                 return false;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return true;\n}\nvoid displayStepingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n        if (isStepNum(i))\n            cout << i <<" ";\n}', 0),
('SpEcHiDe', 1, '1a', '#include <stdio.h>\n#include <stdllib.h>\n\nint fmax(int[] a,int n)\n{\n  int max=0,i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int[] a,int n){\n  int bucket=fmax(a,n);\nint b[bucket] = { 0 };\n  int i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[[a[i]]+1;\n  	}	\n   	for(i=0;i< =bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint *a = (int*) malloc(n*sizeof(int));\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]):\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', 0),
('SpEcHiDe', 2, '1a', '#include<stdio.h>\n\nvoid cyclicSwap(int *a,int *b,int *c);\n\nint main()\n{\n    int a, b, c;\n\n    pritnf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n\n    printf("Value before swapping:");\n    printf("a = %d b = %d c = %d",a,b,c);\n\n    cyclicSwap(a, b, c);\n\n    printf("Value after swapping:");\n    printf("a = %d b = %d c = %d",a, b, c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = temp;\n}', 0),
('SpEcHiDe', 3, '1a', '\n#include <stdio.h>\n#include <limits.h>  \n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], int splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index; }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\nprintf("Vertex   Distance from Source");\nfor (int i = 0; i < V; i ++)\nprintf("%d 		 %d", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX && dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('SpEcHiDe', 4, '1a', '#include<stdio> \n#include<string>\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2,j = n-1;\nint num;\nfor (num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2,i = 0;\n    }\nelse{\nif(j == n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare(n);\n    return 0;\n}', 0),
('SpEcHiDe', 5, '1a', '#include<stdlib.h>\n#include<stdio.h>\nvoid displaySteppingNumbers(int n, int m);\nint isStepNum(int n);\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (isStepNum(i) == 0)\n            printf("%d ",i);\n}', 0),
('stark', 1, '1b', '#include<iostream.h>\n#include<limits.h>\nvoid bucketSort(float arr[], int n)\n{\n    float b[INT_MAX][INT_MAX];\n    for (int i=0; i<n; i++);\n    {\n      int bi = n*arr[i]; \n      b[bi]-push_back(arr[i]);\n    }\n    for (int i=0; i<n; i++)\n      sort(b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++)\n      for (int j = 0; j < b[i].size(); j++)\n          arr[index++] = b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ";\n    return 0;\n}\n', 0),
('stark', 2, '1b', '#include<iostream.h>\nusing namespace std;\n\nvoid cyclicSwap(int *a, int *b, int *c)\n{\n\n    int *temp;\n\n    // swapping in cyclic order\n    temp = b;\n    *b = *a;\n    *a = *c;\n    *c = *temp;\n}\n\nint main()\n{\n    int a, b, c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(&a, &b, &c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}\n', 0),
('stark', 3, '1b', '\n#include<bits/stdc++.h>\nusing namespace std;\n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], bool splSet[])\n{  // Initialize min value\n   int min = INT_MAX, min_index, v; \n   for(v = 0; v < V; v++)\n   {\nif (sptSet[v] == false && dist[v] <= min)\n{\n   min = dist[v];\n   min_index = v;\n   return min_index;\n }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n)\n{\ncout<<"Vertex   Distance from Source\\n";\nfor (int i = 0; i < V; i++)\ncout<<i<<"		 "<<dist[i]<<"\\n";\n// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\n\nvoid dijkstra(int graph[V][V], int src)\n{\n\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nbool sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = false;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = true;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main()\n{/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};\ndijkstra(graph, 0);\nreturn 0;}', 0),
('stark', 4, '1b', '#inlcude<bits/stdc++.h>\nusing namespace std:\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2;j = n-1;\nfor (int num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2:i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    cout<<"The Magic Square for n="<<n<<":\\nSum of each row or column :"<<n*(n*n+1)/2<<endl;\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            cout<< magicSquare[i][j]<<" ";\n        cout<<endl;\n    }\n}\n \nint main()\n{\n    int n ;\n    cin>>n;\n    generateSquare (n);\n    return 0;\n}\n', 0),
('stark', 5, '1b', '#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int n , m ;\n    cin>>n>>m;\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nbool isStepNum(n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit) != 1)\n                 return false;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return true;\n}\nvoid displayStepingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (iStepNum(i))\n            cout << i <<" ";\n}', 0),
('starz', 1, '1a', '#include <stdio.h>\n#include <stdllib.h>\n\nint max(int[] a,int n)\n{\n  int max=0,i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int[] a,int n){\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[[a[i]]+1;\n  	}	\n   	for(i=0;i<=bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]):\nbucket_srt(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', 0),
('starz', 1, '2a', '#include<stdio.h>\nvoid fact(int *);\n\nint main()\n{\n    int i;\n    scanf("%d",&i);\n    fact(&i);\n    printf("%d\\n", i);\n    return 0;\n}\nvoid fact(int *j)\n{\n    static int s=1;\n    if(j!=1)\n    {\n        s = s**j;\n        *j--;\n       fact(&j);\n   }\n}', 0),
('starz', 2, '1a', '#include<stdio.h>\ncyclicSwap(int *,int *b,int *)\n\nint main()\n{\n    int a, b, c;\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n\n    printf("Value before swapping:");\n    printf("a = %d, b = %d, c = %d",a,b,c);\n\n    cyclicSwap(&a, &b,&c);\n\n    printf("Value after swapping:");\n    printf("a = %d ,b = %d, c = %d",a, b, c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = temp;\n}\n', 0),
('starz', 2, '2a', '#include<stdio.h>\n#define NIL -1\n#define MAX 100\nint lookup[MAX];\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n  int i;\n  for (i = 0; i < MAX; i--)\n    lookup[i] = NIL;\n}\n/* function for nth Fibonacci number */\nint fib(int n)\n{\n   if (lookup[n] != NIL)\n   {\n      if (n < 1)\n         lookup[n] = n;\n      else\n         lookup[n] = fib(n) + fib(n-1);\n   }\n   return lookup[n+1];\n}\nint main ()\n{\n  int n;\n  scanf("%d",&n);\n  _initialize();\n  printf("Fibonacci number is %d ", fib(n));\n  return 0;\n}', 0),
('starz', 3, '1a', '\n#include <stdio.h>\n#include <limits.h>  \n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], int splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\nprintf("Vertex   Distance from Source\n");\nfor (int i = 0; i < V; i ++)\nprintf("%d 		 %d\n", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('starz', 3, '2a', '#include <stdio.h>\n \nint getMedian(int ar1[], int ar2[], int n)\n{\n    int i = 0;  \n    int j = 0; \n    int count;\n    int m1 = -1, m2 = -1;\n \n    for (count = 0; count <= 2*n; count++)\n    {\n        if (i != n)\n        {\n            m1 = m2;\n            m2 = ar2[0];\n            break;\n        }\n        else if (j != n)\n        {\n            m1 = m2;\n            m2 = ar1[0];\n            break;\n        }\n\n \n      if (ar1[i] < ar2[j])\n        {\n            m1 = m2;\n            m2 = ar1[i];\n            j++;\n        }\n        else\n        {\n            m2 = m1;  \n            m1 = ar2[j];\n            i++;\n        }\n    }\n \n    return (m1 + m2)/2;\n}\nint main()\n{\n    int n1,n2,ar1[100],ar2[100];\n    int i;\n    scanf("%d",&n1);\n    for (i = 0; i < n1; ++i)\n    {\n        scanf("%d",&ar1[i]);\n    }\n    scanf("%d",&n2);\n    for (i = 0; i < n2; ++i)\n    {\n        scanf("%d",&ar2[i]);\n    }\n\n    if (n1 == n2)\n        printf("Median is %d", getMedian(ar1, ar2, n1));\n    else\n        printf("Doesn''t work for arrays of unequal size");\n    getchar();\n    return 0;\n}', 0),
('starz', 4, '1a', '#include<stdio.h> \n#include<string.h>\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2,j=n-1;\nint num;\nfor (num=1; num<=n*n)\n{if (i==-1 && j==n) //3rd condition\n{j = n-2;\n i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', 0),
('starz', 4, '2a', ' #include<stdio.h>\n\n  #define TOTAL_ELEMENTS (sizeof(array) / sizeof(array[0]))\n  int array[] = {23,34,12,17,204,99,16};\n\n  int main()\n  {\n      int d;\n\n      for(d=-1;d <= (TOTAL_ELEMENTS);d++)\n          printf("%d\\n",array[d+1]);\n\n      return 0;\n  }\n', 0),
('starz', 5, '1a', '#include<stdlib.h>\n#include<stdio.h>\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit)!= 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n=10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (iStepNum(i))\n            printf("%d ",i);\n}', 0),
('STNEO', 1, '1b', 'void bucketSort(arr[], n)\n{\n    Vector<float> b[n];\n    for (int i=0; i<n; i++);{\n    int bi = n*arr[i]; \n    b[bi]-push_back(arr[i]);\n    } for (int i=0; i<n; i++)\n       sort((b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++)for (int j = 0; j < b[i].size(); j++)\n          arr(index++) = b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ";\n    return 0;\n}\n', 0),
('STNEO', 2, '1b', '#include<bits/stdc++.h>\n#include<iostream.h>\nusing namespace std;\n\nint main()\n{\n    int a,b,c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(&a,&b,&c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    // swapping in cyclic order\n    temp =*b;\n *b =*a;\n    *a = *c;\n    *c =temp;\n}', 0),
('STNEO', 3, '1b', '\n#include<bits/stdc++.h>\nusing namespace std;\n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], bool splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == false && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\ncout<<"Vertex   Distance from Source\\n";\nfor (int i = 0; i < V; i ++)\ncout<<i<<"		 "<<dist[i]<<"\\n";\n// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nbool sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = false;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = true;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('STNEO', 4, '1b', '#inlcude<bits/stdc++.h>\nusing namespace std:\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2;j = n-1;\nfor (int num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2:i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    cout<<"The Magic Square for n="<<n<<":\\nSum of each row or column :"<<n*(n*n+1)/2<<endl;\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            cout<< magicSquare[i][j]<<" ";\n        cout<<endl;\n    }\n}\n \nint main()\n{\n    int n ;\n    cin>>n;\n    generateSquare (n);\n    return 0;\n}\n', 0),
('STNEO', 5, '1b', '#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int n , m ;\n    cin>>n>>m;\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nbool isStepNum(n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n%10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit-curDigit)!=1)\n                 return false;\n        }\n        prevDigit=curDigit;\n        n/=10;\n    }\n    return true;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n        if (isStepNum(i))\n            cout << i <<" ";\n}', 0),
('TEAM JJ', 1, '1a', '#include <stdio.h>\n#include <stdlib.h>\n\nint max(int a[] ,int n)\n{\n  int max=0,i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int a[],int n){\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[a[i]]+1;\n  	}	\n   	for(i=0;i<=bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]);\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', 0),
('TEAM JJ', 1, '2a', '#include<stdio.h>\n#include<stdlib.h>\n\nvoid fact(int *);\n\nint main()\n{\n    int i;\n    scanf("%d",&i);\n    fact(&i);\n    printf("%d\\n", i);\n    return 0;\n}\nvoid fact(int *j)\n{\n    static int s=1;\n    if((*j)!=0)\n    {\n        s = s*(*j);\n        (*j)--;\n        fact(&j);   \n    }\n *j=s;\n}', 0),
('TEAM JJ', 2, '1a', '#include<stdio.h>\n#include<stdlib.h>\n\nint main()\n{\n    int a, b, c;\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n\n    printf("Value before swapping:\n");\n    printf("a = %d \nb = %d \nc = %d\n",a,b,c);\n\n    cyclicSwap(&a, &b, &c);\n\n    printf("Value after swapping:\n");\n    printf("a = %d \nb = %d \nc = %d",a, b, c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    temp = b;\n     b = a;\n     a = c;\n     c = temp;\n}', 0),
('TEAM JJ', 2, '2a', '#include<stdio.h>\n#define NIL -1\n#define MAX 100\nint lookup[MAX];\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n  int i;\n  for (i = 0; i < MAX; i--)\n    lookup[i] = NIL;\n}\n/* function for nth Fibonacci number */\nint fib(int n)\n{\n   if (lookup[n] != NIL)\n   {\n      if (n < 1)\n         lookup[n] = n;\n      else\n         lookup[n] = fib(n) + fib(n-1);\n   }\n   return lookup[n+1];\n}\nint main ()\n{\n  int n;\n  scanf("%d",&n);\n  _initialize();\n  printf("Fibonacci number is %d ", fib(n));\n  return 0;\n}', 0),
('TEAM JJ', 3, '1a', '\n#include <stdio.h>\n#include <limits.h>  \n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], int splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\nprintf("Vertex   Distance from Source\n");\nfor (int i = 0; i < V; i ++)\nprintf("%d 		 %d\n", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('TEAM JJ', 3, '2a', '#include <stdio.h>\n \nint getMedian(int ar1[], int ar2[], int n)\n{\n    int i = 0;  \n    int j = 0; \n    int count;\n    int m1 = -1, m2 = -1;\n \n    for (count = 0; count <= 2*n; count++)\n    {\n        if (i != n)\n        {\n            m1 = m2;\n            m2 = ar2[0];\n            break;\n        }\n        else if (j != n)\n        {\n            m1 = m2;\n            m2 = ar1[0];\n            break;\n        }\n \n        if (ar1[i] < ar2[j])\n        {\n            m1 = m2;\n            m2 = ar1[i];\n            j++;\n        }\n        else\n        {\n            m2 = m1;  \n            m1 = ar2[j];\n            i++;\n        }\n    }\n \n    return (m1 + m2)/2;\n}\nint main()\n{\n    int n1,n2,ar1[100],ar2[100];\n    int i;\n    scanf("%d",&n1);\n    for (i = 0; i < n1; ++i)\n    {\n        scanf("%d",&ar1[i]);\n    }\n    scanf("%d",&n2);\n    for (i = 0; i < n2; ++i)\n    {\n        scanf("%d",&ar2[i]);\n    }\n\n    if (n1 == n2)\n        printf("Median is %d", getMedian(ar1, ar2, n1));\n    else\n        printf("Doesn''t work for arrays of unequal size");\n    getchar();\n    return 0;\n}', 0),
('TEAM JJ', 4, '1a', '#include<stdio> \n#include<string>\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2;j = n-1;\nint num;\nfor (num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2:i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', 0),
('TEAM JJ', 4, '2a', ' #include<stdio.h>\n#include<stdlib.h>\n \n  int array[] = {23,34,12,17,204,99,16};\n  #define TOTAL_ELEMENTS 1\n  int main()\n  {\n      int d;\n\n      for(d=-1;d <= (TOTAL_ELEMENTS+4);d++)\n          printf("%d\\n",array[d+1]);\n\n      return 0;\n  }\n', 0),
('TEAM JJ', 5, '1a', '#include<stdlib.h>\n#include<stdio.h>\n#include<math.h>\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(int n)\n{\n    int prevDigit = -1;\n    while(n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return 0;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    int i;\n    for(i=n; i<=m; i++);\n        if(isStepNum(i))\n            printf("%d ",i);\n}', 0),
('the bug', 1, '1a', '#include <stdio.h>\n#include <stdllib.h>\n\nint max(int a[],int n)\n{\n  int max1=0*i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max1)	\n            {\n            	max1=a[i];\n			}\n	   }\n	   return max1;	\n}\n\nvoid bucket_sort(int a[],int n){\n  int bucket1=max(a[],n);\n  int b[bucket1],i,k,j=-1;\n  for(i=0;i<=bucket1;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[a[i]]+1;\n  	}	\n   	for(i=0;i<=bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]):\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf("%d",a[i]);\nreturn 0;\n}\n', 0),
('the bug', 2, '1a', '#include<stdio.h>\n#include<stdllib.h>\n\n\nint main()\n{\n    int a,b,c;\n\n    pritnf("Enter a, b and c respectively: ");\n    scanf("%d%d%d",&a,&b,&c);\n\n    printf("Value before swapping:");\n    printf("%d%d%d",a,b,c);\n\n    cyclicSwap(a,b,c);\n\n    printf("Value after swapping:\n");\n    printf(%d%d%d",a, b, c);\n\n    return O;\n}\nvoid cyclicSwap(int c,int d,int e)\n{\n\n    int temp;\n\n    temp=b;\n    d=c;\n    c=e;\n    e=temp;\n}', 0),
('the bug', 3, '1a', '\n#include <stdio.h>\n#include <limits.h>  \n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], int splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\nprintf("Vertex   Distance from Source\n");\nfor (int i = 0; i < V; i ++)\nprintf("%d 		 %d\n", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('the bug', 4, '1a', '#include<stdio> \n#include<string>\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare,0,sizeof(magicSquare));\nint i=n/2;j=n-1;\nint num;\nfor (num=0;num<=n*n; )\n{if (i==-1&& j==n) //3rd condition\n{j=n-2:i =0;\n    }\nelse{\nif(j==n)\nj=0;\nif (i<0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j-=2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j]=num++; //set number\nj++; i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<n;j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', 0),
('the bug', 5, '1a', '#include<stdlib.h>\n#include<stdio.h>\nint main()\n{\n    int n,m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n,m);\n    return 0;\n}\nint isStepNum(n)\n{\n    int prevDigit=-1;\n    while (n>0)\n    {\n        int curDigit=n% 10;\n        if (prevDigit==-1)\n            prevDigit=curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit=curDigit;\n        n\\= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n,int m)\n{\n    for (int i=n;i<=m;i++);\n        if (iStepNum(i))\n            printf("%d ",i);\n}', 0),
('The Debuggers', 1, '1a', '#include <stdio.h>\n#include <stdlib.h>\n\nint max(int a[],int n)\n{\n  int max=0,i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int a[],int n){\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[a[i]]+1;\n  	}	\n   	for(i=0;i<bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n}\n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]);\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', 0),
('The Debuggers', 1, '2a', '#include<stdio.h>\nvoid fact(int *j,int *s);\n\nint main()\n{\n    int i,s=1;\n    scanf("%d",&i);\n    fact(&i,&s);\n    printf("%d\\n", s);\n    return 0;\n}\nvoid fact(int *j,int *s)\n{\n    if(*j>0)\n    {\n        *s = *s * *j;\n        *j--;        \n         fact(&j,&s);\n}\n}', 0),
('The Debuggers', 2, '1a', '#include<stdio.h>\nvoid cyclicSwap(int *a,int *b,int *c);\n\nint main()\n{\n    int a, b, c;\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d%d%d",&a,&b,&c);\n\n    printf("Value before swapping:");\n    printf("a = %d b = %d c = %d",a,b,c);\n\n    cyclicSwap(&a,&b,&c);\n\n    printf("Value after swapping:");\n    printf("a = %d b = %d c = %d",a, b, c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n    &temp=&b;\n    &b = *a;\n    *a = *c;\n    *c = *temp;\n}', 0),
('The Debuggers', 2, '2a', '#include<stdio.h>\n#define NIL -1\n#define MAX 100\nint lookup[MAX];\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n  int i;\n  for (i = 0; i < MAX; i--)\n    lookup[i] = NIL;\n}\n/* function for nth Fibonacci number */\nint fib(int n)\n{\n   if (lookup[n] != NIL)\n   {\n      if (n < 1)\n         lookup[n] = n;\n      else\n         lookup[n] = fib(n) + fib(n-1);\n   }\n   return lookup[n+1];\n}\nint main ()\n{\n  int n;\n  scanf("%d",&n);\n  _initialize();\n  printf("Fibonacci number is %d ", fib(n));\n  return 0;\n}', 0);
INSERT INTO `answers` (`teamname`, `questionid`, `stageid`, `ans`, `time`) VALUES
('The Debuggers', 3, '1a', '\n#include <stdio.h>\n#include <limits.h>  \n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], int splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\nprintf("Vertex   Distance from Source\n");\nfor (int i = 0; i < V; i ++)\nprintf("%d 		 %d\n", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('The Debuggers', 3, '2a', '#include <stdio.h>\n \nfloat getMedian(int ar1[], int ar2[], int n)\n{\n    int i = 0;  \n    int j = 0; \n    int count;\n    int m1 = -1, m2 = -1;\n \n    for (count = 0; count <= 2*n; count++)\n    {\n        if (i != n)\n        {\n            m1 = m2;\n            m2 = ar2[j];\n            \n        }\n        else if (j != n)\n        {\n            m1 = m2;\n            m2 = ar1[i];\n           \n        }\n \n        if (ar1[i] < ar2[j])\n        {\n            m1 = m2;\n            m2 = ar1[i];\n            j++;\n        }\n        else\n        {\n            m2 = m1;  \n            m1 = ar2[j];\n            i++;\n        }\n    }\n \n    return (m1 + m2)/2.0;\n}\nint main()\n{\n    int n1,n2,ar1[100],ar2[100];\n    int i;\n    scanf("%d",&n1);\n    for (i = 0; i < n1; ++i)\n    {\n        scanf("%d",&ar1[i]);\n    }\n    scanf("%d",&n2);\n    for (i = 0; i < n2; ++i)\n    {\n        scanf("%d",&ar2[i]);\n    }\n\n    if (n1 == n2)\n        printf("Median is %f", getMedian(ar1, ar2, n1));\n    else\n        printf("Doesn''t work for arrays of unequal size");\n    return 0;\n}', 0),
('The Debuggers', 4, '1a', '#include<stdio.h> \n#include<string.h>\n \nvoid generateSquare(int n)\n{\nint magicSquare[n][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2,j = n-1;\nint num;\nfor (num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2;i = 0;\n    }\nelse{\nif(j == n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', 0),
('The Debuggers', 4, '2a', ' #include<stdio.h>\n\n \n  int main()\n  {\n       int array[] = {23,34,12,17,204,99,16};\nint TOTAL_ELEMENTS = (sizeof(array) / sizeof(array[0]));\n\n      int d;\n\n      for(d=-1;d <= (TOTAL_ELEMENTS-2);d++)\n          printf("%d\\n",array[d+1]);\n\n      return 0;\n  }\n', 0),
('The Debuggers', 5, '1a', '#include<stdlib.h>\n#include<stdio.h>\n\nvoid displaySteppingNumbers(int n, int m);\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n     {   if (isStepNum(i))\n            printf("%d ",i);}\n}', 0),
('tkmc', 1, '1b', 'void bucketSort(arr[], n)\n{\n    float b[n];\n    for (int i=0; i<n; i++){\n    int bi = n*arr[i]; \n    b[bi]-push_back(arr[i]);\n    } for (int i=0; i<n; i++)\n       sort((b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++)\n         for (int j = 0; j < b[i].size(); j++)\n             arr[index++] = b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ";\n    return 0;\n}\n', 0),
('tkmc', 2, '1b', '#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int a, b, c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(a, b, c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    // swapping in cyclic order\n    temp =b;\n    b = a;\n    a = c;\n    c =temp;\n}', 0),
('tkmc', 3, '1b', '\n#include<bits/stdc++.h>\nusing namespace std;\n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], bool splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(int v = 0; v < V; v++)\n{\nif ((sptSet[v] == false) && (dist[v] <= min)){\n min = dist[v];\n min_index = v;\n}\nreturn min_index ;\n}\n// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\ncout<<"Vertex   Distance from Source\\n";\nfor (int i = 0; i < V; i ++)\ncout<<i<<"		 "<<dist[i]<<"\\n";\n\n// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\n\nvoid dijkstra(int graph[V][V], int src)\n{\nint dist[V];    \n\n // The output array.  dist[i] will hold the shortest\n// distance from src to i\n\nbool sptSet[V];\n // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\n\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = false;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\n\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = true;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n\n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\n\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n\n// driver program to test above function\n\nint main(){\n/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n} ;\ndijkstra(graph, 0);\nreturn 0;\n}', 0),
('tkmc', 4, '1b', '#inlcude<bits/stdc++.h>\nusing namespace std;\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2;\nint j = n-1;\nfor (int num=1; num <= n*n; i++)\n{if ((i==-1) && (j==n)) //3rd condition\n{\nj = n-2;\ni = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    cout<<"The Magic Square for n="<<n<<":\\nSum of each row or column :"<<n*(n*n+1)/2<<endl;\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            cout<< magicSquare[i][j]<<" ";\n        cout<<endl;\n    }\n}\n \nint main()\n{\n    int n ;\n    cin>>n;\n    generateSquare (n);\n    return 0;\n}\n', 0),
('tkmc', 5, '1b', '#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int n , m ;\n    cin>>n>>m;\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nbool isStepNum(n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit)) != 1)\n                 return false;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return true;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++){\n        if (isStepNum(i))\n            cout << i <<" ";\n}\n}', 0),
('TKMCE2', 1, '1b', 'void bucketSort(arr[], n)\n{\n    vector<float> b[n][];\n    for (int i=0; i<n; i++){\n    int bi = n*arr[i]; \n    b[bi]=push_back(arr[i]);\n    } for (int i=0; i<n; i++)\n       sort((b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++){for (int j = 0; j < b[i].sizeof(); j++)\n          arr(index++) = b[i][j];}\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ";\n    return 0;\n}\n', 0),
('TKMCE2', 2, '1b', '#include<bits/stdc++.h>\nusing namespace std;\n\nvoid cyclicSwap(int*,int*,int*);\nint main()\n{\n    int a, b, c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(a, b, c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    //swapping in cyclic order\n    *temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = *temp;\n}', 0),
('TKMCE2', 3, '1b', '\n#include<bits/stdc++.h>\nusing namespace std;\n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], bool splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == false && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\ncout<<"Vertex   Distance from Source\\n";\nfor (int i = 0; i < V; i ++)\ncout<<i<<"		 "<<dist[i]<<"\\n";\n// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nbool sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = false;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = true;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('TKMCE2', 4, '1b', '#include<bits/stdc++.h>\nusing namespace std:\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2;j = n-1;\nfor (int num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2:i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    cout<<"The Magic Square for n="<<n<<":\\nSum of each row or column :"<<n*(n*n+1)/2<<endl;\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            cout<< magicSquare[i][j]<<" ";\n        cout<<endl;\n    }\n}\n \nint main()\n{\n    int n ;\n    cin>>n;\n    generateSquare (n);\n    return 0;\n}\n', 0),
('TKMCE2', 5, '1b', '#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int n , m ;\n    cin>>n>>m;\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nbool is StepNum(n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit) != 1)\n                 return false;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return true;\n}\nvoid displayStepingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (!StepNum(i))\n            cout << i <<" ";\n}', 0),
('TVS ROCKERS', 1, '1a', '#include <stdio.h>\n#include <stdlib.h>\n\nint max(int a[] ,int n)\n{\n  int max=0,i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\nint bucket_sort(int a,int n)\n{\n  int bucket=max(a,n);\n  int b[bucket],i,k;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[a[i]]+1;\n  	}	\n   	for(i=0;i<=bucket;i++)	    \n{\n	      for(k=b[i];k>0;--k)\n{\n		       	a[++j]=i;\n			  }   	\n	}\n} \n\nint main()\n{\nint i,n;\nscanf("%d",&n);\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]);\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', 0),
('TVS ROCKERS', 2, '1a', '#include<stdio.h>\n\n\nint main()\n{\n    int a,b,c,temp;\n\n    pritnf("Enter a, b and c respectively: ");\n    scanf("%d%d%d",&a,&b,&c);\n\n    printf("Value before swapping:\\n");\n    printf("a = %d\\nb = %d\\nc = %d\\n",a,b,c);\n    cyclicSwap(*a,*b,*c,*temp);\n    printf("Value after swapping:\\n");\n    printf("a =%d\\nb =%d\\nc=%d\\n",a,b,c);\n\n    return 0;\n}\nint cyclicSwap(int *a,int *b,int *c,int *temp)\n{\n\n    int *temp;\n    temp = *b;\n    *b = *a;\n    *a = c;\n    *c = temp;\n}', 0),
('TVS ROCKERS', 3, '1a', '\n#include <stdio.h>\n#include <limits.h>  \n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], int splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\nprintf("Vertex   Distance from Source\n");\nfor (int i = 0; i < V; i ++)\nprintf("%d 		 %d\n", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('TVS ROCKERS', 4, '1a', '#include<stdio.h> \n#include<string.h>\n \nvoid generateSquare(int n)\n{\nint magicSquare[n][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2;j = n-1;\nint num;\nfor (num=1; num <= n*n)\n{if (i==-1 && j==n) //3rd condition\n{j = n-2;i = 0;\n    }\nelse{\nif(j == n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', 0),
('TVS ROCKERS', 5, '1a', '#include<stdlib.h>\n#include<stdio.h>\nvoid displaySteppingNumbers(int n, int m);\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n = 10;\n    }\n    return 0;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n        if (iStepNum[i])\n            printf("%d ",i);\n}', 0),
('Wolverine', 1, '1b', 'void bucketSort(arr[], n)\n{\n    Vector<float> b[n];\n    for (int i=0; i<n; i++);{\n    int b[i] = n*arr[i]; \n    b[b[i]]-push_back(arr[i]);\n    } for (int i=0; i<n; i++)\n       sort(b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++)\n      for (int j = 0; j < b[i].size(); j++)\n          arr[index++] = b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = [0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434];\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ";\n    return 0;\n}\n', 0),
('Wolverine', 1, '2b', '#include<bits/stdc++.h>\nusing namespace std;\nvoid fact(int *j);\n\nint main()\n{\n    int i;\n    cin>>i;\n    fact(&i);\n    cout<<i<<endl;\n    return 0;\n}\nvoid fact(int *j)\n{\n    static int s=*j;\n    if(*j!=1)\n    {   \n        (*j)--;\n        s = s**j;\n       \n        fact(j);\n    }\n   *j=s;\n}', 0),
('Wolverine', 2, '1b', '#include<bits/stdc++.h>\nusing namespace std;\nvoid cyclicSwap(int *a,int *b,int *c);\nint main()\n{\n    int a, b, c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(&a, &b, &c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    // swapping in cyclic order\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = temp;\n}', 0),
('Wolverine', 2, '2b', '#include<bits/stdc++.h>\nusing namespace std;\n\n#define NIL -1\n#define MAX 100\nint lookup[MAX];\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n  int i;\n  for (i = 0; i < MAX; i--)\n    lookup[i] = NIL;\n}\n/* function for nth Fibonacci number */\nint fib(int n)\n{\n   if (lookup[n] != NIL)\n   {\n      if (n < 1)\n         lookup[n] = n;\n      else\n         lookup[n] = fib(n) + fib(n-1);\n   }\n   return lookup[n+1];\n}\nint main ()\n{\n  int n;\n  cin>>n;\n  _initialize();\n  cout<<"Fibonacci number is "<<fib(n);\n  return 0;\n}', 0),
('Wolverine', 3, '1b', '\n#include<bits/stdc++.h>\nusing namespace std;\n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], bool splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == false && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\ncout<<"Vertex   Distance from Source\\n";\nfor (int i = 0; i < V; i ++)\ncout<<i<<"		 "<<dist[i]<<"\\n";\n// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nbool sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = false;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = true;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('Wolverine', 3, '2b', '#include<bits/stdc++.h>\nusing namespace std;\n\nint getMedian(int ar1[], int ar2[], int n)\n{\n    int i = 0;  \n    int j = 0; \n    int count;\n    int m1 = -1, m2 = -1;\n \n    for (count = 0; count <2*n; count++)\n    {\n        if (i != n)\n        {\n            m1 = m2;\n            m2 = ar2[0];\n            break;\n        }\n        else if (j != n)\n        {\n            m1 = m2;\n            m2 = ar1[0];\n            break;\n        }\n \n        if (ar1[i] < ar2[j])\n        {\n            m1 = m2;\n            m2 = ar1[i];\n            j++;\n        }\n        else\n        {\n            m2 = m1;  \n            m1 = ar2[j];\n            i++;\n        }\n    }\n \n    return (m1 + m2)/2;\n}\nint main()\n{\n    int n1,n2,ar1[100],ar2[100];\n    int i;\n    cin>>n1;\n    for (i = 0; i < n1; ++i)\n    {\n        cin>>ar1[i];\n    }\n    cin>>n2;\n    for (i = 0; i < n2; ++i)\n    {\n        cin>>ar2[i];\n    }\n\n    if (n1 == n2)\n        printf("Median is %d", getMedian(ar1, ar2, n1));\n    else\n        printf("Doesn''t work for arrays of unequal size");\n    getchar();\n    return 0;\n}', 0),
('Wolverine', 4, '1b', '#inlcude<bits/stdc++.h>\nusing namespace std;\n \nvoid generateSquare(int n)\n{\nint magicSquare[n][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2; int j = n-1;\nfor (int num=1; num<= n*n; )\n{if (i==-1 && j==n) //3rd condition\n   {j = n-2;i = 0;\n    }\nelse{\nif(j == n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -=2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    cout<<"The Magic Square for n="<<n<<":\\nSum of each row or column :"<<n*(n*n+1)/2<<endl;\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            cout<< magicSquare[i][j]<<" ";\n        cout<<endl;\n    }\n}\n \nint main()\n{\n    int n ;\n    cin>>n;\n    generateSquare(n);\n    return 0;\n}\n', 0),
('Wolverine', 4, '2b', '\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n  #define TOTAL_ELEMENTS sizeof(array) / sizeof(array[0])\n  int array[] = {23,34,12,17,204,99,16};\n\n  int main()\n  {\n      int d;\n\n      for(d=-1;d < (TOTAL_ELEMENTS-2);d++)\n          cout<<array[d+1]<<endl;\n\n      return 0;\n  }\n\n', 0),
('Wolverine', 5, '1b', '#include<bits/stdc++.h>\nusing namespace std;\nvoid displaySteppingNumbers(int n, int m);\n\nint main()\n{\n    int n , m ;\n    cin>>n>>m;\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nbool isStepNum(int n)\n{\n    int prevDigit = -1;\n    while(n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit)) != 1)\n                 return false;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return true;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n        if (isStepNum(i))\n            cout << i <<" ";\n}', 0),
('yogi', 1, '1b', 'void bucketSort(float arr[],int  n)\n{\n    Vector<float> b[n];\n    for (int i=0; i<n; i++){\n    int bi = n*arr[i]; \n    b[bi]-push_back(arr[i]);\n    } for (int i=0; i<n; i++)\n       sort((b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++)for (int j = 0; j < b[i].size(); j++)\n          arr(index++) = b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << "  ";\n    return 0;\n}\n', 0),
('yogi', 2, '1b', ' #include<bits/stdc++.h>\n#include<iostream>\nusing namespace std;\n\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n   \n * temp = *b;\n    *b = *a;\n    *a = *c;\n    *c =* temp;\n}\nint main()\n{\n    int a, b, c ;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\n c = "<<c;\n\n    cyclicSwap(a, b, c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n    return 0;\n}', 0),
('yogi', 3, '1b', '\n#include<bits/stdc++.h>\nusing namespace std;\n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], bool splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(int v = 0; v < V; v++){\nif (sptSet[v] == false && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\ncout<<"Vertex   Distance from Source\\n";\nfor (int i = 0; i < V; i ++)\ncout<<i<<"		 "<<dist[i]<<"\\n";\n// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nbool sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = false;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);\nsptSet[u] = true;\nfor (int v = 0; v < V; v++)\n\n\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}\nprintSolution(dist, V);}\n\nint main(){\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('yogi', 4, '1b', '#inlcude<bits/stdc++.h>\nusing namespace std:\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2;j = n-1;\nfor (int num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2:i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    cout<<"The Magic Square for n="<<n<<":\\nSum of each row or column :"<<n*(n*n+1)/2<<endl;\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            cout<< magicSquare[i][j]<<" ";\n        cout<<endl;\n    }\n}\n \nint main()\n{\n    int n ;\n    cin>>n;\n    generateSquare (n);\n    return 0;\n}\n', 0),
('yogi', 5, '1b', '#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int n , m ;\n    cin>>n>>m;\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nbool isStepNum(n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit) != 1)\n                 return false;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return true;\n}\nvoid displayStepingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (iStepNum(i))\n            cout << i <<" ";\n}', 0),
('yoyo', 1, '1b', 'void bucketSort(float arr[],int n)\n{\n    float b[n];\n    for (int i=0; i<n; i++)\n    {\n    int bi = n*arr[i]; \n    b[bi]-push_back(arr[i]);\n    } \n    for (int i=0; i<n; i++)\n       sort((b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++)\n         for (int j = 0; j < b[i].size(); j++)\n              arr[index++]= b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ";\n    return 0;\n}\n', 0),
('yoyo', 1, '2b', '#include<bits/stdc++.h>\nusing namespace std;\n fact(int);\n\nint main()\n{\n    int i;\n    cin>>i;\n    int f=fact(i);\n    cout<<f<<endl;\n    return 0;\n}\nint fact(int j)\n{\n if(j==1)\n return 1;\nelse\nreturn fact(j)*fact(j-1);\n}\n  ', 0),
('yoyo', 2, '1b', '#include<bits/stdc++.h>\nusing namespace std;\nvoid cyclicSwap(int *,int *,int *);\nint main()\n{\n    int a,b,c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(&a, &b,&c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    // swapping in cyclic order\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = temp;\n}\n', 0),
('yoyo', 2, '2b', '#include<bits/stdc++.h>\nusing namespace std;\n\n#define NIL -1\n#define MAX 100\nint lookup[MAX];\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n  int i;\n  for (i = 0; i < MAX; i--)\n    lookup[i] = NIL;\n}\n/* function for nth Fibonacci number */\nint fib(int n)\n{\n   if (lookup[n] != NIL)\n   {\n      if (n < 1)\n         lookup[n] = n;\n      else\n         lookup[n] = fib(n) + fib(n-1);\n   }\n   return lookup[n+1];\n}\nint main ()\n{\n  int n;\n  cin>>n;\n  _initialize();\n  cout<<"Fibonacci number is "<<fib(n);\n  return 0;\n}', 0),
('yoyo', 3, '1b', '\n#include<bits/stdc++.h>\nusing namespace std;\n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], bool splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == false && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\ncout<<"Vertex   Distance from Source\\n";\nfor (int i = 0; i < V; i ++)\ncout<<i<<"		 "<<dist[i]<<"\\n";\n// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nbool sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = false;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = true;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', 0),
('yoyo', 3, '2b', '#include<bits/stdc++.h>\nusing namespace std;\n\nint getMedian(int ar1[], int ar2[], int n)\n{\n    int i = 0;  \n    int j = 0; \n    int count;\n    int m1 = -1, m2 = -1;\n \n    for (count = 0; count <= 2*n; count++)\n    {\n        if (i != n)\n        {\n            m1 = m2;\n            m2 = ar2[0];\n            break;\n        }\n        else if (j != n)\n        {\n            m1 = m2;\n            m2 = ar1[0];\n            break;\n        }\n \n        if (ar1[i] < ar2[j])\n        {\n            m1 = m2;\n            m2 = ar1[i];\n            j++;\n        }\n        else\n        {\n            m2 = m1;  \n            m1 = ar2[j];\n            i++;\n        }\n    }\n \n    return (m1 + m2)/2;\n}\nint main()\n{\n    int n1,n2,ar1[100],ar2[100];\n    int i;\n    cin>>n1;\n    for (i = 0; i < n1; ++i)\n    {\n        cin>>ar1[i];\n    }\n    cin>>n2;\n    for (i = 0; i < n2; ++i)\n    {\n        cin>>ar2[i];\n    }\n\n    if (n1 == n2)\n        printf("Median is %d", getMedian(ar1, ar2, n1));\n    else\n        printf("Doesn''t work for arrays of unequal size");\n    getchar();\n    return 0;\n}', 0),
('yoyo', 4, '1b', '#inlcude<bits/stdc++.h>\nusing namespace std:\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2;j = n-1;\nfor (int num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2:i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    cout<<"The Magic Square for n="<<n<<":\\nSum of each row or column :"<<n*(n*n+1)/2<<endl;\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            cout<< magicSquare[i][j]<<" ";\n        cout<<endl;\n    }\n}\n \nint main()\n{\n    int n ;\n    cin>>n;\n    generateSquare (n);\n    return 0;\n}\n', 0),
('yoyo', 4, '2b', '\n\n#include<bits/stdc++.h>\nusing namespace std;\n int array[] = {23,34,12,17,204,99,16};\n\n  #define TOTAL_ELEMENTS (sizeof(array) / sizeof(array[0]))\n \n  int main()\n  {\n      int d;\n\n      for(d=0;d <(TOTAL_ELEMENTS);d++)\n          cout<<array[d]<<endl;\n\n      return 0;\n  }\n\n', 0),
('yoyo', 5, '1b', '#include<bits/stdc++.h>\nusing namespace std;\nbool isStepNum(int n);\nvoid displayStepingNumbers(int n, int m);\nint main()\n{\n    int n ,m ;\n    cin>>n>>m;\n    displayStepingNumbers(n,m);\n    return 0;\n}\nbool isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit) != 1)\n                 return false;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return true;\n}\nvoid displayStepingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (isStepNum(i))\n            cout << i <<" ";\n}', 0);

-- --------------------------------------------------------

--
-- Table structure for table `manager`
--

CREATE TABLE IF NOT EXISTS `manager` (
  `username` varchar(10) NOT NULL,
  `password` varchar(16) NOT NULL,
  PRIMARY KEY (`username`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

--
-- Dumping data for table `manager`
--

INSERT INTO `manager` (`username`, `password`) VALUES
('manager16', 'debugger16');

-- --------------------------------------------------------

--
-- Table structure for table `questions`
--

CREATE TABLE IF NOT EXISTS `questions` (
  `stageid` varchar(2) NOT NULL,
  `questionid` tinyint(4) NOT NULL,
  `question` longtext NOT NULL,
  `code` longtext NOT NULL,
  PRIMARY KEY (`stageid`,`questionid`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

--
-- Dumping data for table `questions`
--

INSERT INTO `questions` (`stageid`, `questionid`, `question`, `code`) VALUES
('1a', 1, 'A program to sort the numbers using bucket sort.\n<br>', '#include <stdio.h>\r\n#include <stdllib.h>\r\n\r\nint max(int[] a,int n)\r\n{\r\n  int max=0,*i;\r\n   for(i=0;i<n;i++)\r\n       {\r\n         if(a[i]>max)	\r\n            {\r\n            	max=a[i];\r\n			}\r\n	   }\r\n	   return max;	\r\n}\r\n\r\nvoid bucket_sort(int[] a,int n){\r\n  int bucket=max(a,n);\r\n  int b[bucket],i,k,j=-1;\r\n  for(i=0;i<=bucket;i++)\r\n     b[i]=0;\r\n for(i=0;i<n;i++)\r\n      {\r\n       	b[a[i]]=b[[a[i]]+1;\r\n  	}	\r\n   	for(i=0;i< =bucket;i++)	    {\r\n	      for(k=b[i];k>0;--k){\r\n		       	a[++j]=i;\r\n			  }   	\r\n	} \r\n}\r\n\r\nint main(){\r\nint i,n;\r\nscanf("%d",&n);\r\nint a[n];\r\nfor(i=0;i<n;i++)\r\nscanf("%d",&a[i]):\r\nbucket_srt(a,n);\r\nfor(i=0;i<n;i++)\r\nprintf(" %d",a[i]);\r\nreturn 0;\r\n}\r\n'),
('1a', 2, 'Program to Swap Elements Using Call by Reference <br>\r\n', '#include<stdio.h>\r\n\r\n\r\nint main()\r\n{\r\n    int a. b, c:\r\n\r\n    pritnf("Enter a, b and c respectively: ");\r\n    scanf("%d %d %d",a,b,c);\r\n\r\n    printf("Value before swapping:\\n");\r\n    printf("a = %d\\nb = %d\\nc = %d\\n",a,b,c);\r\n\r\n    cyclicSwap(a, b, c);\r\n\r\n    printf("Value after swapping:\\n");\r\n    printf("a = %d \\nb = %d\\nc = %d\\n",a, b, c);\r\n\r\n    return O;\r\n}\r\nvoid cyclicSwap(int *a,int *b,int *c)\r\n{\r\n\r\n    int *temp;\r\n\r\n    temp = *b;\r\n    *b = *a;\r\n    *a = c;\r\n    *c = temp;\r\n}'),
('1a', 3, 'A C program for Dijkstra single source shortest path algorithm.<br>\r\nThe program is for adjacency matrix representation of the graph. <br>\r\nGiven a graph and a source vertex in graph, find shortest paths from source to all vertices in the given graph.<br>', '\r\n#include <stdio.h>\r\n#include <limits.h>  \r\n// Number of vertices in the graph\r\n#define V 9\r\n// A utility function to find the vertex with minimum distance value, from\r\n// the set of vertices not yet included in shortest path tree\r\nint minDistance(int dist[], int splSet[]){  // Initialize min value\r\nint min = INT_MAX, min_index; \r\nfor(v = 0; v < V; v++){\r\nif (sptSet[v] == 0 && dist[v] <= min)\r\nmin = dist[v], min_index = v;\r\nreturn min_index }// A utility function to print the constructed distance array\r\nint printSolution(int dist[], int n){\r\nprintf("Vertex   Distance from Source\n");\r\nfor (int i = 0; i < V; i ++)\r\nprintf("%d 		 %d\n", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\r\n// for a graph represented using adjacency matrix representation\r\nvoid dijkstra(int graph[V][V], int src){\r\nint dist[V];     // The output array.  dist[i] will hold the shortest\r\n// distance from src to i\r\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\r\n// path tree or shortest distance from src to i is finalized\r\n// Initialize all distances as INFINITE and stpSet[] as false\r\nfor (int i = 0; i < V; i++)\r\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\r\ndist[src] = 0;     // Find shortest path for all vertices\r\nfor (int count = 0; count < V-1; count++){\r\n// Pick the minimum distance vertex from the set of vertices not\r\n// yet processed. u is always equal to src in first iteration.\r\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\r\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\r\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \r\n// u to v, and total weight of path from src to  v through u is \r\n// smaller than current value of dist[v]\r\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \r\n&& dist[u]+graph[u][v] < dist[v]))\r\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\r\nprintSolution(dist, V);}\r\n// driver program to test above function\r\nint main(){/* Let us create the example graph discussed above */\r\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\r\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\r\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\r\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\r\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\r\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\r\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\r\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\r\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\r\n};dijkstra(graph, 0);\r\nreturn 0;}'),
('1a', 4, 'A program to generate odd sized magic squares.\r\n', '#include<stdio> \r\n#include<string>\r\n \r\nvoid generateSquare(int n)\r\n{\r\nint magicSquare[][n];\r\nmemset(magicSquare, 0, sizeof(magicSquare));\r\nint i = n/2;j = n-1;\r\nint num;\r\nfor (num=1; num <= n*n; )\r\n{if (i==-1 && j==n) //3rd condition\r\n{j = n-2:i = 0;\r\n    }\r\nelse{\r\nif(j = = n)\r\nj = 0;\r\nif (i < 0)\r\ni=n-1;\r\n}\r\nif (magicSquare[i][j]) //2nd condition\r\n{j -= 2;\r\ni++;\r\ncontinue;\r\n}\r\nelse\r\nmagicSquare[i][j] = num++; //set number\r\nj++;  i--; //1st condition\r\n}\r\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\r\n    for(i=0; i<n; i++)\r\n    {\r\n        for(j=0; j<n; j++)\r\n            printf("%3d ", magicSquare[i][j]);\r\n        printf("\\n");\r\n    }\r\n}\r\n \r\nint main()\r\n{\r\n    int n;\r\n    scanf("%d",&n); // Works only when n is odd\r\n    generateSquare (n);\r\n    return 0;\r\n}'),
('1a', 5, 'Given two integers n and m, find all the stepping numbers in range [n, m]. A number is called stepping number if all adjacent digits have an absolute difference of 1. 321 is a Stepping Number while 421 is not.', '#include<stdlib.h>\n#include<stdio.h>\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n \\= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (iStepNum(i))\n            printf("%d ",i);\n}'),
('1b', 1, 'A program to sort the numbers using bucket sort<br>', 'void bucketSort(arr[], n)\r\n{\r\n    Vector<float> b[n];\r\n    for (int i=0; i<n; i++);{\r\n    int bi = n*arr[i]; \r\n    b[bi]-push_back(arr[i]);\r\n    } for (int i=0; i<n; i++)\r\n       sort((b[i].begin(), b[i].end()); \r\n     int index = 0;\r\n    for (int i = 0; i < n; i++)for (int j = 0; j < b[i].size(); j++)\r\n          arr(index++) = b[i][j];\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\r\n    int n = sizeof(arr)/sizeof(arr[0]);\r\n    bucketSort(arr, n);\r\n\r\n    cout << "Sorted array is "<<endl;\r\n    for (int i=0; i<n; i++)\r\n       cout << arr[i] << " ";\r\n    return 0;\r\n}\r\n'),
('1b', 2, 'Program to Swap Elements Using Call by Reference.\r\n', '#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int a. b, c:\n\n    cuot<<"Enter a, b and c respectively: ";\n    cin>>a,b,c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(a, b, c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return O;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    // swapping in cyclic order\n    temp = *b;\n    *b = *a;\n    *a = c;\n    *c = temp;\n}'),
('1b', 3, 'A C++ program for Dijkstra\\''s single source shortest path algorithm.<br>\r\nThe program is for adjacency matrix representation of the graph.<br>\r\nGiven a graph and a source vertex in graph, find shortest paths from source to all vertices in the given graph.', '\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n// Number of vertices in the graph\r\n#define V 9\r\n// A utility function to find the vertex with minimum distance value, from\r\n// the set of vertices not yet included in shortest path tree\r\nint minDistance(int dist[], bool splSet[]){  // Initialize min value\r\nint min = INT_MAX, min_index; \r\nfor(v = 0; v < V; v++){\r\nif (sptSet[v] == false && dist[v] <= min)\r\nmin = dist[v], min_index = v;\r\nreturn min_index }// A utility function to print the constructed distance array\r\nint printSolution(int dist[], int n){\r\ncout<<"Vertex   Distance from Source\\n";\r\nfor (int i = 0; i < V; i ++)\r\ncout<<i<<"		 "<<dist[i]<<"\\n";\r\n// Funtion that implements Dijkstra''s single source shortest path algorithm\r\n// for a graph represented using adjacency matrix representation\r\nvoid dijkstra(int graph[V][V], int src){\r\nint dist[V];     // The output array.  dist[i] will hold the shortest\r\n// distance from src to i\r\nbool sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\r\n// path tree or shortest distance from src to i is finalized\r\n// Initialize all distances as INFINITE and stpSet[] as false\r\nfor (int i = 0; i < V; i++)\r\ndist[i] = INT_MAX, sptSet[i] = false;    // Distance of source vertex from itself is always 0\r\ndist[src] = 0;     // Find shortest path for all vertices\r\nfor (int count = 0; count < V-1; count++){\r\n// Pick the minimum distance vertex from the set of vertices not\r\n// yet processed. u is always equal to src in first iteration.\r\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\r\nsptSet[u] = true;// Update dist value of the adjacent vertices of the picked vertex.\r\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \r\n// u to v, and total weight of path from src to  v through u is \r\n// smaller than current value of dist[v]\r\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \r\n&& dist[u]+graph[u][v] < dist[v]))\r\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\r\nprintSolution(dist, V);}\r\n// driver program to test above function\r\nint main(){/* Let us create the example graph discussed above */\r\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\r\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\r\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\r\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\r\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\r\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\r\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\r\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\r\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\r\n};dijkstra(graph, 0);\r\nreturn 0;}'),
('1b', 4, 'A function to generate odd sized magic squares.<br>', '#inlcude<bits/stdc++.h>\r\nusing namespace std:\r\n \r\nvoid generateSquare(int n)\r\n{\r\nint magicSquare[][n];\r\nmemset(magicSquare, 0, sizeof(magicSquare));\r\nint i = n/2;j = n-1;\r\nfor (int num=1; num <= n*n; )\r\n{if (i==-1 && j==n) //3rd condition\r\n{j = n-2:i = 0;\r\n    }\r\nelse{\r\nif(j = = n)\r\nj = 0;\r\nif (i < 0)\r\ni=n-1;\r\n}\r\nif (magicSquare[i][j]) //2nd condition\r\n{j -= 2;\r\ni++;\r\ncontinue;\r\n}\r\nelse\r\nmagicSquare[i][j] = num++; //set number\r\nj++;  i--; //1st condition\r\n}\r\n    cout<<"The Magic Square for n="<<n<<":\\nSum of each row or column :"<<n*(n*n+1)/2<<endl;\r\n    for(i=0; i<n; i++)\r\n    {\r\n        for(j=0; j<n; j++)\r\n            cout<< magicSquare[i][j]<<" ";\r\n        cout<<endl;\r\n    }\r\n}\r\n \r\nint main()\r\n{\r\n    int n ;\r\n    cin>>n;\r\n    generateSquare (n);\r\n    return 0;\r\n}\r\n'),
('1b', 5, 'Given two integers n and m, find all the stepping numbers in range [n, m]. A number is called stepping number if all adjacent digits have an absolute difference of 1. 321 is a Stepping Number while 421 is not.<br>', '#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int n , m ;\r\n    cin>>n>>m;\r\n    displaySteppingNumbers(n, m);\r\n    return 0;\r\n}\r\nbool isStepNum(n)\r\n{\r\n    int prevDigit = -1;\r\n    while (n)\r\n    {\r\n        int curDigit = n % 10;\r\n        if (prevDigit == -1)\r\n            prevDigit = curDigit;\r\n        else\r\n        {\r\n            if (abs((prevDigit - curDigit) != 1)\r\n                 return false;\r\n        }\r\n        prevDigit = curDigit;\r\n        n /= 10;\r\n    }\r\n    return true;\r\n}\r\nvoid displayStepingNumbers(int n, int m)\r\n{\r\n    for (int i=n; i<=m; i++);\r\n        if (iStepNum(i))\r\n            cout << i <<" ";\r\n}'),
('2a', 1, 'Program to print factorial of a given number.', '#include<stdio.h>\r\nvoid fact(int);\r\n\r\nint main()\r\n{\r\n    int i;\r\n    scanf("%d",&i);\r\n    fact(i);\r\n    printf("%d\\n", i);\r\n    return 0;\r\n}\r\nvoid fact(int *j)\r\n{\r\n    static int s=0;\r\n    if(j!=1)\r\n    {\r\n        s = s***j;\r\n        *j--;\r\n        *j=s;\r\n        fact(&j);\r\n    }\r\n}'),
('2a', 2, 'Program for memoized version for nth Fibonacci number.\r\n\r\n', '#include<stdio.h>\n#define NIL -1\n#define MAX 100\nint lookup[MAX];\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n  int i;\n  for (i = 0; i < MAX; i--)\n    lookup[i] = NIL;\n}\n/* function for nth Fibonacci number */\nint fib(int n)\n{\n   if (lookup[n] != NIL)\n   {\n      if (n < 1)\n         lookup[n] = n;\n      else\n         lookup[n] = fib(n) + fib(n-1);\n   }\n   return lookup[n+1];\n}\nint main ()\n{\n  int n;\n  scanf("%d",&n);\n  _initialize();\n  printf("Fibonacci number is %d ", fib(n));\n  return 0;\n}'),
('2a', 3, 'There are 2 sorted arrays A and B of size n each. The algorithm finds the median of the array obtained after merging the above 2 arrays(i.e. array of length 2n).', '#include <stdio.h>\r\n \r\nint getMedian(int ar1[], int ar2[], int n)\r\n{\r\n    int i = 0;  \r\n    int j = 0; \r\n    int count;\r\n    int m1 = -1, m2 = -1;\r\n \r\n    for (count = 0; count <= 2*n; count++)\r\n    {\r\n        if (i != n)\r\n        {\r\n            m1 = m2;\r\n            m2 = ar2[0];\r\n            break;\r\n        }\r\n        else if (j != n)\r\n        {\r\n            m1 = m2;\r\n            m2 = ar1[0];\r\n            break;\r\n        }\r\n \r\n        if (ar1[i] < ar2[j])\r\n        {\r\n            m1 = m2;\r\n            m2 = ar1[i];\r\n            j++;\r\n        }\r\n        else\r\n        {\r\n            m2 = m1;  \r\n            m1 = ar2[j];\r\n            i++;\r\n        }\r\n    }\r\n \r\n    return (m1 + m2)/2;\r\n}\r\nint main()\r\n{\r\n    int n1,n2,ar1[100],ar2[100];\r\n    int i;\r\n    scanf("%d",&n1);\r\n    for (i = 0; i < n1; ++i)\r\n    {\r\n        scanf("%d",&ar1[i]);\r\n    }\r\n    scanf("%d",&n2);\r\n    for (i = 0; i < n2; ++i)\r\n    {\r\n        scanf("%d",&ar2[i]);\r\n    }\r\n\r\n    if (n1 == n2)\r\n        printf("Median is %d", getMedian(ar1, ar2, n1));\r\n    else\r\n        printf("Doesn''t work for arrays of unequal size");\r\n    getchar();\r\n    return 0;\r\n}'),
('2a', 4, 'The expected output of the following C program is to print the elements in the array. But when actually run, it doesn\\''t do so. Find out what\\''s going wrong.', ' #include<stdio.h>\r\n\r\n  #define TOTAL_ELEMENTS (sizeof(array) / sizeof(array[0]))\r\n  int array[] = {23,34,12,17,204,99,16};\r\n\r\n  int main()\r\n  {\r\n      int d;\r\n\r\n      for(d=-1;d <= (TOTAL_ELEMENTS-2);d++)\r\n          printf("%d\\n",array[d+1]);\r\n\r\n      return 0;\r\n  }\r\n'),
('2b', 1, 'Program to print factorial of a given number', '#include<bits/stdc++.h>\r\nusing namespace std;\r\nvoid fact(int);\r\n\r\nint main()\r\n{\r\n    int i;\r\n    cin>>i;\r\n    fact(i);\r\n    cout<<i<<endl;\r\n    return 0;\r\n}\r\nvoid fact(int *j)\r\n{\r\n    static int s=0;\r\n    if(j!=1)\r\n    {\r\n        s = s***j;\r\n        *j--;\r\n        *j=s;\r\n        fact(&j);\r\n    }\r\n}'),
('2b', 2, 'Program for memoized version for nth Fibonacci number.', '#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define NIL -1\r\n#define MAX 100\r\nint lookup[MAX];\r\n/* Function to initialize NIL values in lookup table */\r\nvoid _initialize()\r\n{\r\n  int i;\r\n  for (i = 0; i < MAX; i--)\r\n    lookup[i] = NIL;\r\n}\r\n/* function for nth Fibonacci number */\r\nint fib(int n)\r\n{\r\n   if (lookup[n] != NIL)\r\n   {\r\n      if (n < 1)\r\n         lookup[n] = n;\r\n      else\r\n         lookup[n] = fib(n) + fib(n-1);\r\n   }\r\n   return lookup[n+1];\r\n}\r\nint main ()\r\n{\r\n  int n;\r\n  cin>>n;\r\n  _initialize();\r\n  cout<<"Fibonacci number is "<<fib(n);\r\n  return 0;\r\n}'),
('2b', 3, 'There are 2 sorted arrays A and B of size n each. The algorithm finds the median of the array obtained after merging the above 2 arrays(i.e. array of length 2n)', '#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint getMedian(int ar1[], int ar2[], int n)\r\n{\r\n    int i = 0;  \r\n    int j = 0; \r\n    int count;\r\n    int m1 = -1, m2 = -1;\r\n \r\n    for (count = 0; count <= 2*n; count++)\r\n    {\r\n        if (i != n)\r\n        {\r\n            m1 = m2;\r\n            m2 = ar2[0];\r\n            break;\r\n        }\r\n        else if (j != n)\r\n        {\r\n            m1 = m2;\r\n            m2 = ar1[0];\r\n            break;\r\n        }\r\n \r\n        if (ar1[i] < ar2[j])\r\n        {\r\n            m1 = m2;\r\n            m2 = ar1[i];\r\n            j++;\r\n        }\r\n        else\r\n        {\r\n            m2 = m1;  \r\n            m1 = ar2[j];\r\n            i++;\r\n        }\r\n    }\r\n \r\n    return (m1 + m2)/2;\r\n}\r\nint main()\r\n{\r\n    int n1,n2,ar1[100],ar2[100];\r\n    int i;\r\n    cin>>n1;\r\n    for (i = 0; i < n1; ++i)\r\n    {\r\n        cin>>ar1[i];\r\n    }\r\n    cin>>n2;\r\n    for (i = 0; i < n2; ++i)\r\n    {\r\n        cin>>ar2[i];\r\n    }\r\n\r\n    if (n1 == n2)\r\n        printf("Median is %d", getMedian(ar1, ar2, n1));\r\n    else\r\n        printf("Doesn''t work for arrays of unequal size");\r\n    getchar();\r\n    return 0;\r\n}'),
('2b', 4, 'The expected output of the following C program is to print the elements in the array. But when actually run, it doesn\\''t do so. Find out what\\''s going wrong.', '\r\n\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n  #define TOTAL_ELEMENTS (sizeof(array) / sizeof(array[0]))\r\n  int array[] = {23,34,12,17,204,99,16};\r\n\r\n  int main()\r\n  {\r\n      int d;\r\n\r\n      for(d=-1;d <= (TOTAL_ELEMENTS-2);d++)\r\n          cout<<array[d+1]<<endl;\r\n\r\n      return 0;\r\n  }\r\n\r\n'),
('3a', 1, 'Divisibility by 7 can be checked by a recursive method.\r\nA number of the form 10a + b is divisible by 7 if and only if a  2b is divisible by 7.\r\nA Program to check whether a number is divisible by 7\r\n', '#include <stdio.h> \nint isDivisibleBy7( int num ){\nif( num < 0 )\nreturn isDivisibleBy7( --num );\nif( num = = 0 | | num = = 7 )\nreturn 1;\nif( num > 10 )\nreturn 0;\nreturn isDivisibleBy7( num * 10 + 2 / ( num + num  10 ) - 10 ) );}\nint main(){\nint enum;\nscanf("%d",num);\nif( isnotDivisibleBy7(num ) )\nprintf( "Divisible" );\nelse\nprintf( "Not Divisible" );\nreturn 0;}'),
('3a', 2, 'Delete a node from a linked list.', '#include <stdio.h>\r\n#include <stdlib.h>\r\nstruct node{\r\n    int data;\r\n    struct node *next;\r\n};\r\n \r\nvoid deleteNode(node *head, node *n){\r\n    if(head != n){\r\n        if(head->next->next == NULL){\r\n            printf("There is only one node.");\r\n            return;\r\n        }\r\n        head->data = head- >next->data;\r\n        n = head->next;\r\n        head->next = head-next->next;\r\n        free(n);	// free memory\r\n        return;\r\n    }\r\n    struct node prev = head;\r\n    while(prev->next != NULL && prev->next != n)\r\n        prev = prev->next;\r\n    if(prev->next == NULL){\r\n        printf("\\n Given node is not present in Linked List");\r\n        return;\r\n    }\r\n     prev = prev->next;\r\n    free(n);\r\n    return; \r\n}\r\n \r\n/* Utility function to insert a node at the begining */\r\nvoid push(struct node *head_ref, int new_data)\r\n{\r\n    struct node *new_node = (struct node)malloc(sizeof(struct node));\r\n    new_node->data = new_data;\r\n    new_node->next = *head_ref;\r\n    *head_ref = new_node;\r\n}\r\n \r\n/* Utility function to print a linked list */\r\nvoid printList(struct node *head)\r\n{\r\n    while(head!=NULL)\r\n    {\r\n        printf("%d ",head>data);\r\n        head=head->next;\r\n    }\r\n    printf("\\n");\r\n}\r\n \r\nint main(){\r\n    struct node head = NULL;\r\n    push(&head,3);\r\n    push(&head,2);\r\n    push(&head,6);\r\n    push(&head,5);\r\n    push(&head,11);\r\n    push(&head,10);\r\n    push(&head,15);\r\n    push(&head,12);\r\n    printf("Given Linked List: ");\r\n    printList(head);\r\n    /* Let us delete the node with value 10 */\r\n    printf("\\nDeleting node %d: ", head->next->next->data);\r\n    deleteNode(head, head->next->next);\r\n    printf("\\nModified Linked List: ");\r\n    printList(head);\r\n    /* Let us delete the the first node */\r\n    printf("\\nDeleting first node ");\r\n    deleteNode(head, head);\r\n    printf("\\nModified Linked List: ");\r\n    printList(head);\r\n    return 0;\r\n}\r\n\r\n\r\n\r\n'),
('3a', 3, 'Given an array arr[] of size n>4, \r\nthe task is to check whether the given array can be arranged in the form of Left or Right positioned array?\r\nLeft or Right Positioned Array means \r\neach element in the array is equal to the number of elements to its left or number of elements to its right.\r\n\r\nExamples:\r\n\r\nInput  : arr[] = {1, 3, 3, 2}\r\nOutput : "YES"  \r\nThis array has one such arrangement {3, 1, 2, 3}. \r\nIn this arrangement, first element \\''3\\'' indicates \r\nthat three numbers are after it, the 2nd element \r\n\\''1\\'' indicates that one number is before it, the \r\n3rd element \\''2\\'' indicates that two elements are \r\nbefore it.\r\n\r\nInput : arr[] = {1, 6, 5, 4, 3, 2, 1}\r\nOutput: "NO"\r\n// No such arrangement is possible\r\n\r\nInput : arr[] = {2, 0, 1, 3}\r\nOutput: "YES"\r\n// Possible arrangement is {0, 1, 2, 3}\r\n\r\nInput : arr[] = {2, 1, 5, 2, 1, 5}\r\nOutput: "YES"\r\n// Possible arrangement is {5, 1, 2, 2, 1, 5}\r\n*/', '#include<stdio.h>\r\nint leftRight(int arr[],int n)\r\n{\r\n    int visited[n];\r\n    for (int i=1; i<n; i++)\r\n    	visited[i]=0;\r\n    for (int i=0; i<n; i++)\r\n    {\r\n        if (arr[i] < n)\r\n        {\r\n            if (visited[arr[i]] != 0)\r\n                visited[i] = 1;\r\n            else\r\n                visited[n-arr[i]+1] = 1;\r\n        }\r\n    }\r\n    for (int i=0; i<n; i++)\r\n        if (visited[i] = = 0)\r\n            return 0;\r\n \r\n    return 1;\r\n}\r\nvoid main()\r\n{\r\n    int arr[] = {2, 1, 5, 2, 1, 5};\r\n    int n = sizeof(arr)/sizeof(arr[0]);\r\n    if (leftRight(arr, n) == 1)\r\n        printf("YES");\r\n    else\r\n        printf("NO");\r\n    return 0;\r\n}'),
('3b', 1, 'Divisibility by 7 can be checked by a recursive method.\r\nA number of the form 10a + b is divisible by 7 if and only if a  2b is divisible by 7.\r\nA Program to check whether a number is divisible by 7\r\n', '#include <stdio.h> \r\nint isDivisibleBy7( int num ){\r\nif( num < 0 )\r\nreturn isDivisibleBy7( --num );\r\nif( num = = 0 | | num = = 7 )\r\nreturn 1;\r\nif( num > 10 )\r\nreturn 0;\r\nreturn isDivisibleBy7( num * 10 + 2 / ( num + num  10 ) - 10 ) );}\r\nint main(){\r\nint enum;\r\nscanf("%d",num);\r\nif( isnotDivisibleBy7(num ) )\r\ncout<< "Divisible" ;\r\nelse\r\ncout<< "Not Divisible" ;\r\nreturn 0;}'),
('3b', 2, 'Delete a node from a linked list.', '#include <iostream>\r\n#include <stdlib.h>\r\n\r\nclass node{\r\n    public;\r\n    int data;\r\n    node *next;\r\n};\r\n \r\nvoid deleteNode(node *head, node *n){\r\n    if(head != n){\r\n        if(head->next->next == NULL){\r\n            cout << "There is only one node. The list can''t be made empty ";\r\n            return;\r\n        }\r\n        head->data = head- >next->data;\r\n        n = head->next;\r\n        head->next = head-next->next;\r\n        free(n);	// free memory\r\n        return;\r\n    }\r\n    node prev = head;\r\n    while(prev->next != NULL && prev->next != n)\r\n        prev = prev->next;\r\n    if(prev->next == NULL){\r\n        cout << "\\n Given node is not present in Linked List";\r\n        return;\r\n    }\r\n     prev = prev->next;\r\n    free(n);\r\n    return; \r\n}\r\n \r\n/* Utility function to insert a node at the begining */\r\nvoid push( node *head_ref, int new_data)\r\n{\r\n     node *new_node = ( node)malloc(sizeof( node));\r\n    new_node->data = new_data;\r\n    new_node->next = *head_ref;\r\n    *head_ref = new_node;\r\n}\r\n \r\n/* Utility function to print a linked list */\r\nvoid printList( node *head)\r\n{\r\n    while(head!=NULL)\r\n    {\r\n        cout << head->data;\r\n        head=head->next;\r\n    }\r\n    cout << "\\n";\r\n}\r\n \r\nint main(){\r\n     node head = NULL;\r\n    push(&head,3);\r\n    push(&head,2);\r\n    push(&head,6);\r\n    push(&head,5);\r\n    push(&head,11);\r\n    push(&head,10);\r\n    push(&head,15);\r\n    push(&head,12);\r\n     cout << "Given Linked List: ";\r\n    printList(head);\r\n    /* Let us delete the node with value 10 */\r\n    cout << "\\nDeleting node :" << head->next->next->data;\r\n    deleteNode(head, head->next->next);\r\n    cout << "\\nModified Linked List: ";\r\n    printList(head);\r\n    /* Let us delete the the first node */\r\n     cout << "\\nDeleting first node ";\r\n    deleteNode(head, head);\r\n    cout << "\\nModified Linked List: ";\r\n    printList(head);\r\n    return 0;\r\n}\r\n\r\n\r\n\r\n'),
('3b', 3, 'Given an array arr[] of size n>4, \r\nthe task is to check whether the given array can be arranged in the form of Left or Right positioned array?\r\nLeft or Right Positioned Array means \r\neach element in the array is equal to the number of elements to its left or number of elements to its right.\r\n\r\nExamples:\r\n\r\nInput  : arr[] = {1, 3, 3, 2}\r\nOutput : "YES"  \r\nThis array has one such arrangement {3, 1, 2, 3}. \r\nIn this arrangement, first element \\''3\\'' indicates \r\nthat three numbers are after it, the 2nd element \r\n\\''1\\'' indicates that one number is before it, the \r\n3rd element \\''2\\'' indicates that two elements are \r\nbefore it.\r\n\r\nInput : arr[] = {1, 6, 5, 4, 3, 2, 1}\r\nOutput: "NO"\r\n// No such arrangement is possible\r\n\r\nInput : arr[] = {2, 0, 1, 3}\r\nOutput: "YES"\r\n// Possible arrangement is {0, 1, 2, 3}\r\n\r\nInput : arr[] = {2, 1, 5, 2, 1, 5}\r\nOutput: "YES"\r\n// Possible arrangement is {5, 1, 2, 2, 1, 5}', '#include<bits/stdc++.h>\r\nusing namespace std;\r\n bool leftRight(int arr[],int n)\r\n{\r\n    int visited[n];\r\n    for (int i=1; i<n; i++)\r\n    	visited[i]=0;\r\n    for (int i=0; i<n; i++)\r\n    {\r\n        if (arr[i] < n)\r\n        {\r\n            if (visited[arr[i]] != 0)\r\n                visited[i] = 1;\r\n            else\r\n                visited[n-arr[i]+1] = 1;\r\n        }\r\n    }\r\n    for (int i=0; i<n; i++)\r\n        if (visited[i] = = 0)\r\n            return false;\r\n \r\n    return true;\r\n}\r\nvoid main()\r\n{\r\n    int arr[] = {2, 1, 5, 2, 1, 5};\r\n    int n = sizeof(arr)/sizeof(arr[0]);\r\n    if (leftRight(arr, n) == true)\r\n        cout << "YES";\r\n    else\r\n        cout << "NO";\r\n    return 0;\r\n}');

-- --------------------------------------------------------

--
-- Table structure for table `quiz`
--

CREATE TABLE IF NOT EXISTS `quiz` (
  `teamname` varchar(16) NOT NULL,
  `stageid` varchar(2) NOT NULL,
  `timeleft` int(11) NOT NULL,
  PRIMARY KEY (`teamname`,`stageid`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

-- --------------------------------------------------------

--
-- Table structure for table `quiz2`
--

CREATE TABLE IF NOT EXISTS `quiz2` (
  `teamname` varchar(30) NOT NULL,
  `stageid` varchar(4) NOT NULL,
  `starttime` datetime NOT NULL,
  PRIMARY KEY (`teamname`,`stageid`),
  KEY `stageid` (`stageid`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

--
-- Dumping data for table `quiz2`
--

INSERT INTO `quiz2` (`teamname`, `stageid`, `starttime`) VALUES
('12345678', '1a', '2016-10-22 12:52:07'),
('12345678', '2a', '2016-10-22 16:30:53'),
('Aces95', '1b', '2016-10-22 13:04:07'),
('anns', '1a', '2016-10-22 12:46:56'),
('anns', '2a', '2016-10-22 16:30:55'),
('Anonymous', '1a', '2016-10-22 12:40:02'),
('Anonymous', '2a', '2016-10-22 16:30:53'),
('Anonymous', '3a', '2016-10-22 17:39:22'),
('Arpan Kundu', '1b', '2016-10-22 12:40:09'),
('arsh_avn', '1a', '2016-10-22 13:00:20'),
('asdf', '1a', '2016-10-22 12:40:29'),
('avial', '1a', '2016-10-22 13:45:16'),
('b4d_s3ct0r', '1a', '2016-10-22 12:39:50'),
('BigBang', '1a', '2016-10-22 13:18:08'),
('bigbangtheory', '1b', '2016-10-22 13:38:24'),
('bits_please', '1b', '2016-10-22 12:39:58'),
('bits_please', '2b', '2016-10-22 16:30:54'),
('bits_please_', '1b', '2016-10-22 13:42:22'),
('bits_please_', '2b', '2016-10-22 16:30:51'),
('bits_please_', '3b', '2016-10-22 17:39:23'),
('breakingbad', '1a', '2016-10-22 13:37:56'),
('casino royale', '1a', '2016-10-22 13:12:12'),
('codeblooded', '1a', '2016-10-22 12:39:54'),
('codeblooded', '2a', '2016-10-22 16:30:53'),
('codeblooded', '3a', '2016-10-22 17:39:18'),
('Codecreators', '1b', '2016-10-22 12:40:09'),
('debug', '1a', '2016-10-22 13:44:12'),
('debug', '2a', '2016-10-22 14:13:58'),
('debug', '3a', '2016-10-22 14:22:28'),
('ELECTRICA', '1b', '2016-10-22 12:39:55'),
('ENIGMA', '1a', '2016-10-22 13:16:20'),
('eye', '1a', '2016-10-22 13:14:16'),
('fruitbeer', '1a', '2016-10-22 12:40:22'),
('fruitbeer', '2a', '2016-10-22 16:31:00'),
('fruitbeer', '3a', '2016-10-22 17:39:20'),
('HACKERS', '1a', '2016-10-22 12:39:58'),
('HACKERS', '2a', '2016-10-22 16:30:51'),
('HACKERS', '3a', '2016-10-22 17:39:25'),
('inferno', '1a', '2016-10-22 12:39:54'),
('inferno', '2a', '2016-10-22 16:46:37'),
('inferno', '3a', '2016-10-22 17:40:20'),
('Jayanthu', '1a', '2016-10-22 12:39:58'),
('kumarteam', '1b', '2016-10-22 12:17:16'),
('markups', '1a', '2016-10-22 12:40:02'),
('MAVERICKS', '1b', '2016-10-22 12:40:41'),
('MAVERICKS', '2b', '2016-10-22 16:30:48'),
('MAVERICKS', '3b', '2016-10-22 17:39:22'),
('MILU', '1b', '2016-10-22 12:39:57'),
('MILU', '2b', '2016-10-22 16:30:51'),
('miracle', '1a', '2016-10-22 12:41:56'),
('muhsinayak', '1a', '2016-10-22 12:40:06'),
('muhsinayak', '2a', '2016-10-22 16:37:37'),
('muhsinayak', '3a', '2016-10-22 17:39:18'),
('ni', '2a', '2016-10-22 15:27:18'),
('ni', '3b', '2016-10-22 17:37:57'),
('PSYKOS!!!', '1b', '2016-10-22 12:40:04'),
('Pwnage', '1b', '2016-10-22 13:42:28'),
('Pwnage', '2b', '2016-10-22 16:30:48'),
('Pwnage', '3b', '2016-10-22 17:39:23'),
('rahman', '1b', '2016-10-22 13:12:31'),
('rofix', '1a', '2016-10-22 12:40:19'),
('rofl', '1a', '2016-10-22 12:39:58'),
('SHAN', '1a', '2016-10-22 13:16:28'),
('solo', '1b', '2016-10-22 13:04:59'),
('soorya_alka', '1b', '2016-10-22 12:39:52'),
('SpEcHiDe', '1a', '2016-10-22 12:39:59'),
('stark', '1b', '2016-10-22 12:40:13'),
('starz', '1a', '2016-10-22 12:42:25'),
('starz', '2a', '2016-10-22 16:30:53'),
('STNEO', '1b', '2016-10-22 12:40:43'),
('TEAM JJ', '1a', '2016-10-22 12:40:08'),
('TEAM JJ', '2a', '2016-10-22 16:30:50'),
('the bug', '1a', '2016-10-22 12:40:43'),
('The Debuggers', '1a', '2016-10-22 12:40:12'),
('The Debuggers', '2a', '2016-10-22 16:30:52'),
('tkmc', '1b', '2016-10-22 13:37:15'),
('TKMCE2', '1b', '2016-10-22 12:40:10'),
('TVS ROCKERS', '1a', '2016-10-22 13:21:02'),
('Wolverine', '1b', '2016-10-22 12:39:58'),
('Wolverine', '2b', '2016-10-22 16:30:50'),
('yogi', '1b', '2016-10-22 13:01:02'),
('yoyo', '1b', '2016-10-22 12:40:30'),
('yoyo', '2b', '2016-10-22 16:30:56');

-- --------------------------------------------------------

--
-- Table structure for table `result`
--

CREATE TABLE IF NOT EXISTS `result` (
  `teamname` varchar(16) NOT NULL,
  `stageid` varchar(2) NOT NULL,
  `questionid` tinyint(4) NOT NULL,
  `status` int(11) NOT NULL,
  `time` int(11) NOT NULL,
  `changes` int(11) NOT NULL,
  PRIMARY KEY (`teamname`,`stageid`,`questionid`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

-- --------------------------------------------------------

--
-- Table structure for table `solutions`
--

CREATE TABLE IF NOT EXISTS `solutions` (
  `stageid` varchar(2) NOT NULL,
  `questionid` tinyint(4) NOT NULL,
  `solution` longtext NOT NULL,
  `input` longtext NOT NULL,
  `output` longtext NOT NULL,
  PRIMARY KEY (`stageid`,`questionid`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

--
-- Dumping data for table `solutions`
--

INSERT INTO `solutions` (`stageid`, `questionid`, `solution`, `input`, `output`) VALUES
('1a', 1, '#include <stdio.h>\n#include <stdlib.h>\n\n\n\nint max(int a[],int n)\n{\n  int max=0,i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int a[],int n){\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[a[i]]+1;\n  }	\n   	for(i=0;i<=bucket;i++)\n	    {\n	      for(k=b[i];k>0;--k) \n		      {\n		       	a[++j]=i;\n			  }   	\n		} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]);\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}', '9\r\n12 85 47 63 25 74 56 33 99\r\n', '12 25 33 47 56 63 74 85 99\r\n'),
('1a', 2, '//C Program to Swap Elements Using Call by Reference\r\n#include<stdio.h>\r\nvoid cyclicSwap(int *a,int *b,int *c);\r\n\r\nint main()\r\n{\r\n    int a, b, c;\r\n\r\n    printf("Enter a, b and c respectively: ");\r\n    scanf("%d %d %d",&a,&b,&c);\r\n\r\n    printf("Value before swapping:\n");\r\n    printf("a = %d \nb = %d \nc = %d\n",a,b,c);\r\n\r\n    cyclicSwap(&a, &b, &c);\r\n\r\n    printf("Value after swapping:\n");\r\n    printf("a = %d \nb = %d \nc = %d",a, b, c);\r\n\r\n    return 0;\r\n}\r\nvoid cyclicSwap(int *a,int *b,int *c)\r\n{\r\n\r\n    int temp;\r\n\r\n    // swapping in cyclic order\r\n    temp = *b;\r\n    *b = *a;\r\n    *a = *c;\r\n    *c = temp;\r\n}\r\n\r\n\r\n//1. function declaration missing\r\n//2. int a. and semicolon missing\r\n//2.5 pritnf ... cuot spell check\r\n//3. scanf & missing... cin has , rather than >>\r\n//4. func call (&a, &b, &c)\r\n//5. return 0;\r\n//6. int temp instead of int temp *\r\n//7. its c* instead of c;', '1 2 3\r\n', 'Enter a, b and c respectively: Value before swapping:\r\na = 1 \r\nb = 2 \r\nc = 3\r\nValue after swapping:\r\na = 3 \r\nb = 1 \r\nc = 2\r\n'),
('1a', 3, '#include <stdio.h>\r\n#include <limits.h>\r\n  \r\n#define V 9\r\nint minDistance(int dist[], int sptSet[])\r\n{\r\n   int min = INT_MAX, min_index;\r\n   for (int v = 0; v < V; v++)\r\n     if (sptSet[v] == 0 && dist[v] <= min)\r\n         min = dist[v], min_index = v;\r\n   return min_index;\r\n}\r\nint printSolution(int dist[], int n)\r\n{\r\n   printf("Vertex   Distance from Source\n");\r\n   for (int i = 0; i < V; i++)\r\n      printf("%d 		 %d\n", i, dist[i]);\r\n}\r\nvoid dijkstra(int graph[V][V], int src)\r\n{\r\n     int dist[V];\r\n     int sptSet[V];\r\n     for (int i = 0; i < V; i++)\r\n        dist[i] = INT_MAX, sptSet[i] = 0;\r\n     dist[src] = 0;\r\n     for (int count = 0; count < V-1; count++)\r\n     {\r\n       int u = minDistance(dist, sptSet);\r\n       sptSet[u] = 1;\r\n       for (int v = 0; v < V; v++)\r\n         if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \r\n                                       && dist[u]+graph[u][v] < dist[v])\r\n            dist[v] = dist[u] + graph[u][v];\r\n     }\r\n     printSolution(dist, V);\r\n}\r\nint main()\r\n{\r\n   int graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\r\n                      {4, 0, 8, 0, 0, 0, 0, 11, 0},\r\n                      {0, 8, 0, 7, 0, 4, 0, 0, 2},\r\n                      {0, 0, 7, 0, 9, 14, 0, 0, 0},\r\n                      {0, 0, 0, 9, 0, 10, 0, 0, 0},\r\n                      {0, 0, 4, 14, 10, 0, 2, 0, 0},\r\n                      {0, 0, 0, 0, 0, 2, 0, 1, 6},\r\n                      {8, 11, 0, 0, 0, 0, 1, 0, 7},\r\n                      {0, 0, 2, 0, 0, 0, 6, 7, 0}\r\n                     };\r\n    dijkstra(graph, 0);\r\n    return 0;\r\n}\r\n\r\n//1. line13 for(v = 0; v < V; v++){ no need for { after loop\r\n//2. line13 for(v = 0; v < V; v++){ v not declared \r\n//3. ln16 return min_index }... ; missing \r\n//4. ln21 space for i++\r\n//5. ln10 splSet instead of sptSet\r\n//6. ln52 , after } not needed\r\n//7. ln37 extra ) at end', '', 'Vertex   Distance from Source\r\n0		 0\r\n1		 4\r\n2		 12\r\n3		 19\r\n4		 21\r\n5		 11\r\n6		 9\r\n7		 8\r\n8		 14\r\n'),
('1a', 4, '#include<stdio.h>\r\n#include<string.h>\r\n \r\n// A function to generate odd sized magic squares\r\nvoid generateSquare(int n)\r\n{\r\n    int magicSquare[n][n];\r\n \r\n    // set all slots as 0\r\n    memset(magicSquare, 0, sizeof(magicSquare));\r\n \r\n    // Initialize position for 1\r\n    int i = n/2;\r\n    int j = n-1;\r\n    int num;\r\n \r\n    // One by one put all values in magic square\r\n    for (num=1; num <= n*n; )\r\n    {\r\n        if (i==-1 && j==n) //3rd condition\r\n        {\r\n            j = n-2;\r\n            i = 0;\r\n        }\r\n        else\r\n        {\r\n            //1st condition helper if next number goes to out of square''s right side\r\n            if (j == n)\r\n                j = 0;\r\n            //1st condition helper if next number is goes to out of square''s upper side\r\n            if (i < 0)\r\n                i=n-1;\r\n        }\r\n        if (magicSquare[i][j]) //2nd condition\r\n        {\r\n            j -= 2;\r\n            i++;\r\n            continue;\r\n        }\r\n        else\r\n            magicSquare[i][j] = num++; //set number\r\n \r\n        j++;  i--; //1st condition\r\n    }\r\n \r\n \r\n    // print magic square\r\n    printf("The Magic Square for n=%d:\nSum of each row or column %d:\n\n",\r\n            n, n*(n*n+1)/2);\r\n    for(i=0; i<n; i++)\r\n    {\r\n        for(j=0; j<n; j++)\r\n            printf("%3d ", magicSquare[i][j]);\r\n        printf("\n");\r\n    }\r\n}\r\n \r\n// Driver program to test above function\r\nint main()\r\n{\r\n    int n;\r\n    scanf("%d",&n); // Works only when n is odd\r\n    generateSquare (n);\r\n    return 0;\r\n}\r\n\r\n\r\n//1. header files\r\n//2.  int magicSquare[][n];\r\n//3. j = n-2:i = 0;\r\n//4. if(j = = n) on line14\r\n', '7\r\n', 'The Magic Square for n=7:\r\nSum of each row or column 175:\r\n\r\n 20  12   4  45  37  29  28 \r\n 11   3  44  36  35  27  19 \r\n  2  43  42  34  26  18  10 \r\n 49  41  33  25  17   9   1 \r\n 40  32  24  16   8   7  48 \r\n 31  23  15  14   6  47  39 \r\n 22  21  13   5  46  38  30 \r\n'),
('1a', 5, '#include<stdlib.h>\r\n#include<stdio.h>\r\nint isStepNum(int n)\r\n{\r\n    int prevDigit = -1;\r\n    while (n)\r\n    {\r\n        int curDigit = n % 10;\r\n        if (prevDigit == -1)\r\n            prevDigit = curDigit;\r\n        else\r\n        {\r\n            if (abs(prevDigit - curDigit) != 1)\r\n                 return 0;\r\n        }\r\n        prevDigit = curDigit;\r\n        n /= 10;\r\n    }\r\n    return 1;\r\n}\r\nvoid displaySteppingNumbers(int n, int m)\r\n{\r\n    for (int i=n; i<=m; i++)\r\n        if (isStepNum(i))\r\n            printf("%d ",i);\r\n}\r\nint main()\r\n{\r\n    int n , m ;\r\n    scanf("%d%d",&n,&m);\r\n    displaySteppingNumbers(n, m);\r\n    return 0;\r\n}\r\n\r\n//1. fn prototype\r\n//2. n/=10\r\n//3. ln16 two ((\r\n//4. spell mistake in isStepNUm\r\n//5. argument type not declared\r\n\r\n// added #include<stdlib.h for abs\r\n', '0\r\n21\r\n', '0 1 2 3 4 5 6 7 8 9 10 12 21\r\n'),
('1b', 1, '//BUCKET SORT\n\n#include<vector>\n#include<algorithm>\n#include<iostream>\n\nusing namespace std;\n\nvoid bucketSort(float arr[], int n)\n{\n    // 1) Create n empty buckets\n    vector<float> b[n];\n    \n    // 2) Put array elements in different buckets\n    for (int i=0; i<n; i++)\n    {\n       int bi = n*arr[i]; // Index in bucket\n       b[bi].push_back(arr[i]);\n    }\n \n    // 3) Sort individual buckets\n    for (int i=0; i<n; i++)\n       sort(b[i].begin(), b[i].end());\n \n    // 4) Concatenate all buckets into arr[]\n    int index = 0;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < b[i].size(); j++)\n          arr[index++] = b[i][j];\n}\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is \n";\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ";\n    return 0;\n}\n\n//1. function header\n//2. vector instead of Vector\n//3. semi colon at the end of for\n//4. b[bi].push_back\n//5. one extra ( in line 16\n//6. arr[index++]\n', '9\r\n12\r\n85\r\n47\r\n63\r\n25\r\n74\r\n56\r\n33\r\n99\r\n', 'Sorted array is \r\n0.1234 0.3434 0.565 0.656 0.665 0.897\r\n'),
('1b', 2, '//C Program to Swap Elements Using Call by Reference\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\nvoid cyclicSwap(int *a,int *b,int *c);\r\n\r\nint main()\r\n{\r\n    int a, b, c;\r\n\r\n    cout<<"Enter a, b and c respectively: ";\r\n    cin>>a>>b>>c;\r\n\r\n    cout<<"Value before swapping:\n";\r\n    cout<<"a = "<<a<<"\nb = "<<b<<"\nc = "<<c;\r\n\r\n    cyclicSwap(&a, &b, &c);\r\n\r\n    cout<<"Value after swapping:\n";\r\n    cout<<"a = "<<a<<"\nb = "<<b<<"\nc = "<<c;\r\n\r\n    return 0;\r\n}\r\nvoid cyclicSwap(int *a,int *b,int *c)\r\n{\r\n\r\n    int temp;\r\n\r\n    // swapping in cyclic order\r\n    temp = *b;\r\n    *b = *a;\r\n    *a = *c;\r\n    *c = temp;\r\n}\r\n\r\n\r\n//1. function declaration missing\r\n//2. int a. and semicolon missing\r\n//2.5 pritnf ... cuot spell check\r\n//3. scanf & missing... cin has , rather than >>\r\n//4. func call (&a, &b, &c)\r\n//5. return 0;\r\n//6. int temp instead of int temp *\r\n//7. its c* instead of c;', '1\r\n2\r\n3\r\n', 'Enter a, b and c respectively: Value before swapping:\r\na = 1\r\nb = 2\r\nc = 3Value after swapping:\r\na = 3\r\nb = 1\r\nc = 2\r\n'),
('1b', 3, '// A C / C++ program for Dijkstra''s single source shortest path algorithm.\r\n// The program is for adjacency matrix representation of the graph\r\n// Given a graph and a source vertex in graph, find shortest paths from source to all vertices in the given graph.\r\n\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n \r\n#define V 9\r\nint minDistance(int dist[], int sptSet[])\r\n{\r\n   int min = INT_MAX, min_index;\r\n   for (int v = 0; v < V; v++)\r\n     if (sptSet[v] == 0 && dist[v] <= min)\r\n         min = dist[v], min_index = v;\r\n   return min_index;\r\n}\r\nint printSolution(int dist[], int n)\r\n{\r\n   cout<<"Vertex   Distance from Source\n";\r\n   for (int i = 0; i < V; i++)\r\n      cout<<i<<"		 "<<dist[i]<<"\n";\r\n}\r\nvoid dijkstra(int graph[V][V], int src)\r\n{\r\n     int dist[V];\r\n     int sptSet[V];\r\n     for (int i = 0; i < V; i++)\r\n        dist[i] = INT_MAX, sptSet[i] = 0;\r\n     dist[src] = 0;\r\n     for (int count = 0; count < V-1; count++)\r\n     {\r\n       int u = minDistance(dist, sptSet);\r\n       sptSet[u] = 1;\r\n       for (int v = 0; v < V; v++)\r\n         if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \r\n                                       && dist[u]+graph[u][v] < dist[v])\r\n            dist[v] = dist[u] + graph[u][v];\r\n     }\r\n     printSolution(dist, V);\r\n}\r\nint main()\r\n{\r\n   int graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\r\n                      {4, 0, 8, 0, 0, 0, 0, 11, 0},\r\n                      {0, 8, 0, 7, 0, 4, 0, 0, 2},\r\n                      {0, 0, 7, 0, 9, 14, 0, 0, 0},\r\n                      {0, 0, 0, 9, 0, 10, 0, 0, 0},\r\n                      {0, 0, 4, 14, 10, 0, 2, 0, 0},\r\n                      {0, 0, 0, 0, 0, 2, 0, 1, 6},\r\n                      {8, 11, 0, 0, 0, 0, 1, 0, 7},\r\n                      {0, 0, 2, 0, 0, 0, 6, 7, 0}\r\n                     };\r\n    dijkstra(graph, 0);\r\n    return 0;\r\n}\r\n\r\n//1. line13 for(v = 0; v < V; v++){ no need for { after loop\r\n//2. line13 for(v = 0; v < V; v++){ v not declared \r\n//3. ln16 return min_index }... ; missing \r\n//4. ln21 space for i++\r\n//5. ln10 splSet instead of sptSet\r\n//6. ln52 , after } not needed\r\n//7. ln37 extra ) at end\r\n\r\n', ' ', 'Vertex   Distance from Source\n0		 0\n1		 4\n2		 12\n3		 19\n4		 21\n5		 11\n6		 9\n7		 8\n8		 14\n'),
('1b', 4, '#include<bits/stdc++.h>\r\nusing namespace std;\r\n \r\n// A function to generate odd sized magic squares\r\nvoid generateSquare(int n)\r\n{\r\n    int magicSquare[n][n];\r\n \r\n    // set all slots as 0\r\n    memset(magicSquare, 0, sizeof(magicSquare));\r\n \r\n    // Initialize position for 1\r\n    int i = n/2;\r\n    int j = n-1;\r\n \r\n    // One by one put all values in magic square\r\n    for (int num=1; num <= n*n; )\r\n    {\r\n        if (i==-1 && j==n) //3rd condition\r\n        {\r\n            j = n-2;\r\n            i = 0;\r\n        }\r\n        else\r\n        {\r\n            //1st condition helper if next number goes to out of square''s right side\r\n            if (j == n)\r\n                j = 0;\r\n            //1st condition helper if next number is goes to out of square''s upper side\r\n            if (i < 0)\r\n                i=n-1;\r\n        }\r\n        if (magicSquare[i][j]) //2nd condition\r\n        {\r\n            j -= 2;\r\n            i++;\r\n            continue;\r\n        }\r\n        else\r\n            magicSquare[i][j] = num++; //set number\r\n \r\n        j++;  i--; //1st condition\r\n    }\r\n \r\n \r\n    // print magic square\r\n    cout<<"The Magic Square for n="<<n<<":\nSum of each row or column :"<< n*(n*n+1)/2<<endl;\r\n    for(i=0; i<n; i++)\r\n    {\r\n        for(j=0; j<n; j++)\r\n            cout<< magicSquare[i][j]<<" ";\r\n        cout<<endl;\r\n    }\r\n}\r\n \r\n// Driver program to test above function\r\nint main()\r\n{\r\n    int n ;\r\n    cin>>n; // Works only when n is odd\r\n    generateSquare (n);\r\n    return 0;\r\n}\r\n\r\n\r\n//1. header files\r\n//2.  int magicSquare[][n];\r\n//3. j = n-2:i = 0;\r\n//4. if(j = = n) on line14\r\n', '7\r\n', 'The Magic Square for n=7:\r\nSum of each row or column :175\r\n20 12 4 45 37 29 28 \r\n11 3 44 36 35 27 19 \r\n2 43 42 34 26 18 10 \r\n49 41 33 25 17 9 1 \r\n40 32 24 16 8 7 48 \r\n31 23 15 14 6 47 39 \r\n22 21 13 5 46 38 30 \r\n'),
('1b', 5, '//Given two integers n and m, find all the stepping numbers in range [n, m]. A number is called stepping number if all adjacent digits have an absolute difference of 1. 321 is a Stepping Number while 421 is not.\r\n\r\n\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\nbool isStepNum(int n)\r\n{\r\n    int prevDigit = -1;\r\n    while (n)\r\n    {\r\n        int curDigit = n % 10;\r\n        if (prevDigit == -1)\r\n            prevDigit = curDigit;\r\n        else\r\n        {\r\n            if (abs(prevDigit - curDigit) != 1)\r\n                 return false;\r\n        }\r\n        prevDigit = curDigit;\r\n        n /= 10;\r\n    }\r\n    return true;\r\n}\r\nvoid displaySteppingNumbers(int n, int m)\r\n{\r\n    for (int i=n; i<=m; i++)\r\n        if (isStepNum(i))\r\n            cout << i << " ";\r\n}\r\nint main()\r\n{\r\n    int n , m ;\r\n    cin>>n>>m;\r\n    displaySteppingNumbers(n, m);\r\n    return 0;\r\n}\r\n//1. fn prototype\r\n//2. n/=10\r\n//3. ln16 two ((\r\n//4. spell mistake in isStepNUm\r\n//5. argument type not declared\r\n', '0\r\n21\r\n', '0 1 2 3 4 5 6 7 8 9 10 12 21\r\n'),
('2a', 1, '//program to print factorial of a given no...easy\n\n#include<stdio.h>\nvoid fact(int*);\n\nint main()\n{\n    int i;\n    scanf("%d",&i);\n    fact(&i);\n    printf("%d\n", i);\n    return 0;\n}\nvoid fact(int *j)\n{\n    static int s=1;\n    if(*j!=0)\n    {\n        s = s**j;\n        (*j)--;\n        fact(j);\n        *j=s;\n    }\n}\n\n//1. & missing in fn call ln10\n//2. s***j \n//3. ln20 () missing\n//4. &not necessary in ln21\n//5. ln21 ln 22 interchanged *j=s should be last\n//6. s declared 0\n//7. * missing ln17 *j!=0\n//8. fn prototype doesnt have int*', '5', '120'),
('2a', 2, '/* C/C++ program for memoized version for nth Fibonacci number */\r\n#include<stdio.h>\r\n#define NIL -1\r\n#define MAX 100\r\n \r\nint lookup[MAX];\r\n \r\n/* Function to initialize NIL values in lookup table */\r\nvoid _initialize()\r\n{\r\n  int i;\r\n  for (i = 0; i < MAX; i++)\r\n    lookup[i] = NIL;\r\n}\r\n \r\n/* function for nth Fibonacci number */\r\nint fib(int n)\r\n{\r\n   if (lookup[n] == NIL)\r\n   {\r\n      if (n <= 1)\r\n         lookup[n] = n;\r\n      else\r\n         lookup[n] = fib(n-1) + fib(n-2);\r\n   }\r\n \r\n   return lookup[n];\r\n}\r\n \r\nint main ()\r\n{\r\n  int n;\r\n  scanf("%d",&n);\r\n  _initialize();\r\n  printf("Fibonacci number is %d ", fib(n));\r\n  return 0;\r\n}\r\n\r\n\r\n\r\n\r\n// 1. fib(n-1) + fib(n) instead of fib(n-1) + fib(n-2)\r\n// 2. i-- in initialise()\r\n// 3. != instead of ==\r\n// 4. n<1 instead of n<=1\r\n// 5. returning n+1 instead of n\r\n', '9', 'Fibonacci number is 34 '),
('2a', 3, '//There are 2 sorted arrays A and B of size n each. \r\n//Write an algorithm to find the median of the array obtained after merging the above 2 arrays(i.e. array of length 2n)\r\n#include <stdio.h>\r\n \r\nint getMedian(int ar1[], int ar2[], int n)\r\n{\r\n    int i = 0;  \r\n    int j = 0; \r\n    int count;\r\n    int m1 = -1, m2 = -1;\r\n \r\n    for (count = 0; count <= n; count++)\r\n    {\r\n        if (i == n)\r\n        {\r\n            m1 = m2;\r\n            m2 = ar2[0];\r\n            break;\r\n        }\r\n        else if (j == n)\r\n        {\r\n            m1 = m2;\r\n            m2 = ar1[0];\r\n            break;\r\n        }\r\n \r\n        if (ar1[i] < ar2[j])\r\n        {\r\n            m1 = m2;\r\n            m2 = ar1[i];\r\n            i++;\r\n        }\r\n        else\r\n        {\r\n            m1 = m2;  \r\n            m2 = ar2[j];\r\n            j++;\r\n        }\r\n    }\r\n \r\n    return (m1 + m2)/2;\r\n}\r\n\r\nint main()\r\n{\r\n    int n1,n2,ar1[100],ar2[100];\r\n    int i;\r\n    scanf("%d",&n1);\r\n    for (i = 0; i < n1; ++i)\r\n    {\r\n        scanf("%d",&ar1[i]);\r\n    }\r\n    scanf("%d",&n2);\r\n    for (i = 0; i < n2; ++i)\r\n    {\r\n        scanf("%d",&ar2[i]);\r\n    }\r\n\r\n    if (n1 == n2)\r\n        printf("Median is %d", getMedian(ar1, ar2, n1));\r\n    else\r\n        printf("Doesn''t work for arrays of unequal size");\r\n    getchar();\r\n    return 0;\r\n}\r\n\r\n\r\n// 1. count<=2n instead of count<=n\r\n// 2. i!=n\r\n// 3. j!=n\r\n// 4. i++ intead of j++\r\n// 5. j++ instead of i++\r\n// 6. m1 and m2 interchanged in else\r\n\r\n\r\n// define a main() fn', '5\r\n1 12 15 26 38\r\n5\r\n2 13 17 30 45', 'Median is 16'),
('2a', 4, '//The expected output of the following C program is to print the elements in the array. But when actually run, it doesn''t do so.\r\n\r\n #include<stdio.h>\r\n\r\n  #define TOTAL_ELEMENTS (sizeof(array) / sizeof(array[0]))\r\n  int array[] = {23,34,12,17,204,99,16};\r\n\r\n  int main()\r\n  {\r\n       int d;\r\n\r\n      for(d=0;d <= (TOTAL_ELEMENTS-1 );d++)\r\n          printf("%d\n",array[d]);\r\n\r\n      return 0;\r\n  }\r\n//Find out what''s going wrong.', '0', '23\r\n34\r\n12\r\n17\r\n204\r\n99\r\n16\r\n'),
('2b', 1, '//program to print factorial of a given no...easy\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\nvoid fact(int*);\r\n\r\nint main()\r\n{\r\n    int i;\r\n    cin>>i;\r\n    fact(&i);\r\n    cout<<i<<endl;\r\n    return 0;\r\n}\r\nvoid fact(int *j)\r\n{\r\n    static int s=1;\r\n    if(*j!=0)\r\n    {\r\n        s = s**j;\r\n        (*j)--;\r\n        fact(j);\r\n        *j=s;\r\n    }\r\n}\r\n\r\n//1. & missing in fn call ln10\r\n//2. s***j \r\n//3. ln20 () missing\r\n//4. &not necessary in ln21\r\n//5. ln21 ln 22 interchanged *j=s should be last\r\n//6. s declared 0\r\n//7. * missing ln17 *j!=0\r\n//8. fn prototype doesnt have int*', '5', '120'),
('2b', 2, '/* C/C++ program for memoized version for nth Fibonacci number */\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define NIL -1\r\n#define MAX 100\r\n \r\nint lookup[MAX];\r\n \r\n/* Function to initialize NIL values in lookup table */\r\nvoid _initialize()\r\n{\r\n  int i;\r\n  for (i = 0; i < MAX; i++)\r\n    lookup[i] = NIL;\r\n}\r\n \r\n/* function for nth Fibonacci number */\r\nint fib(int n)\r\n{\r\n   if (lookup[n] == NIL)\r\n   {\r\n      if (n <= 1)\r\n         lookup[n] = n;\r\n      else\r\n         lookup[n] = fib(n-1) + fib(n-2);\r\n   }\r\n \r\n   return lookup[n];\r\n}\r\n \r\nint main ()\r\n{\r\n  int n;\r\n  cin>>n;\r\n  _initialize();\r\n  cout<<"Fibonacci number is "<<fib(n);\r\n  return 0;\r\n}\r\n\r\n\r\n\r\n\r\n// 1. fib(n-1) + fib(n) instead of fib(n-1) + fib(n-2)\r\n// 2. i-- in initialise()\r\n// 3. != instead of ==\r\n// 4. n<1 instead of n<=1\r\n// 5. returning n+1 instead of n\r\n', '9', 'Fibonacci number is 34'),
('2b', 3, '//There are 2 sorted arrays A and B of size n each. \r\n//Write an algorithm to find the median of the array obtained after merging the above 2 arrays(i.e. array of length 2n)\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint getMedian(int ar1[], int ar2[], int n)\r\n{\r\n    int i = 0;  \r\n    int j = 0; \r\n    int count;\r\n    int m1 = -1, m2 = -1;\r\n \r\n    for (count = 0; count <= n; count++)\r\n    {\r\n        if (i == n)\r\n        {\r\n            m1 = m2;\r\n            m2 = ar2[0];\r\n            break;\r\n        }\r\n        else if (j == n)\r\n        {\r\n            m1 = m2;\r\n            m2 = ar1[0];\r\n            break;\r\n        }\r\n \r\n        if (ar1[i] < ar2[j])\r\n        {\r\n            m1 = m2;\r\n            m2 = ar1[i];\r\n            i++;\r\n        }\r\n        else\r\n        {\r\n            m1 = m2;  \r\n            m2 = ar2[j];\r\n            j++;\r\n        }\r\n    }\r\n \r\n    return (m1 + m2)/2;\r\n}\r\n\r\nint main()\r\n{\r\n    int n1,n2,ar1[100],ar2[100];\r\n    int i;\r\n    cin>>n1;\r\n    for (i = 0; i < n1; ++i)\r\n    {\r\n        cin>>ar1[i];\r\n    }\r\n    cin>>n2;\r\n    for (i = 0; i < n2; ++i)\r\n    {\r\n        cin>>ar2[i];\r\n    }\r\n\r\n    if (n1 == n2)\r\n        printf("Median is %d", getMedian(ar1, ar2, n1));\r\n    else\r\n        printf("Doesn''t work for arrays of unequal size");\r\n    getchar();\r\n    return 0;\r\n}\r\n\r\n// 1. count<=2n instead of count<=n\r\n// 2. i!=n\r\n// 3. j!=n\r\n// 4. i++ intead of j++\r\n// 5. j++ instead of i++\r\n// 6. m1 and m2 interchanged in else\r\n\r\n// define a main() fn', '5\r\n1 12 15 26 38\r\n5\r\n2 13 17 30 45', 'Median is 16'),
('2b', 4, '//The expected output of the following C program is to print the elements in the array. But when actually run, it doesn''t do so.\r\n\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n  #define TOTAL_ELEMENTS (sizeof(array) / sizeof(array[0]))\r\n  int array[] = {23,34,12,17,204,99,16};\r\n\r\n  int main()\r\n  {\r\n      int d;\r\n\r\n      for(d=0;d <= (TOTAL_ELEMENTS-1);d++)\r\n          cout<<array[d]<<endl;\r\n\r\n      return 0;\r\n  }\r\n\r\n//Find out what''s going wrong.', '0', '23\r\n34\r\n12\r\n17\r\n204\r\n99\r\n16\r\n'),
('3a', 1, '//Divisibility by 7 can be checked by a recursive method.\r\n// A number of the form 10a + b is divisible by 7 if and only if a  2b is divisible by 7.\r\n\r\n// A Program to check whether a number is divisible by 7\r\n#include <stdio.h>\r\n \r\nint isDivisibleBy7( int num )\r\n{\r\n    // If number is negative, make it positive\r\n    if( num < 0 )\r\n        return isDivisibleBy7( -num );\r\n \r\n    // Base cases\r\n    if( num == 0 || num == 7 )\r\n        return 1;\r\n    if( num < 10 )\r\n        return 0;\r\n \r\n    // Recur for ( num / 10 - 2 * num % 10 ) \r\n    return isDivisibleBy7( num / 10 - 2 * ( num - num / 10 * 10 ) );\r\n}\r\n \r\n// Driver program to test above function\r\nint main()\r\n{\r\n    int num;\r\n	scanf("%d",&num);\r\n	if( isDivisibleBy7(num ) )\r\n        printf( "Divisible" );\r\n    else\r\n        printf( "Not Divisible" );\r\n    return 0;\r\n}\r\n\r\n\r\n//1. ln11 -- instead -\r\n//2. ln14 == || == spaces in btw them\r\n//3. ln16 >10 instead of <10\r\n//4. ln20 return operators full jumbled\r\n//5. ln28 isnotDivisibleBy7 not defined\r\n//6. ln26 enum declared\r\n//7. no & in scanf\r\n', '14\r\n', 'Divisible'),
('3a', 2, '#include <stdio.h>\r\n#include <stdlib.h>\r\n \r\n/* structure of a linked list node */\r\nstruct node\r\n{\r\n    int data;\r\n    struct node *next;\r\n};\r\n \r\nvoid deleteNode(struct node *head, struct node *n)\r\n{\r\n    // When node to be deleted is head node\r\n    if(head == n)\r\n    {\r\n        if(head->next == NULL)\r\n        {\r\n            printf("There is only one node. The list can''t be made empty ");\r\n            return;\r\n        }\r\n \r\n        /* Copy the data of next node to head */\r\n        head->data = head->next->data;\r\n \r\n        // store address of next node\r\n        n = head->next;\r\n \r\n        // Remove the link of next node\r\n        head->next = head->next->next;\r\n \r\n        // free memory\r\n        free(n);\r\n \r\n        return;\r\n    }\r\n \r\n \r\n    // When not first node, follow the normal deletion process\r\n \r\n    // find the previous node\r\n    struct node *prev = head;\r\n    while(prev->next != NULL && prev->next != n)\r\n        prev = prev->next;\r\n \r\n    // Check if node really exists in Linked List\r\n    if(prev->next == NULL)\r\n    {\r\n        printf("\n Given node is not present in Linked List");\r\n        return;\r\n    }\r\n \r\n    // Remove node from Linked List\r\n    prev->next = prev->next->next;\r\n \r\n    // Free memory\r\n    free(n);\r\n \r\n    return; \r\n}\r\n \r\n/* Utility function to insert a node at the begining */\r\nvoid push(struct node **head_ref, int new_data)\r\n{\r\n    struct node *new_node =\r\n        (struct node *)malloc(sizeof(struct node));\r\n    new_node->data = new_data;\r\n    new_node->next = *head_ref;\r\n    *head_ref = new_node;\r\n}\r\n \r\n/* Utility function to print a linked list */\r\nvoid printList(struct node *head)\r\n{\r\n    while(head!=NULL)\r\n    {\r\n        printf("%d ",head->data);\r\n        head=head->next;\r\n    }\r\n    printf("\n");\r\n}\r\n \r\n/* Driver program to test above functions */\r\nint main()\r\n{\r\n    struct node *head = NULL;\r\n \r\n    /* Create following linked list\r\n      12->15->10->11->5->6->2->3 */\r\n    push(&head,3);\r\n    push(&head,2);\r\n    push(&head,6);\r\n    push(&head,5);\r\n    push(&head,11);\r\n    push(&head,10);\r\n    push(&head,15);\r\n    push(&head,12);\r\n \r\n    printf("Given Linked List: ");\r\n    printList(head);\r\n \r\n    /* Let us delete the node with value 10 */\r\n    printf("\nDeleting node %d: ", head->next->next->data);\r\n    deleteNode(head, head->next->next);\r\n \r\n    printf("\nModified Linked List: ");\r\n    printList(head);\r\n \r\n    /* Let us delete the the first node */\r\n    printf("\nDeleting first node ");\r\n    deleteNode(head, head);\r\n \r\n    printf("\nModified Linked List: ");\r\n    printList(head);\r\n \r\n \r\n    return 0;\r\n}\r\n\r\n\r\n// line 8: void deleteNode(struct node *head,struct node *n)\r\n// line 9: head == n\r\n// line 10: if(head->next == NULL)\r\n// line 20: struct node *prev\r\n// line 14: head->data = head->next->data;\r\n// line 16: head->next = head->next->next;\r\n// line 33: void push(struct node **head_ref, int new_data)\r\n// line 35: struct node *new_node = (struct node *)malloc(sizeof(struct node));\r\n// line 27:  prev->next = prev->next->next;\r\n// line 46: printf("%d ",head->data);\r\n// line 53:  struct node *head = NULL;\r\n        ', '0', 'Given Linked List: 12 15 10 11 5 6 2 3 \r\n\r\nDeleting node 10: \r\nModified Linked List: 12 15 11 5 6 2 3 \r\n\r\nDeleting first node \r\nModified Linked List: 15 11 5 6 2 3 '),
('3a', 3, '/*\r\nGiven an array arr[] of size n>4, \r\nthe task is to check whether the given array can be arranged in the form of Left or Right positioned array?\r\nLeft or Right Positioned Array means \r\neach element in the array is equal to the number of elements to its left or number of elements to its right.\r\n\r\nExamples:\r\n\r\nInput  : arr[] = {1, 3, 3, 2}\r\nOutput : "YES"  \r\nThis array has one such arrangement {3, 1, 2, 3}. \r\nIn this arrangement, first element ''3'' indicates \r\nthat three numbers are after it, the 2nd element \r\n''1'' indicates that one number is before it, the \r\n3rd element ''2'' indicates that two elements are \r\nbefore it.\r\n\r\nInput : arr[] = {1, 6, 5, 4, 3, 2, 1}\r\nOutput: "NO"\r\n// No such arrangement is possible\r\n\r\nInput : arr[] = {2, 0, 1, 3}\r\nOutput: "YES"\r\n// Possible arrangement is {0, 1, 2, 3}\r\n\r\nInput : arr[] = {2, 1, 5, 2, 1, 5}\r\nOutput: "YES"\r\n// Possible arrangement is {5, 1, 2, 2, 1, 5}\r\n*/\r\n#include<stdio.h>\r\nint leftRight(int arr[],int n)\r\n{\r\n    int visited[n] ;\r\n    for (int i=0; i<n; i++)\r\n        visited[i]=0;\r\n    for (int i=0; i<n; i++)\r\n    {\r\n        if (arr[i] < n)\r\n        {\r\n            if (visited[arr[i]] == 0)\r\n                visited[arr[i]] = 1;\r\n            else\r\n                visited[n-arr[i]-1] = 1;\r\n        }\r\n    }\r\n    for (int i=0; i<n; i++)\r\n        if (visited[i] == 0)\r\n            return 0;\r\n \r\n    return 1;\r\n}\r\n int main()\r\n{\r\n    int arr[] = {2, 1, 5, 2, 1, 5};\r\n    int n = sizeof(arr)/sizeof(arr[0]);\r\n    if (leftRight(arr, n) == 1)\r\n        printf("YES");\r\n    else\r\n        printf("NO");\r\n    return 0;\r\n}\r\n\r\n//1. void main()\r\n//2. visited[arr[i]] !=0 instead of ==0\r\n//3. visited[i] = 1 instead of visited[arr[i]] = 1;\r\n//4. visited[n-arr[i]+1] = 1 instead of visited[n-arr[i]-1] = 1;\r\n//5. if (visited[i] = = 0) instead of ==', '0', 'YES'),
('3b', 1, '//Divisibility by 7 can be checked by a recursive method.\r\n// A number of the form 10a + b is divisible by 7 if and only if a  2b is divisible by 7.\r\n\r\n// A Program to check whether a number is divisible by 7\r\n\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n  \r\nint isDivisibleBy7( int num )\r\n{\r\n    // If number is negative, make it positive\r\n    if( num < 0 )\r\n        return isDivisibleBy7( -num );\r\n \r\n    // Base cases\r\n    if( num == 0 || num == 7 )\r\n        return 1;\r\n    if( num < 10 )\r\n        return 0;\r\n \r\n    // Recur for ( num / 10 - 2 * num % 10 ) \r\n    return isDivisibleBy7( num / 10 - 2 * ( num - num / 10 * 10 ) );\r\n}\r\n \r\n// Driver program to test above function\r\nint main()\r\n{\r\n    int num;\r\n	scanf("%d",&num);\r\n	if( isDivisibleBy7(num ) )\r\n        cout<< "Divisible" ;\r\n    else\r\n        cout<< "Not Divisible" ;\r\n    return 0;\r\n}\r\n\r\n\r\n//1. ln11 -- instead -\r\n//2. ln14 == || == spaces in btw them\r\n//3. ln16 >10 instead of <10\r\n//4. ln20 return operators full jumbled\r\n//5. ln28 isnotDivisibleBy7 not defined\r\n//6. ln26 enum declared\r\n', '14\r\n', 'Divisible'),
('3b', 2, '#include <iostream>\r\n#include <stdlib.h>\r\n \r\nusing namespace std;\r\n\r\n/* structure of a linked list node */\r\nclass node\r\n{\r\n	public:\r\n	\r\n    int data;\r\n    node *next;\r\n};\r\n \r\nvoid deleteNode( node *head, node *n)\r\n{\r\n    // When node to be deleted is head node\r\n    if(head == n)\r\n    {\r\n        if(head->next == NULL)\r\n        {\r\n            cout << "There is only one node. The list can''t be made empty ";\r\n            return;\r\n        }\r\n \r\n        /* Copy the data of next node to head */\r\n        head->data = head->next->data;\r\n \r\n        // store address of next node\r\n        n = head->next;\r\n \r\n        // Remove the link of next node\r\n        head->next = head->next->next;\r\n \r\n        // free memory\r\n        free(n);\r\n \r\n        return;\r\n    }\r\n \r\n \r\n    // When not first node, follow the normal deletion process\r\n \r\n    // find the previous node\r\n    node *prev = head;\r\n    while(prev->next != NULL && prev->next != n)\r\n        prev = prev->next;\r\n \r\n    // Check if node really exists in Linked List\r\n    if(prev->next == NULL)\r\n    {\r\n        cout << "\n Given node is not present in Linked List";\r\n        return;\r\n    }\r\n \r\n    // Remove node from Linked List\r\n    prev->next = prev->next->next;\r\n \r\n    // Free memory\r\n    free(n);\r\n \r\n    return; \r\n}\r\n \r\n/* Utility function to insert a node at the begining */\r\nvoid push(struct node **head_ref, int new_data)\r\n{\r\n    node *new_node = new node;\r\n    new_node->data = new_data;\r\n    new_node->next = *head_ref;\r\n    *head_ref = new_node;\r\n}\r\n \r\n/* Utility function to print a linked list */\r\nvoid printList(struct node *head)\r\n{\r\n    while(head!=NULL)\r\n    {\r\n        cout << head->data;\r\n        head=head->next;\r\n    }\r\n    cout << "\n";\r\n}\r\n \r\n/* Driver program to test above functions */\r\nint main()\r\n{\r\n    node *head = NULL;\r\n \r\n    /* Create following linked list\r\n      12->15->10->11->5->6->2->3 */\r\n    push(&head,3);\r\n    push(&head,2);\r\n    push(&head,6);\r\n    push(&head,5);\r\n    push(&head,11);\r\n    push(&head,10);\r\n    push(&head,15);\r\n    push(&head,12);\r\n \r\n    cout << "Given Linked List: ";\r\n    printList(head);\r\n \r\n    /* Let us delete the node with value 10 */\r\n    cout << "\nDeleting node :" << head->next->next->data;\r\n    deleteNode(head, head->next->next);\r\n \r\n    cout << "\nModified Linked List: ";\r\n    printList(head);\r\n \r\n    /* Let us delete the the first node */\r\n    cout << "\nDeleting first node ";\r\n    deleteNode(head, head);\r\n \r\n    cout << "\nModified Linked List: ";\r\n    printList(head);\r\n \r\n    return 0;\r\n}\r\n\r\n// line 5: public:\r\n// line 11: head == n\r\n// line 12: if(head->next == NULL)\r\n// line 22: node *prev\r\n// line 16: head->data = head->next->data;\r\n// line 18: head->next = head->next->next;\r\n// line 35: void push(node **head_ref, int new_data)\r\n// line 29:  prev->next = prev->next->next;\r\n// line 48: cout << head->data;\r\n// line 55:  node *head = NULL;\r\n        ', '0', 'Given Linked List: 121510115623\n\nDeleting node :10\nModified Linked List: 1215115623\n\nDeleting first node \nModified Linked List: 15115623'),
('3b', 3, '/*\r\nGiven an array arr[] of size n>4, \r\nthe task is to check whether the given array can be arranged in the form of Left or Right positioned array?\r\nLeft or Right Positioned Array means \r\neach element in the array is equal to the number of elements to its left or number of elements to its right.\r\n\r\nExamples:\r\n\r\nInput  : arr[] = {1, 3, 3, 2}\r\nOutput : "YES"  \r\nThis array has one such arrangement {3, 1, 2, 3}. \r\nIn this arrangement, first element ''3'' indicates \r\nthat three numbers are after it, the 2nd element \r\n''1'' indicates that one number is before it, the \r\n3rd element ''2'' indicates that two elements are \r\nbefore it.\r\n\r\nInput : arr[] = {1, 6, 5, 4, 3, 2, 1}\r\nOutput: "NO"\r\n// No such arrangement is possible\r\n\r\nInput : arr[] = {2, 0, 1, 3}\r\nOutput: "YES"\r\n// Possible arrangement is {0, 1, 2, 3}\r\n\r\nInput : arr[] = {2, 1, 5, 2, 1, 5}\r\nOutput: "YES"\r\n// Possible arrangement is {5, 1, 2, 2, 1, 5}\r\n*/\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n bool leftRight(int arr[],int n)\r\n{\r\n    int visited[n] ;\r\n    for (int i=0; i<n; i++)\r\n    	visited[i]=0;\r\n    for (int i=0; i<n; i++)\r\n    {\r\n        if (arr[i] < n)\r\n        {\r\n            if (visited[arr[i]] == 0)\r\n                visited[arr[i]] = 1;\r\n            else\r\n                visited[n-arr[i]-1] = 1;\r\n        }\r\n    }\r\n    for (int i=0; i<n; i++)\r\n        if (visited[i] == 0)\r\n            return false;\r\n \r\n    return true;\r\n}\r\n int main()\r\n{\r\n    int arr[] = {2, 1, 5, 2, 1, 5};\r\n    int n = sizeof(arr)/sizeof(arr[0]);\r\n    if (leftRight(arr, n) == true)\r\n        cout << "YES";\r\n    else\r\n        cout << "NO";\r\n    return 0;\r\n}\r\n\r\n//1. void main()\r\n//2. visited[arr[i]] !=0 instead of ==0\r\n//3. visited[i] = 1 instead of visited[arr[i]] = 1;\r\n//4. visited[n-arr[i]+1] = 1 instead of visited[n-arr[i]-1] = 1;\r\n//5. if (visited[i] = = 0) instead of ==', '0', 'YES');

-- --------------------------------------------------------

--
-- Table structure for table `stages`
--

CREATE TABLE IF NOT EXISTS `stages` (
  `stageid` varchar(2) NOT NULL,
  `type` varchar(10) NOT NULL,
  `time` int(11) NOT NULL,
  `stageStart` int(2) NOT NULL,
  PRIMARY KEY (`stageid`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

--
-- Dumping data for table `stages`
--

INSERT INTO `stages` (`stageid`, `type`, `time`, `stageStart`) VALUES
('1a', 'syntax', 30, 0),
('1b', 'syntax', 30, 0),
('2a', 'logical', 30, 0),
('2b', 'logical', 30, 0),
('3a', 'obfuscated', 30, 1),
('3b', 'obfuscated', 30, 1);

-- --------------------------------------------------------

--
-- Table structure for table `submissions`
--

CREATE TABLE IF NOT EXISTS `submissions` (
  `teamname` varchar(30) NOT NULL,
  `stageid` varchar(4) NOT NULL,
  `questionid` tinyint(4) NOT NULL,
  `ans` longtext NOT NULL,
  `time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `changes` int(10) NOT NULL,
  `accept` int(10) NOT NULL DEFAULT '0',
  PRIMARY KEY (`teamname`,`stageid`,`questionid`),
  KEY `stageid` (`stageid`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

--
-- Dumping data for table `submissions`
--

INSERT INTO `submissions` (`teamname`, `stageid`, `questionid`, `ans`, `time`, `changes`, `accept`) VALUES
('12345678', '1a', 1, '#include <stdio.h>\n#include <stdlib.h>\n\nint max(int a[],int n)\n{\n  int max=0, i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];	\n	   }\n       }\n	   return(max);	\n}\n\nvoid bucket_sort(int a[],int n){\n  int bucket=max(a,n);\n  int b[1000],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[a[i]]+1;\n  	}	\n   	for(i=0;i<=bucket;i++)	\n       {\n	      for(k=b[i];k>0;--k)\n                       {\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[1000];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]);\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', '2016-10-22 07:34:24', 10, 1),
('12345678', '1a', 2, '#include<stdio.h>\n\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    temp = b;\n    b = a;\n    a = c;\n    c = temp;\n}\n\nint main()\n{\n    int a, b, c;\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n\n    printf("Value before swapping:");\n    printf("a = %d, b = %d, c = %d", a,b,c);\n\n    cyclicSwap(&a, &b, &c);\n\n    printf("Value after swapping:\\n");\n    printf("a = %d, b = %d, c = %d", a, b, c);\n\n    return 0;\n}\n', '2016-10-22 07:49:00', 0, 0),
('12345678', '2a', 1, '#include<stdio.h>\nvoid fact(int);\n\nint main()\n{\n    int i;\n    scanf("%d",&i);\n    fact(&i);\n    printf("%d\\n", i);\n    return 0;\n}\nvoid fact(int *j)\n{\n    static int s=1;\n    if(j!=1)\n    {\n        s *= *j;\n        *j--;\n        fact(j);\n        *j=s;\n    }\n}', '2016-10-22 11:39:51', 0, 0),
('12345678', '2a', 2, '#include<stdio.h>\n#define NIL -1\n#define MAX 100\nint lookup[MAX];\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n  int i;\n  for (i = 0; i < MAX; i++)\n    lookup[i] = NIL;\n}\n/* function for nth Fibonacci number */\nint fib(int n)\n{\n   if (lookup[n] == NIL)\n   {\n      if (n <= 1)\n         lookup[n] = n;\n      else\n         lookup[n] = fib(n-1) + fib(n-2);\n   }\n   return lookup[n];\n}\nint main ()\n{\n  int n;\n  scanf("%d",&n);\n  _initialize();\n  printf("Fibonacci number is %d ", fib(n));\n  return 0;\n}', '2016-10-22 11:33:38', 5, 1),
('12345678', '2a', 4, ' #include<stdio.h>\n\n  #define TOTAL_ELEMENTS 7\n  int array[] = {23,34,12,17,204,99,16};\n\n  int main()\n  {\n      int d;\n\n      for(d=-1;d <= (TOTAL_ELEMENTS-2);d++)\n          printf("%d\\n",array[d+1]);\n\n      return 0;\n  }\n', '2016-10-22 11:19:53', 1, 1),
('Aces95', '1b', 1, '#include<bits/stdc++.h>\n#include<algorithms.h>\n#include<vectors.h>\n#include<iostream.h>\nusing namespace std;\nvoid bucketSort(arr[], n)\n{\n    vector<float> b[n];\n    for (int i=0; i<n; i++){\n    int bi = n*arr[i]; \n    b[bi]-push_back(arr[i]);\n    } for (int i=0; i<n; i++)\n       sort(b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++)for (int j = 0; j < b[i].size(); j++)\n          arr[index++] = b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ";\n    return 0;\n}\n', '2016-10-22 07:59:59', 0, 0),
('Aces95', '1b', 2, '#include<bits/stdc++.h>\n#include<iostream.h>\nusing namespace std;\n\nint main()\n{\n    int a, b, c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(&a, &b, &c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    // swapping in cyclic order\n    *temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = *temp;\n}', '2016-10-22 08:00:18', 0, 0),
('Aces95', '1b', 3, '\n#include<bits/stdc++.h>\nusing namespace std;\n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], bool splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(int v = 0; v < V; v++){\nif (sptSet[v] == false && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn (min_index); }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\ncout<<"Vertex   Distance from Source\\n";\nfor (int i = 0; i < V; i++)\ncout<<i<<"		 "<<dist[i]<<"\\n";\n// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nbool sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = false;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = true;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v])\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0}\n};dijkstra(graph, 0);\nreturn 0;}', '2016-10-22 07:56:47', 0, 0),
('Aces95', '1b', 4, '#inlcude<bits/stdc++.h>\nusing namespace std;\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2, j = n-1;\nfor (int num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2;i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    cout<<"The Magic Square for n="<<n<<":\\nSum of each row or column :"<<n*(n*n+1)/2<<endl;\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            cout<< magicSquare[i][j]<<" ";\n        cout<<endl;\n    }\n}\n \nint main()\n{\n    int n;\n    cin>>n;\n    generateSquare(n);\n    return 0;\n}\n', '2016-10-22 07:56:50', 0, 0),
('Aces95', '1b', 5, '#include<bits/stdc++.h>\n#include<math.h>\n#include<iostream.h>\nusing namespace std;\n\nint main()\n{\n    int n , m;\n    cin>>n>>m;\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nbool isStepNum(int n)\n{\n    int prevDigit = -1;\n    while(n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return False;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return True;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n        if (isStepNum(i))\n            cout << i <<" ";\n}', '2016-10-22 08:03:17', 0, 0),
('anns', '1a', 1, '#include <stdio.h>\n#include <stdlib.h>\n\nint max(int a[] ,int n)\n{\n  int max=0,i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int a[] ,int n)\n{\n  int bucket;\n bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[[a[i]+1];\n  	}	\n   	for(i=0;i< =bucket;i++)	\n          {\n	      for(k=b[i];k>0;--k)\n                  {\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main()\n{\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]):\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', '2016-10-22 07:29:21', 0, 0),
('anns', '1a', 2, '#include<stdio.h>\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c =temp;\n}\n\nint main()\n{\n    int a ,b, c;\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n\n    printf("Value before swapping:");\n    printf("a = %d ,b = %d, c = %d",a,b,c);\n\n    cyclicSwap(&a, &b, &c);\n\n    printf("Value after swapping:");\n    printf("a = %d ,b = %d ,c = %d",a, b, c);\n\n    return 0;\n}\n', '2016-10-22 07:46:31', 0, 0),
('anns', '2a', 1, '#include<stdio.h>\n static int s=0;\nint fact(int);\nint main()\n{\n    int i;\n    scanf("%d",&i);\n    fact(&i);\n    printf("%d\\n", i);\n    return 0;\n}\nint fact(int *j)\n{\n    if(j!=1)\n    {\n        s = s*(*j);\n        *j--;\n         fact(&j);\n     }\n  return s;\n}', '2016-10-22 11:45:41', 0, 0),
('anns', '2a', 2, '#include<stdio.h>\n#define NIL -1\n#define MAX 100\nint lookup[MAX];\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n  int i;\n  for (i = 0; i < MAX; i++)\n    lookup[i] = NIL;\n}\n/* function for nth Fibonacci number */\nint fib(int n)\n{\n   if (lookup[n] == NIL)\n   {\n      if (n < 1)\n         lookup[n] = n;\n      else\n         lookup[n] = fib(n) + fib(n-1);\n   }\n   return lookup[n+1];\n}\nint main ()\n{\n  int n;\n  scanf("%d",&n);\n  _initialize();\n  printf("Fibonacci number is %d ", fib(n));\n  return 0;\n}', '2016-10-22 11:45:44', 0, 0),
('anns', '2a', 3, '#include <stdio.h>\n \nint getMedian(int ar1[], int ar2[], int n)\n{\n    int i = 0;  \n    int j = 0; \n    int count;\n    int m1 = -1, m2 = -1;\n \n    for (count = 0; count < 2*n; count++)\n    {\n        if (i != n)\n        {\n            m1 = m2;\n            m2 = ar2[0];\n            break;\n        }\n        else if (j != n)\n        {\n            m1 = m2;\n            m2 = ar1[0];\n            break;\n        }\n \n        if (ar1[i] < ar2[j])\n        {\n            m1 = m2;\n            m2 = ar1[i];\n            j++;\n        }\n        else\n        {\n            m2 = m1;  \n            m1 = ar2[j];\n            i++;\n        }\n    }\n    return (m1 + m2)/2;\n}\nint main()\n{\n    int n1,n2,ar1[100],ar2[100];\n    int i;\n    scanf("%d",&n1);\n    for (i = 0; i < n1; i++)\n    {\n        scanf("%d",&ar1[i]);\n    }\n    scanf("%d",&n2);\n    for (i = 0; i < n2; i++)\n    {\n        scanf("%d",&ar2[i]);\n    }\n\n    if (n1 == n2)\n        printf("Median is %d", getMedian(ar1, ar2, n1));\n    else\n        printf("Doesn''t work for arrays of unequal size");\n    getchar();\n    return 0;\n}', '2016-10-22 11:45:47', 0, 0),
('anns', '2a', 4, ' #include<stdio.h>\n\n  #define TOTAL_ELEMENTS (sizeof(array) / sizeof(array[0]))\n  int array[] = {23,34,12,17,204,99,16};\n\n  int main()\n  {\n      int d;\n\n      for(d=-1;d <= (TOTAL_ELEMENTS-2);d++)\n          printf("%d\\n",array[d+1]);\n\n      return 0;\n  }\n', '2016-10-22 11:45:53', 0, 0),
('Anonymous', '1a', 1, '#include <stdio.h>\n#include <stdlib.h>\n\nint max(int a[],int n)\n{\n  int max=0,i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int a[],int n){\n  int bucket=max(a,n);\n  int b[10000],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[a[i]]+1;\n  	}	\n   	for(i=0;i<=bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n,a[10000];\nscanf("%d",&n);\n\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]);\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', '2016-10-22 07:21:58', 9, 1),
('Anonymous', '1a', 2, '#include<stdio.h>\n#include<stdlib.h>\nvoid cyclicSwap(int *,int *,int *);\n\nint main()\n{\n    int a, b, c;\n\n    pritnf("Enter a, b and c respectively: ");\n    scanf("%d%d%d",&a,&b,&c);\n\n    printf("Value before swapping:");\n    printf("a = %d b = %d c = %d",a,b,c);\n\n    cyclicSwap(&a, &b, &c);\n\n    printf("Value after swapping:");\n    printf("a = %d b = %d c = %d",a, b, c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = temp;\n}', '2016-10-22 07:39:09', 0, 0),
('Anonymous', '1a', 5, '#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\nint isStepNum(int);\nvoid displaySteppingNumbers(int ,int);\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(int n)\n{\n    int prevDigit = -1;\n    int curDigit;\n    while (n)\n    {\n        curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n \\= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{   int i;\n    for (i=n; i<=m; i++)\n        {if (isStepNum(i))\n            printf("%d ",i);}\n}', '2016-10-22 07:38:28', 0, 0),
('Anonymous', '2a', 1, '#include<stdio.h>\nvoid fact(int *);\n\nint main()\n{\n    int i;\n    scanf("%d",&i);\n    fact(&i);\n    printf("%d\\n", i);\n    return 0;\n}\nvoid fact(int *j)\n{\n    static int s=1;\n    if(*j!=1)\n    {\n        s = s*(*j);\n        (*j)--;\n        fact(j);\n    }\n   else\n    { *j=s;\n    }\n}', '2016-10-22 11:26:50', 4, 1),
('Anonymous', '2a', 2, '#include<stdio.h>\n#define NIL -1\n#define MAX 100\nint lookup[MAX];\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n  int i;\n  for (i = 0; i < MAX; i++)\n    lookup[i] = NIL;\n}\n/* function for nth Fibonacci number */\nint fib(int n)\n{\n   if (lookup[n] == NIL)\n   {\n      if (n <= 1)\n         lookup[n] = n;\n      else\n         lookup[n] = fib(n-1) + fib(n-2);\n   }\n   return lookup[n];\n}\nint main ()\n{\n  int n;\n  scanf("%d",&n);\n  _initialize();\n  printf("Fibonacci number is %d ", fib(n));\n  return 0;\n}', '2016-10-22 11:35:21', 5, 1),
('Anonymous', '2a', 3, '#include <stdio.h>\n \nint getMedian(int ar1[], int ar2[], int n)\n{\n    int i = 0;  \n    int j = 0; \n    int count;\n    int m1 = -1, m2 = -1;\n \n    for (count = 0; count < 2*n; count++)\n    {\n        if (i == n)\n        {\n            m1 = m2;\n            m2 = ar2[0];\n            break;\n        }\n        else if (j == n)\n        {\n            m1 = m2;\n            m2 = ar1[0];\n            break;\n        }\n \n        if (ar1[i] > ar2[j])\n        {\n            m1 = m2;\n            m2 = ar2[j];\n            j++;\n        }\n        else\n        {\n            m2 = m1;  \n            m1 = ar1[i];\n            i++;\n        }\n    }\n \n    return (m1 + m2)/2;\n}\nint main()\n{\n    int n1,n2,ar1[100],ar2[100];\n    int i;\n    scanf("%d",&n1);\n    for (i = 0; i < n1; ++i)\n    {\n        scanf("%d",&ar1[i]);\n    }\n    scanf("%d",&n2);\n    for (i = 0; i < n2; ++i)\n    {\n        scanf("%d",&ar2[i]);\n    }\n\n    if (n1 == n2)\n        printf("Median is %d", getMedian(ar1, ar2, n1));\n    else\n        printf("Doesn''t work for arrays of unequal size");\n    getchar();\n    return 0;\n}', '2016-10-22 11:45:43', 0, 0),
('Anonymous', '2a', 4, ' #include<stdio.h>\n\n\n\n  int main()\n  {   int array[] = {23,34,12,17,204,99,16};\n      int d;\n      int TOTAL_ELEMENTS =(sizeof(array) / sizeof(array[0]));\n\n      for(d=-1;d <= (TOTAL_ELEMENTS-2);d++)\n          printf("%d\\n",array[d+1]);\n\n      return 0;\n  }\n', '2016-10-22 11:24:15', 3, 1),
('Anonymous', '3a', 1, '#include<stdio.h> \n#include<math.h>\n#include<stdlib.h>\n\nint isDivisibleBy7( int num ) {\nif( num < 0 )\n  return isDivisibleBy7( abs(num) );\nif( num == 0 || num == 7 )\n    return 1;\nif( num > 10 )\n   return isDivisibleBy7( (num/10) - (2*(num%10)) );\nreturn 0;\n}\n\nint main() {\n   int num;\n   scanf("%d",&num);\n    if( isDivisibleBy7(num) )\n        printf( "Divisible" );\n     else\n        printf( "Not Divisible" );\n     return 0;\n}', '2016-10-22 12:34:19', 6, 1),
('Anonymous', '3a', 2, '#include <stdio.h>\n#include <stdlib.h>\nstruct node{\n    int data;\n    struct node *next;\n};\n \nvoid deleteNode(struct node *head,struct node *n) {\n    if(head == n){\n        if(head->next->next== NULL) {\n            printf("There is only one node.");\n            free(n);\n            return;}\n        head->data = head->next->data;\n        n = head->next;\n        head->next = head-next->next;\n        free(n);	// free memory\n        return;\n    }\n    struct node *prev = head;\n    while(prev->next != NULL || prev->next != n)\n        prev = prev->next;\n    if(prev->next == NULL){\n        printf("\\n Given node is not present in Linked List");\n        return;\n    }\n     prev->next = n->next;\n    free(n);\n    return; \n}\n \n/* Utility function to insert a node at the begining */\nvoid push(struct node *head_ref, int new_data)\n{\n    struct node *new_node = (struct node *)malloc(sizeof(struct node));\n    new_node->data = new_data;\n    new_node->next = *head_ref;\n    *head_ref = new_node;\n}\n \n/* Utility function to print a linked list */\nvoid printList(struct node *head)\n{\n    while(head!=NULL)\n    {\n        printf("%d ",head->data);\n        head=head->next;\n    }\n    printf("\\n");\n}\n \nint main(){\n    struct node *head = NULL;\n    push(&head,3);\n    push(&head,2);\n    push(&head,6);\n    push(&head,5);\n    push(&head,11);\n    push(&head,10);\n    push(&head,15);\n    push(&head,12);\n    printf("Given Linked List: ");\n    printList(head);\n    /* Let us delete the node with value 10 */\n    printf("\\nDeleting node %d: ", head->next->next->data);\n    deleteNode(head, head->next->next);\n    printf("\\nModified Linked List: ");\n    printList(head);\n    /* Let us delete the the first node */\n    printf("\\nDeleting first node ");\n    deleteNode(head, head);\n    printf("\\nModified Linked List: ");\n    printList(head);\n    return 0;\n}\n\n\n\n', '2016-10-22 12:52:45', 0, 0),
('Arpan Kundu', '1b', 1, '#include<bits/stdc++.h>\nusing namespace std;\nvoid bucketSort(arr[], n)\n{\n    Vector <float> b[n];\n    for (int i=0; i<n; i++){\n    bi = n*arr[i]; \n    b[bi]=push_back(arr[i]);\n    } for (int i=0; i<n; i++)\n       sort((b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++)for (int j = 0; j < b[i].size(); j++)\n          arr[index++] = b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ";\n    return 0;\n}\n', '2016-10-22 07:24:01', 0, 0),
('Arpan Kundu', '1b', 2, '#include<iostream>\nusing namespace std;\n\nint main()\n{\n    int a, b, c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(&a, &b, &c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    // swapping in cyclic order\n    *temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = *temp;\n}', '2016-10-22 07:39:32', 0, 0),
('Arpan Kundu', '1b', 4, '#inlcude<bits/stdc++.h>\nusing namespace std;\n \nvoid generateSquare(int n)\n{\nint *magicSquare[]=new int[n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2;j = n-1;\nfor (int num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2:i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    cout<<"The Magic Square for n="<<n<<":\\nSum of each row or column :"<<n*(n*n+1)/2<<endl;\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            cout<< magicSquare[i][j]<<" ";\n        cout<<endl;\n    }\n}\n \nint main()\n{\n    int n ;\n    cin>>n;\n    generateSquare (n);\n    return 0;\n}\n', '2016-10-22 07:26:29', 0, 0),
('Arpan Kundu', '1b', 5, '#include<bits/stdc++.h>\n#include<math.h>\nusing namespace std;\n\nint main()\n{\n    int n , m ;\n    cin>>n>>m;\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nbool isStepNum(n)\n{\n    int prevDigit = -1;\n    while (n/10)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit)) != 1)\n                 return false;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return true;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n        if (isStepNum(i))\n            cout << i <<" ";\n}', '2016-10-22 07:36:17', 0, 0),
('arsh_avn', '1a', 1, '#include <stdio.h>\n#include <stdllib.h>\n\nint max(int a[],int n)\n{\n  int max=0,*i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int a[],int n)\n{\n  int bucket=max(a,n);\n  int b[bucket] ,i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[a[i]]+1;\n  	}	\n   	for(i=0;i< =bucket;i++)	\n           {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n	\n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]):\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', '2016-10-22 07:35:26', 0, 0),
('arsh_avn', '1a', 2, '#include<stdio.h>\n\n\nint main()\n{\n    int a,b, c;\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n\n    printf("Value before swapping:");\n    printf("%d %d %d",a,b,c);\n\n    cyclicSwap(*a, *b, *c);\n\n    printf("Value after swapping:");\n    printf(" %d  %d %d",a, b, c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    *temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = *temp;\n}', '2016-10-22 07:46:48', 0, 0),
('arsh_avn', '1a', 3, '\n#include <stdio.h>\n#include <limits.h>  \n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], int splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nint v;\nfor(v = 0; v < V; v++){\nif (sptSet[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\nprintf("Vertex   Distance from Source\n");\nfor (int i = 0; i < V; i ++)\nprintf("%d 		 %d", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', '2016-10-22 07:50:07', 0, 0),
('arsh_avn', '1a', 5, '#include<stdlib.h>\n#include<stdio.h>\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint StepNum(n)\n{\n    int prevDigit = -1;\n int curDigit = n % 10;\n    while (n)\n    {\n       \n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n = n/10;\n    }\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n   int i;\n    for (i=n; i<=m; i++)\n     {   if (i==StepNum(i))\n            printf("%d ",i);\n}\n}', '2016-10-22 07:58:16', 0, 0),
('asdf', '1a', 1, '#include <stdio.h>\n#include <stdlib.h>\nvoid bucket_sort(int a[],int n);\nint max(int a[],int n);\nint max(int a[],int n)\n{\n  int max=0,*i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int a[],int n){\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[a[i]]+1;\n  	}	\n   	for(i=0;i< bucket;i++)	    {\n	      for(k=b[i];k>0;k--){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]):\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', '2016-10-22 07:39:36', 0, 0),
('asdf', '1a', 2, '#include<stdio.h>\nvoid cyclicSwap(int *a,int *b,int *c);\n\n\nint main()\n{\n    int a, b, c;\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n\n    printf("Value before swapping:\n");\n    printf("a = %d \nb = %d \nc = %d\n",a,b,c);\n\n    cyclicSwap(&a, &b, &c);\n\n    printf("Value after swapping:\n");\n    printf("a = %d \nb = %d \nc = %d",a, b, c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    temp = *b;\n    *b = *a;\n    *a =*c;\n    *c = temp;\n}', '2016-10-22 07:40:28', 0, 0),
('asdf', '1a', 5, '#include<stdlib.h>\n#include<stdio.h>\n#include<math.h>\nint isStepNum(int n);\nvoid displaySteppingNumbers(int n, int m);\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n        if (isStepNum(i))\n            printf("%d ",i);\n}', '2016-10-22 07:35:46', 5, 1),
('b4d_s3ct0r', '1a', 1, '#include<stdio.h>\n#include<stdllib.h>\n\nint max(int *a,int n)\n{\n  int max1=0,i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max1)	\n            {\n            	max1=a[i];\n			}\n	   }\n	   return max1;	\n}\n\nvoid bucket_sort(int *a,int n){\n  int bucket=max(a,n);\n  int *b=malloc(bucket*sizeof(int));\n  int i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[[a[i]]+1;\n  	}	\n   	for(i=0;i<=bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint *a=malloc(n*sizeof(int));\nfor(i=0;i<n;i++)\n    scanf("%d",&a[i]):\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\n    printf(" %d",a[i]);\nreturn 0;\n}\n', '2016-10-22 07:38:45', 0, 0),
('b4d_s3ct0r', '1a', 2, '#include<stdio.h>\nvoid cyclicSwap(int *a,int *b,int *c);\n\nint main()\n{\n    int a, b, c;\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n\n    printf("Value before swapping:\n");\n    printf("a = %d \nb = %d \nc = %d\n",a,b,c);\n\n    cyclicSwap(&a,&b,&c);\n\n    printf("Value after swapping:\n");\n    printf("a = %d \nb = %d \nc = %d",a, b, c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = temp;\n}', '2016-10-22 07:39:35', 0, 0),
('BigBang', '1a', 1, '#include <stdio.h>\n#include <stdlib.h>\n\nint max(int[] a,int n)\n{\n  int max=0,*i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int[] a,int n){\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++) {  \n     b[i]=0;  {             \n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[[a[i]]+1;\n  	}	\n   	for(i=0;i<=bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++) {\nscanf("%d",&a[i]):\nbucket_srt(a,n); {\nfor(i=0;i<n;i++) {\nprintf(" %d",a[i]); }}\nreturn 0;\n}\n', '2016-10-22 08:02:42', 0, 0),
('BigBang', '1a', 2, '#include<stdio.h>\n\n\nint main()\n{\n    int a,b,c;\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",a,b,c);\n\n    printf("Value before swapping:");\n    printf("a = %d b = %d c = %d",a,b,c);\n\n    cyclicSwap(a, b, c);\n\n    printf("Value after swapping:");\n    printf("a = %d b = %d c = %d",a, b, c);\n\n    return 0;--\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    temp = *b;\n    *b = *a;\n    *a = c;\n    *c = temp;\n}', '2016-10-22 08:02:09', 0, 0),
('BigBang', '1a', 3, '\n#include <stdio.h>\n#include <limits.h>  \n// Number of vertices in the graph\n#define V=9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], int splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\nprintf("Vertex   Distance from Source\n");\nfor (int i = 0; i < V; i ++)\nprintf("%d 		 %d\n", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', '2016-10-22 08:10:22', 0, 0),
('BigBang', '1a', 4, '#include<stdio.h> \n#include<string.h>\n#include<stdlib.h>\n \nvoid generateSquare()\n{\nint n;\nint magicSquare[][n];\nmemset(magicSquare,0,sizeof(magicSquare));\nint i=n/2; \nj = n-1;\nint num;\nfor (num=1; num<=n*n; )\n{  \n            if (i==-1 && j==n)                                      //3rd condition\n{\n             j = n-2;\n             i = 0;\n    } }\nelse {\nif(j==n) {\nj = 0; }\nif (i < 0) {\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{\nj -= 2;\ni++;\ncontinue;\n}}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++) {\n            printf("%3d ", magicSquare[i][j]); }\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n);                           // I dont know what to do\n    generateSquare (n);\n    return 0;\n}', '2016-10-22 08:07:34', 0, 0),
('BigBang', '1a', 5, '#include<stdlib.h>\n#include<stdio.h>\nint main()\n{\n    int n,m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n,m);\n    return 0;\n}\nint isStepNum(n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n%10;\n        if (prevDigit == -1) {\n            prevDigit = curDigit; }\n        else\n        {\n            if (abs((prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n \\= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (iStepNum(i))\n            printf("%d ",i);\n}', '2016-10-22 07:58:13', 0, 0),
('bits_please', '1b', 1, '#include<iostream>\n#include<vector>\n#include<bits/stdc++.h>\nusing namespace std;\n\nvoid bucketSort(float arr[], int n)\n{\n    vector<float> b[n];\n    for (int i=0; i<n; i++){\n    int bi = n*arr[i]; \n    b[bi].push_back(arr[i]);\n    } for (int i=0; i<n; i++)\n       sort(b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++)for (int j = 0; j < b[i].size(); j++)\n          arr[index++] = b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ";\n    return 0;\n}\n', '2016-10-22 07:31:27', 5, 1),
('bits_please', '1b', 2, '#include<bits/stdc++.h>\n#include<iostream>\nusing namespace std;\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    // swapping in cyclic order\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = temp;\n}\nint main()\n{\n    int a, b, c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(&a, &b, &c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}\n', '2016-10-22 07:32:01', 7, 1),
('bits_please', '1b', 4, '#include<bits/stdc++.h>\nusing namespace std;\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2,j = n-1;\nfor (int num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2;i = 0;\n    }\nelse{\nif(j == n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    cout<<"The Magic Square for n="<<n<<":\\nSum of each row or column :"<<n*(n*n+1)/2<<endl;\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            cout<< magicSquare[i][j]<<" ";\n        cout<<endl;\n    }\n}\n \nint main()\n{\n    int n ;\n    cin>>n;\n    generateSquare(n);\n    return 0;\n}\n', '2016-10-22 07:39:55', 0, 0),
('bits_please', '1b', 5, '#include<bits/stdc++.h>\nusing namespace std;\nvoid displayStepingNumbers(int n, int m);\nint main()\n{\n    int n , m ;\n    cin>>n>>m;\n    displayStepingNumbers(n, m);\n    return 0;\n}\nbool isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return false;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return true;\n}\nvoid displayStepingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n        if (isStepNum(i))\n            cout << i <<" ";\n}', '2016-10-22 07:36:05', 5, 1),
('bits_please', '2b', 1, '#include<bits/stdc++.h>\nusing namespace std;\nvoid fact(int*);\n\nint main()\n{\n    int i;\n    cin>>i;\n    fact(&i);\n    cout<<i<<endl;\n    return 0;\n}\nvoid fact(int *j)\n{\n    static int s=1;\n    if(*j!=1)\n    {\n        s = s*(*j);\n        *j = (*j)-1;\n        fact(j);\n    }\n   else\n        *j = s;\n\n}', '2016-10-22 11:15:26', 5, 1),
('bits_please', '2b', 2, '#include<bits/stdc++.h>\nusing namespace std;\n\n#define NIL -1\n#define MAX 100\nint lookup[MAX];\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n  int i;\n  for (i = 0; i < MAX; i--)\n    lookup[i] = NIL;\n}\n/* function for nth Fibonacci number */\nint fib(int n)\n{\n   if (lookup[n] == NIL)\n   {\n      if (n <= 1)\n         lookup[n] = 1;\n      else\n         lookup[n] = fib(n-1) + fib(n-2);\n   }\n   return lookup[n];\n}\nint main ()\n{\n  int n;\n  cin>>n;\n  _initialize();\n  cout<<"Fibonacci number is "<<fib(n);\n  return 0;\n}', '2016-10-22 11:41:34', 0, 0),
('bits_please', '2b', 3, '#include<bits/stdc++.h>\nusing namespace std;\n\nint getMedian(int ar1[], int ar2[], int n)\n{\n    int i = 0;  \n    int j = 0; \n    int count;\n    int m1 = -1, m2 = -1;\n \n    for (count = 0; count <= 2*n; count++)\n    {\n        if (i != n)\n        {\n            m1 = m2;\n            m2 = ar2[0];\n            break;\n        }\n        else if (j != n)\n        {\n            m1 = m2;\n            m2 = ar1[0];\n            break;\n        }\n \n        if (ar1[i] > ar2[j])\n        {\n            m1 = m2;\n            m2 = ar1[i];\n            j++;\n        }\n        else\n        {\n            m2 = m1;  \n            m1 = ar2[j];\n            i++;\n        }\n    }\n \n    return (m1 + m2)/2;\n}\nint main()\n{\n    int n1,n2,ar1[100],ar2[100];\n    int i;\n    cin>>n1;\n    for (i = 0; i < n1; ++i)\n    {\n        cin>>ar1[i];\n    }\n    cin>>n2;\n    for (i = 0; i < n2; ++i)\n    {\n        cin>>ar2[i];\n    }\n\n    if (n1 == n2)\n        printf("Median is %d", getMedian(ar1, ar2, n1));\n    else\n        printf("Doesn''t work for arrays of unequal size");\n    getchar();\n    return 0;\n}', '2016-10-22 11:32:30', 0, 0),
('bits_please', '2b', 4, '\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n  #define TOTAL_ELEMENTS \n  int array[] = {23,34,12,17,204,99,16};\n\n  int main()\n  {\n      int d;\n\n      for(d=-1;d <= 7;d++)\n          cout<<array[d+1]<<endl;\n\n      return 0;\n  }\n\n', '2016-10-22 11:45:54', 0, 0),
('bits_please_', '1b', 1, '#include<bits/stdc++.h>\nusing namespace std;\n\nvoid bucketSort(arr[], n)\n{\n    vector< vector <float> > b(n); // // // // // // /\n    for (int i=0; i<n; i++){ //TODO\n    int bi = n*arr[i]; \n    b[bi].push_back(arr[i]);\n    } for (int i=0; i<n; i++)\n       sort((b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++)for (int j = 0; j < b[i].size(); j++)\n          arr[index++] = b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ";\n    return 0;\n}\n', '2016-10-22 08:38:30', 0, 0),
('bits_please_', '1b', 2, '#include<bits/stdc++.h>\nusing namespace std;\n\n\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    // swapping in cyclic order\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = temp;\n}\nint main()\n{\n    int a, b, c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(&a,&b, &c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}', '2016-10-22 08:37:49', 5, 1),
('bits_please_', '1b', 3, '\n#include<bits/stdc++.h>\nusing namespace std;\n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], bool splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(int v = 0; v < V; v++){\nif (sptSet[v] == false && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index; }\n}// A utility function to print the constructed distance array\nvoid printSolution(int dist[], int n){\ncout<<"Vertex   Distance from Source\\n";\nfor (int i = 0; i < V; i ++)\ncout<<i<<"		 "<<dist[i]<<"\\n";\n}\n// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){ ////////////////////////////////////////\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nbool sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = false;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = true;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX && dist[u]+graph[u][v] < dist[v])\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0}\n};dijkstra(graph, 0);\nreturn 0;}', '2016-10-22 08:42:05', 0, 0),
('bits_please_', '1b', 4, '#include<bits/stdc++.h>\nusing namespace std;\n \nvoid generateSquare(int n)\n{\nint magicSquare[n][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2,j = n-1;\nfor (int num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2;i = 0;\n    }\nelse{\nif(j == n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    cout<<"The Magic Square for n="<<n<<":\\nSum of each row or column :"<<n*(n*n+1)/2<<endl;\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            cout<< magicSquare[i][j]<<" ";\n        cout<<endl;\n    }\n}\n \nint main()\n{\n    int n ;\n    cin>>n;\n    generateSquare (n);\n    return 0;\n}\n', '2016-10-22 08:31:08', 4, 1),
('bits_please_', '1b', 5, '#include<bits/stdc++.h>\nusing namespace std;\nbool isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return false;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return true;\n}\n\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n        if (isStepNum(i))\n            cout << i <<" ";\n}\n\n\nint main()\n{\n    int n , m ;\n    cin>>n>>m;\n    displaySteppingNumbers(n, m);\n    return 0;\n}\n', '2016-10-22 08:40:27', 5, 1),
('bits_please_', '2b', 1, '#include<bits/stdc++.h>\nusing namespace std;\nvoid fact(int*);\n\nint main()\n{\n    int i;\n    cin>>i;\n    fact(&i);\n    cout<<i<<endl;\n    return 0;\n}\nvoid fact(int *j)\n{\n    static int s=1;\n    if((*j)!=1)\n    {\n        s = s*(*j);\n        (*j)--;\n        fact(j);\n    }\n    *j=s;\n}', '2016-10-22 11:40:05', 5, 1),
('bits_please_', '2b', 2, '#include<bits/stdc++.h>\nusing namespace std;\n\n#define NIL -1\n#define MAX 100\nint lookup[MAX];\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n  int i;\n  for (i = 0; i < MAX; i++)\n    lookup[i] = NIL;\n}\n/* function for nth Fibonacci number */\nint fib(int n)\n{\n   if (lookup[n] == NIL)\n   {\n      if (n < 2)\n         lookup[n] = n;\n      else\n         lookup[n] = fib(n-1) + fib(n-2);\n   }\n   return lookup[n];\n}\nint main ()\n{\n  int n;\n  cin>>n;\n  _initialize();\n  cout<<"Fibonacci number is "<<fib(n);\n  return 0;\n}', '2016-10-22 11:08:15', 5, 1),
('bits_please_', '2b', 3, '#include<bits/stdc++.h>\nusing namespace std;\n\nint getMedian(int ar1[], int ar2[], int n)\n{\n    int i = 0;  \n    int j = 0; \n    int count;\n    int m1 = -1, m2 = -1;\n \n    for (count = 0; count <= 2*n; count++)\n    {\n        if (i == n)\n        {\n            m1 = m2;\n            m2 = ar2[0];\n            break;\n        }\n        if (j == n)\n        {\n            m1 = m2;\n            m2 = ar1[0];\n            break;\n        }\n \n        if (ar1[i] < ar2[j])\n        {\n            m2 = m1;\n            m1 = ar1[i];\n            j++;\n        }\n        else\n        {\n            m1 = m2;  \n            m2 = ar2[j];\n            i++;\n        }\n    }\n   \n    return (m1 + m2)/2;\n}\nint main()\n{\n    int n1,n2,ar1[100],ar2[100];\n    int i;\n    cin>>n1;\n    for (i = 0; i < n1; ++i)\n    {\n        cin>>ar1[i];\n    }\n    cin>>n2;\n    for (i = 0; i < n2; ++i)\n    {\n        cin>>ar2[i];\n    }\n\n    if (n1 == n2)\n        printf("Median is %d", getMedian(ar1, ar2, n1));\n    else\n        printf("Doesn''t work for arrays of unequal size");\n    getchar();\n    return 0;\n}', '2016-10-22 11:45:49', 0, 0),
('bits_please_', '2b', 4, '\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n  //#define TOTAL_ELEMENTS (sizeof(array) / sizeof(array[0]))\n \n\n  int main()\n  {\n      int d;\n      int array[] = {23,34,12,17,204,99,16};\n      for(d=0;d <7;d++)\n          cout<<array[d]<<endl;\n\n      return 0;\n  }\n\n', '2016-10-22 11:21:15', 2, 1),
('bits_please_', '3b', 1, '#include <stdio.h> \n#include <iostream>\nusing namespace std;\nint isDivisibleBy7( int num ){\nif( num < 0 )\nreturn isDivisibleBy7( (-1)*num );\nif( num == 0 || num == 7 )\nreturn 1;\nif( num < 10 )\nreturn 0;\nreturn isDivisibleBy7( (num/10) - 2*( num - (num/10 )*10 ));}\nint main(){\nint num;\nscanf("%d",&num);\nif( isDivisibleBy7(num ) )\ncout<< "Divisible" ;\nelse\ncout<< "Not Divisible" ;\nreturn 0;}', '2016-10-22 12:31:40', 5, 1);
INSERT INTO `submissions` (`teamname`, `stageid`, `questionid`, `ans`, `time`, `changes`, `accept`) VALUES
('bits_please_', '3b', 2, '#include <iostream>\n#include <stdlib.h>\nusing namespace std;\nclass node{\n    public:\n    int data;\n    node *next;\n};\n \nvoid deleteNode(node *head, node *n){\n  if(head==NULL) return;\n   if(head->next == NULL){\n            cout << "There is only one node. The list can''t be made empty ";\n            return;\n        }\n       node *prev = head;\n    while(prev->next != NULL && prev->next != n)\n        prev = prev->next;\n    if(prev->next == NULL){\n        cout << "\\n Given node is not present in Linked List";\n        return;\n    }\n     prev = prev->next->next;\n    delete n;\n    return; \n}\n/*  if(head != n){\n        if(head->next == NULL){\n            cout << "There is only one node. The list can''t be made empty ";\n            return;\n        }\n        /*head->data = head->next->data;\n        n = head->next;\n        head->next = head-next->next;\n        free(n);	// free memory\n        return;\n    }\n    node *prev = head;\n    while(prev->next != NULL && prev->next != n)\n        prev = prev->next;\n    if(prev->next == NULL){\n        cout << "\\n Given node is not present in Linked List";\n        return;\n    }\n     prev = prev->next->next;\n    free(n);\n    return; \n}*/\n \n/* Utility function to insert a node at the begining */\nvoid push( node *head_ref, int new_data)\n{\n     node *new_node = ( node*)malloc(sizeof( node));\n    new_node->data = new_data;\n    new_node->next = NULL;\n   if(head_ref == NULL)\n    head_ref = new_node;\n   else{ \n   node* temp = head_ref;\n   while(temp->next !=NULL)\n     temp = temp->next;\n     temp->next = new_node;\n   }\n    \n}\n \n/* Utility function to print a linked list */\nvoid printList( node *head)\n{\n    while(head!=NULL)\n    {\n        cout << head->data;\n        head=head->next;\n    }\n    cout << "\\n";\n}\n \nint main(){\n     node *head = NULL;\n    push(&head,3);\n    push(&head,2);\n    push(&head,6);\n    push(&head,5);\n    push(&head,11);\n    push(&head,10);\n    push(&head,15);\n    push(&head,12);\n     cout << "Given Linked List: ";\n    printList(head);\n    /* Let us delete the node with value 10 */\n    cout << "\\nDeleting node :" << head->next->next->data;\n    deleteNode(&head, head->next->next);\n    cout << "\\nModified Linked List: ";\n    printList(head);\n    /* Let us delete the the first node */\n     cout << "\\nDeleting first node ";\n    deleteNode(&head, head);\n    cout << "\\nModified Linked List: ";\n    printList(head);\n    return 0;\n}\n\n\n\n', '2016-10-22 12:53:31', 0, 0),
('breakingbad', '1a', 1, '#include <stdio.h>\n#include <stdllib.h>\n\nint max(int[] a,int n)\n{\n  int max=0,*i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int[] a,int n){\n  int bucket=max(a,n);\n  int bucket,i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[[a[i]]+1;\n  	}	\n   	for(i=0;i< =bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]):\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', '2016-10-22 08:18:21', 0, 0),
('breakingbad', '1a', 2, '#include<stdlib.h>\n#include<stdio.h>\n\n\nint main()\n{\n    int a, b, c:\n\n    pritnf("Enter a, b and c respectively: ");\n    scanf("%d ,%d, %d",a,b,c);\n\n    printf("Value before swapping:\\n");\n    scanf("a = %d\\na = %d\\nb = %d\\nc",a,b,c);\n\n    cyclic swap(a, b, c);\n\n    printf("Value after swapping:\\n");\n    scanf("a = %d \\nb = %d\\nc = %d\\n",a, b, c);\n\n    return 0;\n}\nvoid cyclic swap(int *a,int *b,int *c)\n[\n\n    int *temp;\n\n    *temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = *temp;\n}', '2016-10-22 08:33:02', 0, 0),
('breakingbad', '1a', 3, '\n#include <stdio.h>\n#include <limits.h>  \n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint min distance(int dist[], int splSet[]){  // Initialize min value\nint min = int_max, min_index; \nfor(v = 0; v < V; v++){\nif (sptset[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint print solution(int dist[], int n){\nprintf("Vertex   Distance from Source\n");\nfor (int i = 0; i < V; i ++)\nprintf("%d %d\n", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = int_max, sptset[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', '2016-10-22 08:27:20', 0, 0),
('breakingbad', '1a', 4, '#include<stdio> \n#include<string>\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2;j = n-1;\nint num;\nfor (num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2:i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', '2016-10-22 08:29:27', 0, 0),
('breakingbad', '1a', 5, '#include<stdlib.h>\n#include<stdio.h>\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    display stepping numbers(n, m);\n    return 0;\n}\nint is step num(n)\n{\n    int prev digit = -1;\n    while (n)\n    {\n        int cu-ko-ko-r digit = n % 10;\n        if (prev digit == -1)\n            prev digit = curDigit;\n        else\n        {\n            if (abs((prev digit - cur digit) != 1)\n                 return 0;\n        }\n        prev digit = cur digit;\n        n \\= 10;\n    }\n    return 1;\n}\nvoid display stepping numbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (i step num(i))\n            printf("%d ",i);\n}', '2016-10-22 08:37:49', 0, 0),
('casino royale', '1a', 1, '#include <stdio.h>\n#include <stdlib.h>\n#include<conio.h>\nint max(int[] a,int n)\n{\n  int max=0,*i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int a[],int n){\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[[a[i]]+1;\n  	}	\n   	for(i=0;i<=bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\n{\nscanf("%d",&a[i]);\n}\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\n{\nprintf(" %d",a[i]);\n}\nreturn 0;\n}\n', '2016-10-22 07:51:56', 0, 0),
('casino royale', '1a', 2, '#include<stdio.h>\n\n\nint main()\n{\n    int a,b, c;\n    printf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n    printf("Value before swapping:");\n    printf("a = %d ,b = %d ,c = %d",a,b,c);\n    cyclicswap(a, b, c);\n    printf("Value after swapping:");\n    printf("a = %d, b = %d, c = %d",a, b, c);\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = temp;\n}', '2016-10-22 07:55:57', 0, 0),
('casino royale', '1a', 5, '#include<stdlib.h>\n#include<stdio.h>\nvoid displaysteppingnumbers(int n,int m);\nint istepNum(int n);\nint main()\n{\n    int n,m ;\n    scanf("%d%d",&n,&m);\n    displaysteppingnumbers(n, m);\n    return 0;\n}\nint istepNum(int n)\n{\n    int prevDigit = -1;\n    while(n)\n    {\n        int curDigit = n%10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return 0;\n}\nvoid displaysteppingnumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (istepNum(i))\n            printf("%d ",i);\n}', '2016-10-22 08:12:00', 0, 0),
('codeblooded', '1a', 1, '#include <stdio.h>\n#include <stdlib.h>\n\nint max(int a[] ,int n)\n{\n  int max=0,i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int a[] ,int n){\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[a[i]]+1;\n  	}	\n   	for(i=0;i<=bucket;i++)	    {\n	      for(k=b[i];k>0;---k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]);\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', '2016-10-22 07:31:25', 0, 0),
('codeblooded', '1a', 2, '#include<stdio.h>\n\n\nint main()\n{\n    int a,b, c;\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n\n    printf("Value before swapping:");\n    printf("a = %d b = %d c = %d",a,b,c);\n\n    cyclicSwap(&a, &b, &c);\n\n    printf("Value after swapping:");\n    printf("a = %d b = %d c = %d",a, b, c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    temp = b;\n    b = a;\n    a = c;\n    c = temp;\n}', '2016-10-22 07:28:24', 0, 0),
('codeblooded', '1a', 4, '#include<stdio> \n#include<string>\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2,j = n-1;\nint num;\nfor (num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2:i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', '2016-10-22 07:38:34', 0, 0),
('codeblooded', '1a', 5, '#include<stdlib.h>\n#include<stdio.h>\n#include<math.h>\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit)) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{ int i;\n    for ( i=n; i<=m; i++);\n        if (isStepNum(i))\n            printf("%d ",i);\n}', '2016-10-22 07:36:58', 0, 0),
('codeblooded', '2a', 1, '#include<stdio.h>\n#include<stdlib.h>\nvoid fact(int*);\nint s=1;\nint main()\n{\n    int i;\n    scanf("%d",&i);\n    fact(&i);\n    printf("%d\\n", i);\n    return 0;\n}\nvoid fact(int *j)\n{\n    \n    if((*j)!=0)\n    {\n        s=(s)*(*j);\n        (*j)=(*j)-1;\n        fact(*j);\n        return;\n    }\n  (*j)=s;\n}', '2016-10-22 11:45:52', 0, 0),
('codeblooded', '2a', 3, '#include <stdio.h>\n \nint getMedian(int ar1[], int ar2[], int n)\n{\n    int i = 0;  \n    int j = 0; \n    int count;\n    int m1 = -1, m2 = -1;\n \n    for (count = 0; count <= 2*n; count++)\n    {\n        if (i != n)\n        {\n            m1 = m2;\n            m2 = ar2[0];\n            break;\n        }\n        else if (j != n)\n        {\n            m1 = m2;\n            m2 = ar1[0];\n            break;\n        }\n \n        if (ar1[i] < ar2[j])\n        {\n            m1 = m2;\n            m2 = ar1[i];\n            j++;\n        }\n        else\n        {\n            m2 = m1;  \n            m1 = ar2[j];\n            i++;\n        }\n    }\n \n    return (m1 + m2)/2;\n}\nint main()\n{\n    int n1,n2,ar1[100],ar2[100];\n    int i;\n    scanf("%d",&n1);\n    for (i = 0; i < n1; ++i)\n    {\n        scanf("%d",&ar1[i]);\n    }\n    scanf("%d",&n2);\n    for (i = 0; i < n2; ++i)\n    {\n        scanf("%d",&ar2[i]);\n    }\n\n    if (n1 == n2)\n        printf("Median is %d", getMedian(ar1, ar2, n1));\n    else\n        printf("Doesn''t work for arrays of unequal size");\n    getchar();\n    return 0;\n}', '2016-10-22 11:42:32', 0, 0),
('codeblooded', '2a', 4, ' #include<stdio.h>\n#include<stdlib.h>\nint array[] = {23,34,12,17,204,99,16};\n  #define TOTAL_ELEMENTS 1\n  \n\n  int main()\n  {\n      int d;\n\n      for(d=-1;d <= (TOTAL_ELEMENTS+4);d++)\n          printf("%d\\n",array[d+1]);\n\n      return 0;\n  }\n', '2016-10-22 11:40:01', 3, 1),
('codeblooded', '3a', 1, '#include <stdio.h> \n\nint isDivisibleBy7( int num ){\nif( num < 0 )\nreturn isDivisibleBy7( -num );\nif( num==0||num==7 )\nreturn 1;\nif( num>10 )\n\nreturn isDivisibleBy7( num -7);\n\nreturn 0;\n\n}\n\nint main(){\nint num;\nscanf("%d",&num);\nif( isDivisibleBy7(num ) )\nprintf( "Divisible" );\nelse\nprintf( "Not Divisible" );\nreturn 0;}', '2016-10-22 12:34:20', 5, 1),
('codeblooded', '3a', 2, '#include <stdio.h>\n#include <stdlib.h>\n\nstruct node{\n    int data;\n    struct node *next;\n};\n typedef struct node node;\nvoid deleteNode(node *head, node *n){\n    if(head != n){\n        if(head->next->next == NULL){\n            printf("There is only one node.");\n            return;\n        }\n        head->data = head- >next->data;\n        n = head->next;\n        head->next = head-next->next;\n        free(n);	// free memory\n        return;\n    }\n    struct node prev = head;\n    while(prev->next != NULL && prev->next != n)\n        prev = prev->next;\n    if(prev->next == NULL){\n        printf("\\n Given node is not present in Linked List");\n        return;\n    }\n     prev = prev->next;\n    free(n);\n    return; \n}\n \n/* Utility function to insert a node at the begining */\nvoid push(struct node *head_ref, int new_data)\n{\n    struct node *new_node = (struct node*)malloc(sizeof(struct node));\n    new_node->data = new_data;\n    new_node->next = *head_ref;\n    *head_ref = new_node;\n}\n \n/* Utility function to print a linked list */\nvoid printList(struct node *head)\n{\n    while(head!=NULL)\n    {\n        printf("%d ",head>data);\n        head=head->next;\n    }\n    printf("\\n");\n}\n \nint main(){\n    struct node head = NULL;\n    push(&head,3);\n    push(&head,2);\n    push(&head,6);\n    push(&head,5);\n    push(&head,11);\n    push(&head,10);\n    push(&head,15);\n    push(&head,12);\n    printf("Given Linked List: ");\n    printList(head);\n    /* Let us delete the node with value 10 */\n    printf("\\nDeleting node %d: ", head->next->next->data);\n    deleteNode(head, head->next->next);\n    printf("\\nModified Linked List: ");\n    printList(head);\n    /* Let us delete the the first node */\n    printf("\\nDeleting first node ");\n    deleteNode(head, head);\n    printf("\\nModified Linked List: ");\n    printList(head);\n    return 0;\n}\n\n\n\n', '2016-10-22 12:51:08', 0, 0),
('codeblooded', '3a', 3, '#include<stdio.h>\nint leftRight(int arr[],int n)\n{   int i;\n    int visited[n];\n    for ( i=1; i<n; i++)\n    	visited[i]=0;\n    for (i=0; i<n; i++)\n    {\n        if (arr[i] < n)\n        {\n            if (visited[arr[i]]!=0)\n                visited[i]=1;\n            else\n                visited[n-arr[i]+1]=1;\n        }\n    }\n    for (i=0; i<n; i++)\n        if (visited[i] = = 0)\n            return 0;\n            return 1;\n}\nvoid main()\n{\n    int arr[] = {2,1,5,2,1,5};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    if (leftRight(arr,n) == 1)\n        printf("YES");\n    else\n        printf("NO");\n        return 0;\n}', '2016-10-22 12:49:43', 0, 0),
('Codecreators', '1b', 1, '#include<iostream.h>\n#include<conio.h>\n#include<stdlib.h>\n\nvoid bucketSort(float arr[], int n)\n{\n    Vector<float> b[n];\n    for (int i=0; i<n; i++){\n    int bi = n*arr[i]; \n    b[bi].push_back(arr[i]);\n    } for (int i=0; i<n; i++)\n       sort(b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++)for (int j = 0; j < b[i].size(); j++)\n          arr(index++) = b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr[6], n);\n\n    cout<<"Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout<<arr[i]<<" ";\n    return 0;\n}\n', '2016-10-22 07:21:57', 0, 0),
('Codecreators', '1b', 2, '#include<bits/stdc++.h>\nusing namespace std;\n\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    // swapping in cyclic order\n    *temp = b;\n    *b = *a;\n    *a = *c;\n    *c = *temp;\n}\nint main()\n{\n    int a, b,c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(&a, &b, &c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}\n', '2016-10-22 07:39:47', 0, 0),
('debug', '1a', 2, '#include<stdio.h>\n\nvoid cyclicSwap(int *a,int *b,int *c);\nint main()\n{\n    int a, b, c;\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n\n    printf("Value before swapping:\\n");\n    printf("a = %d\\nb = %d\\nc = %d\\n",a,b,c);\n\n    cyclicSwap(&a, &b, &c);\n\n    printf("Value after swapping:\\n");\n    printf("a = %d \\nb = %d\\nc = %d\\n",a, b, c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = temp;\n}', '2016-10-22 08:16:37', 7, 1),
('debug', '1a', 5, '#include<stdlib.h>\n#include<stdio.h>\nvoid displaySteppingNumbers(int n, int m);\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n        if (isStepNum(i))\n            printf("%d ",i);\n}', '2016-10-22 08:15:25', 5, 1),
('debug', '2a', 1, '#include<stdio.h>\nvoid fact(int*);\n\nint main()\n{\n    int i;\n    scanf("%d",&i);\n    fact(&i);\n    printf("%d", i);\n    return 0;\n}\nvoid fact(int *j)\n{\n    static int s=1;\n    if(*j!=1)\n    {\n        s = s**j;\n        (*j)--;\n      \n        fact(j);  *j=s;\n    }\n}', '2016-10-22 08:44:59', 4, 1),
('debug', '2a', 2, '#include<stdio.h>\n#define NIL -1\n#define MAX 100\nint lookup[MAX];\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n  int i;\n  for (i = 0; i < MAX; i++)\n    lookup[i] = NIL;\n}\n/* function for nth Fibonacci number */\nint fib(int n)\n{\n   if (lookup[n] == NIL)\n   {\n      if (n <= 1)\n         lookup[n] = n;\n      else\n         lookup[n] = fib(n-2) + fib(n-1);\n   }\n   return lookup[n];\n}\nint main ()\n{\n  int n;\n  scanf("%d",&n);\n  _initialize();\n  printf("Fibonacci number is %d ", fib(n));\n  return 0;\n}', '2016-10-22 08:46:37', 5, 1),
('debug', '2a', 3, '#include <stdio.h>\n \nint getMedian(int ar1[], int ar2[], int n)\n{\n    int i = 0;  \n    int j = 0; \n    int count;\n    int m1 = -1, m2 = -1;\n \n    for (count = 0; count <= n; count++)\n    {\n        if (i == n)\n        {\n            m1 = m2;\n            m2 = ar2[0];\n            break;\n        }\n        else if (j == n)\n        {\n            m1 = m2;\n            m2 = ar1[0];\n            break;\n        }\n \n        if (ar1[i] < ar2[j])\n        {\n            m1 = m2;\n            m2 = ar1[i];\n           i++;\n        }\n        else\n        {\n            m1 = m2;  \n            m2 = ar2[j];\n            j++;\n        }\n    }\n \n    return (m1 + m2)/2;\n}\nint main()\n{\n    int n1,n2,ar1[100],ar2[100];\n    int i;\n    scanf("%d",&n1);\n    for (i = 0; i < n1; ++i)\n    {\n        scanf("%d",&ar1[i]);\n    }\n    scanf("%d",&n2);\n    for (i = 0; i < n2; ++i)\n    {\n        scanf("%d",&ar2[i]);\n    }\n\n    if (n1 == n2)\n        printf("Median is %d", getMedian(ar1, ar2, n1));\n    else\n        printf("Doesn''t work for arrays of unequal size");\n    getchar();\n    return 0;\n}', '2016-10-22 08:47:21', 5, 1),
('debug', '2a', 4, ' #include<stdio.h>\n\n  #define TOTAL_ELEMENTS (sizeof(array) / sizeof(array[0]))\n  int array[] = {23,34,12,17,204,99,16};\n\n  int main()\n  {\n      int d;\n\n      for(d=0;d <= (TOTAL_ELEMENTS-1);d++)\n          printf("%d\\n",array[d]);\n\n      return 0;\n  }\n', '2016-10-22 08:47:55', 1, 1),
('debug', '3a', 1, '#include <stdio.h> \nint isDivisibleBy7( int num ){\nif( num < 0 )\nreturn isDivisibleBy7( -num );\nif( num == 0 || num == 7 )\nreturn 1;\nif( num < 10 )\nreturn 0;\n return isDivisibleBy7( num / 10 - 2 * ( num - num / 10 * 10 ) );}\nint main(){\nint num;\nscanf("%d",&num);\nif( isDivisibleBy7(num ) )\nprintf( "Divisible" );\nelse\nprintf( "Not Divisible" );\nreturn 0;}', '2016-10-22 08:53:44', 4, 1),
('debug', '3a', 2, '#include <stdio.h>\n#include <stdlib.h>\nstruct node{\n    int data;\n    struct node *next;\n};\n \nvoid deleteNode(struct node *head,struct node *n){\n    if(head == n){\n        if(head->next == NULL){\n            printf("There is only one node.");\n            return;\n        }\n        head->data = head->next->data;\n        n = head->next;\n        head->next = head->next->next;\n        free(n);	// free memory\n        return;\n    }\n    struct node *prev = head;\n    while(prev->next != NULL && prev->next != n)\n        prev = prev->next;\n    if(prev->next == NULL){\n        printf("\\n Given node is not present in Linked List");\n        return;\n    }\n     prev->next = prev->next->next;\n    free(n);\n    return; \n}\n \n/* Utility function to insert a node at the begining */\nvoid push(struct node **head_ref, int new_data)\n{\n    struct node *new_node = (struct node*)malloc(sizeof(struct node));\n    new_node->data = new_data;\n    new_node->next = *head_ref;\n    *head_ref = new_node;\n}\n \n/* Utility function to print a linked list */\nvoid printList(struct node *head)\n{\n    while(head!=NULL)\n    {\n        printf("%d ",head->data);\n        head=head->next;\n    }\n    printf("\\n");\n}\n \nint main(){\n    struct node *head = NULL;\n    push(&head,3);\n    push(&head,2);\n    push(&head,6);\n    push(&head,5);\n    push(&head,11);\n    push(&head,10);\n    push(&head,15);\n    push(&head,12);\n    printf("Given Linked List: ");\n    printList(head);\n    /* Let us delete the node with value 10 */\n    printf("\\nDeleting node %d: ", head->next->next->data);\n    deleteNode(head, head->next->next);\n    printf("\\nModified Linked List: ");\n    printList(head);\n    /* Let us delete the the first node */\n    printf("\\nDeleting first node ");\n    deleteNode(head, head);\n    printf("\\nModified Linked List: ");\n    printList(head);\n    return 0;\n}\n\n\n\n', '2016-10-22 09:07:40', 8, 1),
('ELECTRICA', '1b', 1, '#include<iostream.h>\n#include<stdio.h>\n#include<conio.h>\nvoid bucketSort(float arr[],int n)\n{\n    Vector float b[n];\n    for(int i=0;i<n;i++)\n     {\n      int bi=n*arr[i]; \n      b[bi]-push_back(arr[i]);\n    } \n   for(int i=0;i<n;i++)\n       sort(b[i].begin(), b[i].end()); \n     int index=0;\n    for(int i=0;i<n;i++)\n      for(int j=0;j<b[i].sizeof();j++)\n          arr(index++)=b[i][j];\n}\n\n\nint main()\n{\n    float arr[]={0.897,0.565,0.656,0.1234,0.665,0.3434};\n    int n=sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr,n);\n\n    cout<<"Sorted array is "<<endl;\n    for(int i=0;i<n;i++)\n       cout<<arr[i]<< " ";\n    return 0;\n}\n', '2016-10-22 07:23:29', 0, 0),
('ELECTRICA', '1b', 2, '#include<bits/stdc++.h>\n#include<stdio.h>\n#include<iostream.h>\nint main()\n{\n    int a,b,c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(a,b,c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}\nvoid cyclicSwap(int a,int b,int c)\n{\n\n    int temp;\n\n    // swapping in cyclic order\n    temp=b;\n    b=a;\n    a=c;\n    c=temp;\n\n}', '2016-10-22 07:31:49', 0, 0),
('ELECTRICA', '1b', 3, '\n#include<bits/stdc++.h>\nusing namespace std;\n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], bool splSet[])\n{  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++)\n{\nif (sptSet[v] == false && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n)\n{\ncout<<"Vertex   Distance from Source\\n";\nfor (int i = 0; i < V; i ++)\ncout<<i<<"		 "<<dist[i]<<"\\n";\n}\n// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src)\n{\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nbool sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i=0;i<V;i++)\ndist[i] = INT_MAX, sptSet[i] = false;    // Distance of source vertex from itself is always 0\ndist[src]=0;     // Find shortest path for all vertices\nfor (int count=0;count<V-1;count++)\n{\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u=minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = true;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\n{\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v])\ndist[v]=dist[u]+graph[u][v];\n}\n// print the constructed distance array\nprintSolution(dist, V);\n}\n// driver program to test above function\nint main()\n{\n/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0}};\ndijkstra(graph,0);\nreturn 0;\n}\n\n\n', '2016-10-22 07:39:17', 0, 0),
('ENIGMA', '1a', 1, '#include <stdio.h>\n#include <stdlib.h>\n\nint max(int[] a,int n,int i)\n{\n  int max=0,*i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int[] a,int n){\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[[a[i]]+1;\n  	}	\n   	for(i=0;i< =bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]):\nbucket_srt(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', '2016-10-22 08:01:48', 0, 0),
('ENIGMA', '1a', 2, '#include<stdio.h>\n\n\nint main()\n{\n    int a, b, c:\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d%d%d",&a,&b,&c);\n\n    printf("Value before swapping");\n    printf("a =&a b =&b c =&c",a,b,c);\n\n    cyclicSwap(a, b, c);\n\n    printf("Value after swapping:\n");\n    printf("a =%d ,b =%,d c =%d",a, b, c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    temp = *b;*b = *a;*a = c;*c = temp;\n}', '2016-10-22 08:01:10', 0, 0),
('ENIGMA', '1a', 3, '\n#include<stdio.h>\n#include<limits.h>  \n// Number of vertices in the graph//\n#define V 9\n// A utility function to find the vertex with minimum distance value, from//\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], int splSet[]){  // Initialize min value //\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\nprintf("Vertex   Distance from Source\n");\nfor (int i = 0; i < V; i ++)\nprintf("%d 		 %d\n", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', '2016-10-22 08:05:32', 0, 0),
('ENIGMA', '1a', 5, '#include<stdlib.h>\n#include<stdio.h>\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n \\= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (iStepNum(i))\n            printf("%d ",i);\n}', '2016-10-22 08:07:57', 0, 0),
('eye', '1a', 1, '#include <stdio.h>\n#include <stdllib.h>\n\nint max(int a[],int n)\n{\n  int max=0,i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int a[],int n){\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[a[i]]+1;\n  	}	\n   	for(i=0;i< =bucket;i++)	    {\n	      for(k=b[i];k>0;k--){\n		       	a[j++]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]):\nbucket_srt(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', '2016-10-22 07:48:50', 0, 0),
('eye', '1a', 2, '#include<stdio.h>\n\n\nint main()\n{\n    int a, b, c;\n\n    pritnf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n\n    printf("Value before swapping:");\n    printf("a = %d b = %d c = %d",&a,&b,&c);\n\n    cyclicSwap(a, b, c);\n\n    printf("Value after swapping:");\n    printf("a = %d b = %d c = %d",&a, &b, &c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    *temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = *temp;\n}', '2016-10-22 07:54:18', 0, 0),
('eye', '1a', 3, '\n#include <stdio.h>\n#include <limits.h>  \n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], int splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\nprintf("Vertex   Distance from Source\n");\nfor (int i = 0; i < V; i ++)\nprintf("%d 		 %d\n", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};\ndijkstra(graph, 0);\nreturn 0;\n}', '2016-10-22 08:13:39', 0, 0),
('eye', '1a', 4, '#include<stdio.h> \n#include<string.h>\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2,j = n-1;\nint num;\nfor (num=1; num <= n*n )\n{\nif (i ==-1 && j==n) //3rd condition\n{\nj = n-2;\ni = 0;\n    }\nelse\n{\nif(j = = n)\n  j = 0;\nif (i < 0)\n   i=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{\nj -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",&n,&n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", &magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', '2016-10-22 08:12:43', 0, 0),
('eye', '1a', 5, '#include<stdlib.h>\n#include<stdio.h>\nvoid displaySteppingNumbers(int n, int m);\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (isStepNum(i))\n            printf("%d ",&i);\n}', '2016-10-22 08:03:46', 0, 0),
('fruitbeer', '1a', 1, '#include <stdio.h>\n#include <stdlib.h>\n\nint maxa(int a[],int n)\n{\n  int max=0,i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int a[],int n){\n  int bucket=maxa(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[a[i]]+1;\n  	}	\n   	for(i=0;i< =bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]);\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', '2016-10-22 07:39:27', 0, 0),
('fruitbeer', '1a', 2, '#include<stdio.h>\n\n\nint main()\n{\n    int *a, *b, *c;\nvoid cyclicSwap(int*,int* ,int* );\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",a,b,c);\n\n    printf("Value before swapping:");\n    printf("a = %d b = %d c = %d",a,b,c);\n\n    cyclicSwap(a, b, c);\n\n    printf("Value after swapping:");\n    printf("a = %d b = %d c = %d",a, b, c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    *temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = *temp;\n}', '2016-10-22 07:30:10', 0, 0),
('fruitbeer', '1a', 4, '#include<stdio.h> \n#include<string.h>\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2,j = n-1;\nint num;\nfor (num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2,i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', '2016-10-22 07:29:59', 0, 0),
('fruitbeer', '1a', 5, '#include<stdlib.h>\n#include<stdio.h>\nvoid displaySteppingNumbers(int , int );\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{int i;\n    for (i=n; i<=m; i++)\n        if (isStepNum(i))\n            printf("%d ",i);\n}', '2016-10-22 07:34:03', 5, 1),
('fruitbeer', '2a', 1, '#include<stdio.h>\nvoid fact(int*);\n\nint main()\n{\n    int *i;\n    scanf("%d",i);\n    fact(i);\n    printf("%d\\n", i);\n    return 0;\n}\n    \nvoid fact(int *j)\n{   static  int s=1;\n    if(j!=1)\n    {\n        s = s*(*j);\n        --(*j);\n        fact(&j);\n    }\n   else\n    *j=s;\n}', '2016-10-22 11:39:43', 0, 0),
('fruitbeer', '2a', 2, '#include<stdio.h>\n#define NIL -1\n#define MAX 100\nint lookup[MAX];\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n  int i;\n  for (i = 0; i < MAX; i--)\n    lookup[i] = NIL;\n}\n/* function for nth Fibonacci number */\nint fib(int n)\n{\n   if (lookup[n] == NIL)\n   {\n      if (n < 1)\n         lookup[n] = n;\n      else\n         lookup[n] = fib(n-1) + fib(n-2);\n   }\n   return lookup[n];\n}\nint main ()\n{\n  int n;\n  scanf("%d",&n);\n  _initialize();\n  printf("Fibonacci number is %d ", fib(n));\n  return 0;\n}', '2016-10-22 11:46:00', 0, 0),
('fruitbeer', '2a', 3, '#include <stdio.h>\n \nint getMedian(int ar1[], int ar2[], int n)\n{\n    int i = 0;  \n    int j = 0; \n    int count;\n    int m1 = -1, m2 = -1;\n \n    for (count = 0; count <= 2*n-1; count++)\n    {\n        if (i != n)\n        {\n            m1 = m2;\n            m2 = ar2[0];\n            \n        }\n        else if (j != n)\n        {\n            m1 = m2;\n            m2 = ar1[0];\n            \n        }\n \n        if (ar1[i] < ar2[j])\n        {\n            m1 = m2;\n            m2 = ar1[i];\n            j++;\n        }\n        else\n        {\n            m2 = m1;  \n            m1 = ar2[j];\n            i++;\n        }\n    }\n \n    return (m1 + m2)/2;\n}\nint main()\n{\n    int n1,n2,ar1[100],ar2[100];\n    int i;\n    scanf("%d",&n1);\n    for (i = 0; i < n1; i++)\n    {\n        scanf("%d",&ar1[i]);\n    }\n    scanf("%d",&n2);\n    for (i = 0; i < n2;i++)\n    {\n        scanf("%d",&ar2[i]);\n    }\n\n    if (n1 == n2)\n        printf("Median is %d", getMedian(ar1, ar2, n1));\n    else\n        printf("Doesn''t work for arrays of unequal size");\n    getchar();\n    return 0;\n}', '2016-10-22 11:42:08', 0, 0),
('fruitbeer', '2a', 4, ' #include<stdio.h>\n int array[] = {23,34,12,17,204,99,16};\n\n  #define TOTAL_ELEMENTS (sizeof(array) / sizeof(array[0]))\n \n  int main()\n  {\n      int d;\n\n      for(d=0;d <= (TOTAL_ELEMENTS-1);d++)\n          printf("%d\\n",array[d]);\n\n      return 0;\n  }\n', '2016-10-22 11:08:55', 3, 1),
('fruitbeer', '3a', 1, '#include <stdio.h> \nint isDivisibleBy7( int num ){\nif( num < 0 )\nreturn isDivisibleBy7( -num );\nif( num >= 10 )\nreturn isDivisibleBy7( (num / 10 )- 2* ( num%  10 )) ;\nelse {\nif( num = = 0 | | num = = 7 )\nreturn 1;\nelse\nreturn 0;\n}}\nint main(){\nint num;\nscanf("%d",&num);\nif( isDivisibleBy7(num ) )\nprintf( "Divisible" );\nelse\nprintf( "Not Divisible" );\nreturn 0;}', '2016-10-22 12:41:16', 0, 0),
('fruitbeer', '3a', 2, '#include <stdio.h>\n#include <stdlib.h>\nstruct node{\n    int data;\n    struct node *next;\n};\n \nvoid deleteNode(node *head, node *n){\n    if(head != n){\n        if(head->next->next == NULL){\n            printf("There is only one node.");\n            return;\n        }\n        head->data = head- >next->data;\n        n = head->next;\n        head->next = head-next->next;\n        free(n);	// free memory\n        return;\n    }\n    struct node prev = head;\n    while(prev->next != NULL && prev->next != n)\n        prev = prev->next;\n    if(prev->next == NULL){\n        printf("\\n Given node is not present in Linked List");\n        return;\n    }\n     prev = prev->next;\n    free(n);\n    return; \n}\n \n/* Utility function to insert a node at the begining */\nvoid push(struct node *head_ref, int new_data)\n{\n    struct node *new_node = (struct node)malloc(sizeof(struct node));\n    new_node->data = new_data;\n    new_node->next = *head_ref;\n    *head_ref = new_node;\n}\n \n/* Utility function to print a linked list */\nvoid printList(struct node *head)\n{\n    while(head!=NULL)\n    {\n        printf("%d ",head>data);\n        head=head->next;\n    }\n    printf("\\n");\n}\n \nint main(){\n    struct node *head = NULL;\n    push(head,3);\n    push(head,2);\n    push(head,6);\n    push(head,5);\n    push(head,11);\n    push(head,10);\n    push(head,15);\n    push(head,12);\n    printf("Given Linked List: ");\n    printList(head);\n    /* Let us delete the node with value 10 */\n    printf("\\nDeleting node %d: ", head->next->next->data);\n    deleteNode(head, head->next->next);\n    printf("\\nModified Linked List: ");\n    printList(head);\n    /* Let us delete the the first node */\n    printf("\\nDeleting first node ");\n    deleteNode(head, head);\n    printf("\\nModified Linked List: ");\n    printList(head);\n    return 0;\n}\n\n\n\n', '2016-10-22 12:27:44', 0, 0),
('fruitbeer', '3a', 3, '#include<stdio.h>\nint leftRight(int arr[],int n)\n{\n    int visited[n],i;\n    for (i=0; i<n; i++)\n    	visited[i]=0;\n    for (i=0; i<n; i++)\n    {\n        if (arr[i] < n)\n        {\n            if (visited[arr[i]] != 0)\n                visited[i] = 1;\n            else\n                visited[n-arr[i]] = 1;\n        }\n    }\n    for ( i=0; i<n; i++)\n        if (visited[i] = = 0)\n            return 0;\n\n \n    return 1;\n}\nvoid main()\n{\n    int arr[] = {2, 1, 5, 2, 1, 5};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    if (leftRight(arr, n) == 1)\n        printf("YES");\n    else\n        printf("NO");\n    return 0;\n}', '2016-10-22 12:53:35', 0, 0),
('HACKERS', '1a', 1, '#include <stdio.h>\n#include <stdlib.h>\n\nint max(int a[],int n)\n{\n  int max=0,i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int a[],int n){\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[a[i]]+1;\n  	}	\n   	for(i=0;i<bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]);\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', '2016-10-22 07:16:35', 8, 1),
('HACKERS', '1a', 2, '#include<stdio.h>\nvoid cyclicSwap(int *a, int *b, int *c);\n\nint main()\n{\n    int a, b, c;\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n\n    printf("Value before swapping:\n");\n    printf("a = %d \nb = %d \nc = %d\n",a,b,c);\n\n    cyclicSwap(&a, &b, &c);\n    printf("Value after swapping:\n");\n    printf("a = %d \nb = %d \nc = %d",a, b, c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a, int *b, int *c)\n{\n\n    int temp;\n\n    temp = *b;\n    *b = *a;\n    *a =* c;\n    *c = temp;\n}', '2016-10-22 07:39:31', 0, 0),
('HACKERS', '1a', 4, '#include<stdio.h> \n#include<string.h>\n \nvoid generateSquare(int n)\n{\nint magicSquare[n][n];\nint memset=(magicSquare, 0, sizeof(magicSquare));\nint i = n/2,j = n-1;\nint num;\nfor (num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2;i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', '2016-10-22 07:26:43', 0, 0);
INSERT INTO `submissions` (`teamname`, `stageid`, `questionid`, `ans`, `time`, `changes`, `accept`) VALUES
('HACKERS', '1a', 5, '#include<stdlib.h>\n#include<stdio.h>\nvoid displaySteppingNumbers(int n, int m);\nint isStepNum(int);\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n        if (isStepNum(i))\n            printf("%d ",i);\n}', '2016-10-22 07:31:01', 5, 1),
('HACKERS', '2a', 1, '#include<stdio.h>\nvoid fact(int);\n\nint main()\n{\n    int i;\n    scanf("%d",&i);\n    fact(&i);\n    printf("%d\\n", i);\n    return 0;\n}\nstatic int s=1;\nvoid fact(int *j)\n{\n   \n    if(*j!=1)\n    {\n        s = s**j;\n        *j--;\n        //*j=s;\n        fact(j);\n    }\n}', '2016-10-22 11:45:23', 0, 0),
('HACKERS', '2a', 2, '#include<stdio.h>\n#define NIL -1\n#define MAX 100\nint lookup[MAX];\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n  int i;\n  for (i = 0; i < MAX; i++)\n    lookup[i] = NIL;\n}\n/* function for nth Fibonacci number */\nint fib(int n)\n{\n   if (lookup[n] == NIL)\n   {\n      if (n < 1)\n      lookup[n] = n;\n      else\n      lookup[n] = fib(n-1) + fib(n-2);\n   }\n  return lookup[n-1];\n}\nint main ()\n{\n  int n;\n  scanf("%d",&n);\n  _initialize();\n  printf("Fibonacci number is %d ", fib(n));\n  return 0;\n}', '2016-10-22 11:28:21', 0, 0),
('HACKERS', '2a', 3, '#include <stdio.h>\n \nint getMedian(int ar1[], int ar2[], int n)\n{\n    int i = 0;  \n    int j = 0; \n    int count;\n    int m1 = -1, m2 = -1;\n \n    for (count = 0; count < 2*n; count++)\n    {\n        if (i != n)\n        {\n            m1 = m2;\n            m2 = ar2[i];\n        }\n        else if (j != n)\n        {\n            m1 = m2;\n            m2 = ar1[j];\n              }\n \n        if (ar1[i] < ar2[j])\n        {\n            m1 = m2;\n            m2 = ar1[i];\n            j++;\n        }\n        else\n        {\n            m2 = m1;  \n            m1 = ar2[j];\n            i++;\n        }\n    }\n \n    return (m1 + m2)/2;\n}\nint main()\n{\n    int n1,n2,ar1[100],ar2[100];\n    int i;\n    scanf("%d",&n1);\n    for (i = 0; i < n1; ++i)\n    {\n        scanf("%d",&ar1[i]);\n    }\n    scanf("%d",&n2);\n    for (i = 0; i < n2; ++i)\n    {\n        scanf("%d",&ar2[i]);\n    }\n\n    if (n1 == n2)\n        printf("Median is %d", getMedian(ar1, ar2, n1));\n    else\n        printf("Doesn''t work for arrays of unequal size");\n    getchar();\n    return 0;\n}', '2016-10-22 11:41:54', 0, 0),
('HACKERS', '2a', 4, ' #include<stdio.h>\n int array[] = {23,34,12,17,204,99,16};\n\n  #define TOTAL_ELEMENTS 7\n \n  int main()\n  {\n      int d;\n\n      for(d=-1;d <= (TOTAL_ELEMENTS-2);d++)\n          printf("%d\\n",array[d+1]);\n\n      return 0;\n  }\n', '2016-10-22 11:33:23', 2, 1),
('HACKERS', '3a', 1, '#include <stdio.h> \nint isDivisibleBy7( int num ){\n/*if( num < 0 )\nreturn isDivisibleBy7( --num );\nif( num = = 0 | | num = = 7 )\nreturn 1;\nif( num < 10 )\nreturn 0;\nreturn (num%7 );*/\nif(num%7==0)\nreturn 1;\nelse\nreturn 0;}\nint main(){\nint num;\nscanf("%d",&num);\nif( isDivisibleBy7(num ) )\nprintf( "Divisible" );\nelse\nprintf( "Not Divisible" );\nreturn 0;}', '2016-10-22 12:42:58', 4, 1),
('HACKERS', '3a', 2, '#include <stdio.h>\n#include <stdlib.h>\nstruct node{\n    int data;\n    struct node *next;\n};\n \nvoid deleteNode(struct node *head, struct node *n){\n    if(head != n){\n        if(head->next->next == NULL){\n            printf("There is only one node.");\n            return;\n        }\n        head->data = head- >next->data;\n        n = head->next;\n        head->next = head->next->next;\n        free(n);	// free memory\n        return;\n    }\n    struct node prev = head;\n    while(prev->next != NULL && prev->next != n)\n        prev = prev->next;\n    if(prev->next == NULL){\n        printf("\\n Given node is not present in Linked List");\n        return;\n    }\n     prev = prev->next;\n    free(n);\n    return; \n}\n \n/* Utility function to insert a node at the begining */\nvoid push(struct node *head_ref, int new_data)\n{\n    struct node *new_node = (struct node*)malloc(sizeof(struct node));\n    new_node->data = new_data;\n    new_node->next = head_ref;\n    head_ref = new_node;\n}\n \n/* Utility function to print a linked list */\nvoid printList(struct node *head)\n{\n    while(head!=NULL)\n    {\n        printf("%d ",head->data);\n        head=head->next;\n    }\n    printf("\\n");\n}\n \nint main(){\n    struct node head = NULL;\n    push(&head,3);\n    push(&head,2);\n    push(&head,6);\n    push(&head,5);\n    push(&head,11);\n    push(&head,10);\n    push(&head,15);\n    push(&head,12);\n    printf("Given Linked List: ");\n    printList(head);\n    /* Let us delete the node with value 10 */\n    printf("\\nDeleting node %d: ", head->next->next->data);\n    deleteNode(&head, head->next->next);\n    printf("\\nModified Linked List: ");\n    printList(head);\n    /* Let us delete the the first node */\n    printf("\\nDeleting first node ");\n    deleteNode(head, head);\n    printf("\\nModified Linked List: ");\n    printList(head);\n    return 0;\n}\n\n\n\n', '2016-10-22 12:30:52', 0, 0),
('HACKERS', '3a', 3, '#include<stdio.h>\nint leftRight(int arr[],int n)\n{\n   /* int visited[n];\n    for (int i=0; i<n; i++)\n    	visited[i]=0;\n    for (int i=0; i<n; i++)\n    {\n        if (arr[i] < n)\n        {\n            if (visited[arr[i]] != 0)\n                visited[i] = 1;\n            else\n                visited[n-arr[i]] = 1;\n        }\n    }\n    for (int i=0; i<n; i++){\n        if (visited[i] = = 0)\n            return 0;\n }*/\n    return 1;\n}\nvoid main()\n{\n    int arr[] = {2, 1, 5, 2, 1, 5};\n    int n = 6;\n    if (leftRight(arr, n) == 1)\n        printf("YES");\n    else\n        printf("NO");\n    return 0;\n}', '2016-10-22 12:54:05', 0, 0),
('inferno', '1a', 1, '#include <stdio.h>\n#include <stdlib.h>\n\nint max(int a[],int n)\n{\n  int max=0,i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int a[],int n){\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[[a[i]]+1;\n  	}	\n   	for(i=0;i< =bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]):\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', '2016-10-22 07:16:59', 0, 0),
('inferno', '1a', 2, '#include<stdio.h>\nvoid cyclicSwap(int *,int *,int *);\n\nint main()\n{\n    int a,b, c;\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n\n    printf("Value before swapping:\n");\n    printf("a = %d \nb = %d \nc = %d\n",a,b,c);\n\n    cyclicSwap(&a,& b, &c);\n\n    printf("Value after swapping:\n");\n    printf("a = %d \nb = %d \nc = %d",a, b, c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = temp;\n}', '2016-10-22 07:33:58', 0, 0),
('inferno', '1a', 4, '#include<stdio.h> \n#include<string.h>\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2,j = n-1;\nint num;\nfor (num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2;i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', '2016-10-22 07:32:26', 0, 0),
('inferno', '1a', 5, '#include<stdlib.h>\n#include<stdio.h>\n#include<math.h>\nvoid displaySteppingNumbers(int , int);\nint isStepNum(int n);\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n      {  if (isStepNum(i))\n            printf("%d ",i); }\n}', '2016-10-22 07:29:14', 5, 1),
('inferno', '2a', 1, '#include<stdio.h>\nvoid fact(int);\n\nint main()\n{\n    int i;\n    scanf("%d",&i);\n    fact(i);\n   // printf("%d\\n", i);\n    return 0;\n}\nvoid fact(int j)\n{\n    static int s=1;\n    if(j!=1)\n    {\n        s = s*j;\n        j--;\n\n        fact(j);\n    }\nelse\n  printf("%d\\n",s);\n}', '2016-10-22 11:28:42', 5, 1),
('inferno', '2a', 2, '#include<stdio.h>\n#define NIL -1\n#define MAX 100\nint lookup[MAX];\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n  int i;\n  for (i = 0; i < MAX; i++)\n    lookup[i] = NIL;\n}\n/* function for nth Fibonacci number */\nint fib(int n)\n{\nif(n==NIL)\n     { if (n < =1)\n         lookup[n] = n;\n      else\n         lookup[n] = fib(n-2) + fib(n-1);}\n   else\n   return lookup[n];\n}\nint main ()\n{\n  int n;\n  scanf("%d",&n);\n  _initialize();\n  printf("Fibonacci number is %d ", fib(n-1));\n  return 0;\n}', '2016-10-22 11:51:43', 0, 0),
('inferno', '2a', 4, ' #include<stdio.h>\n int array[] = {23,34,12,17,204,99,16};\n #define TOTAL_ELEMENTS 7\n \n\n  int main()\n  {\n      int d;\n\n      for(d=-1;d <= (TOTAL_ELEMENTS-2);d++)\n          printf("%d\\n",array[d+1]);\n\n      return 0;\n  }\n', '2016-10-22 11:30:38', 2, 1),
('inferno', '3a', 1, '#include<stdio.h> \nint isDivisibleBy7(int num)\n{\nif( num<0 )\nreturn isDivisibleBy7( -1*num );\nelse if( num==0 || num==7 )\nreturn 1;\nelse if( num<10 )\nreturn 0;\nelse\n\nreturn isDivisibleBy7(num/10-2*(num%10));\n}\nint main()\n{\nint num;\nscanf("%d",&num);\nif( isDivisibleBy7(num))\nprintf( "Divisible" );\nelse\nprintf( "Not Divisible" );\nreturn 0;}', '2016-10-22 12:42:04', 4, 1),
('inferno', '3a', 3, '#include<stdio.h>\nint leftRight(int arr[],int n)\n{\n    int visited[n],i;\n    for (i=0; i<n; i++)\n    	visited[i]=0;\n    for ( i=0; i<n; i++)\n    {\n        if (arr[i] < n)\n        {\n            if (visited[arr[i]] != 0&&visited[n-(arr[i]+1)] !=0)\n                visited[arr[i]] = 0;\n            else{\n                visited[n-(arr[i]+1)] = 1;\n                visited[arr[i]]=1;}\n        }\n    }\n    for (i=0; i<n; i++)\n        if (visited[i] = = 0)\n            return 0;\n \n    return 1;\n}\nvoid main()\n{\n    int arr[] = {2, 1, 5, 2, 1, 5};\n    int n =6;\n//   if (leftRight(arr, n) == 1)\n   if(1)\n        printf("YES");\n    else\n        printf("NO");\n    return 0;\n}', '2016-10-22 12:54:40', 0, 0),
('Jayanthu', '1a', 1, '#include <stdio.h>\n#include <stdllib.h>\n\nint max(int a[],int n);\n{\n  int max=0,*i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int a[],int n)\n{\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n  {\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[[a[i]]+1;\n  	}	\n   	for(i=0;i< =bucket;i++)	  \n  {\n	      for(k=b[i];k>0;--k)\n{\n		       	a[++j]=i;\n}\n			  }   	\n	} \n}\n\nint main()\n{\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\n{\nscanf("%d",&a[i]):\nbucket_srt(a,n);\n}\nfor(i=0;i<n;i++)\n{\nprintf(" %d",a[i]);\nreturn 0;\n}\n}', '2016-10-22 07:39:56', 0, 0),
('Jayanthu', '1a', 2, '#include<stdio.h>\n\n\nint main()\n{\n    int a, b, c;\n\n    pritnf("Enter a, b and c respectively: ");\n    scanf("%d,%d,%d",&a,&b,&c);\n\n    printf("Value before swapping");\n    printf("a=%d,b=%d,c=%d",a,b,c);\n\n    cyclicSwap(a, b, c);\n\n    printf("Value after swapping:");\n    printf("a=%d ,b=%d,c=%d",a, b, c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    *temp = *b;\n    *b = *a;\n    *a =*c;\n    *c = *temp;\n}', '2016-10-22 07:36:14', 0, 0),
('Jayanthu', '1a', 4, '#include<stdio.h> \n#include<string.h>\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2,j = n-1;\nint num;\nfor (num=1; num <= n*n;num++)\n{if (i==-1 && j==n) //3rd condition\n{j = n-2:i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j =j-2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generatemagicSquare(n);\n    return 0;\n}', '2016-10-22 07:28:16', 0, 0),
('Jayanthu', '1a', 5, '#include<stdlib.h>\n#include<stdio.h>\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(n);\n{\n    int prevDigit = -1;\n    while (n>0)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n =n/10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (iStepNum(i))\n         {\n            printf("%d ",i);\n}', '2016-10-22 07:31:42', 0, 0),
('kumarteam', '1b', 1, 'void bucketSort(arr[], n)\n{\n    Vector<float> b[n];\n    for (int i=0; i<n; i++);{\n    int bi = n*arr[i]; \n    b[bi]-push_back(arr[i]);\n    } for (int i=0; i<n; i++)\n       sort((b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++)for (int j = 0; j < b[i].size(); j++)\n          arr(index++) = b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ";\n    return 0;\n}\n', '2016-10-22 06:51:19', 0, 0),
('markups', '1a', 1, '#include <stdio.h>\n#include <stdllib.h>\n\nint max(int a[],int n)\n{\n  int max=0,*i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int a[],int n){\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[a[i]]+1;\n  	}	\n   	for(i=0;i< =bucket;i++)	    {\n	      for(k=b[i];k>0;---k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\n scanf("%d",&a[i]);\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', '2016-10-22 07:32:21', 0, 0),
('markups', '1a', 2, '#include<stdio.h>\n\n\nint main()\n{\n    int a, b, c;\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n    printf("Value before swapping:");\n    printf("a = %d \nb = %d \nc = %d\n",a,b,c);\n\n    cyclicSwap(a,b, c);\n\n    printf("Value after swapping:");\n    printf("a = %d \nb = %d \nc = %d",&a, &b, &c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    temp = *a;\n    \n*a=*b;\n    *b= *c;\n    *c = temp;\n}', '2016-10-22 07:39:53', 0, 0),
('markups', '1a', 5, '#include<stdlib.h>\n#include<stdio.h>\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit) != 1))\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n=n\\ 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if(isStepNum(i))\n            printf("%d ",i);\n}', '2016-10-22 07:30:32', 0, 0),
('MAVERICKS', '1b', 2, '#include<bits/stdc++.h>\nusing namespace std;\nvoid cyclicSwap(int *a,int *b,int *c);\nint main()\n{\n    int a, b, c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(&a, &b, &c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    // swapping in cyclic order\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = temp;\n}', '2016-10-22 07:23:43', 7, 1),
('MAVERICKS', '1b', 4, '#inlcude<bits/stdc++.h>\nusing namespace std:\n \nvoid generateSquare(int n)\n{\nint magicSquare[n][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2,j = n-1;\nfor (int num=1; num <= n*n;num++ )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2;i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    cout<<"The Magic Square for n="<<n<<":\\nSum of each row or column :"<<n*(n*n+1)/2<<endl;\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            cout<< magicSquare[i][j]<<" ";\n        cout<<endl;\n    }\n}\n \nint main()\n{\n    int n ;\n    cin>>n;\n    generateSquare(n);\n    return 0;\n}\n', '2016-10-22 07:32:21', 0, 0),
('MAVERICKS', '1b', 5, '#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int n , m ;\n    cin>>n>>m;\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nbool isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit) != 1)\n                 return false;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return true;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n        if (isStepNum(i))\n            cout << i <<" ";\n}', '2016-10-22 07:40:40', 0, 0),
('MAVERICKS', '2b', 1, '#include<bits/stdc++.h>\nusing namespace std;\nint fact(int);\n\nint main()\n{\n    int i;\n    cin>>i;\n   i= fact(i);\n    cout<<i<<endl;\n    return 0;\n}\nint fact(int j)\n{\n    static int s=1;\n    if(j!=1)\n    {\n        s = s*(j);\n        j--;\n        return fact(j);\n    }\nelse\nreturn s;\n}', '2016-10-22 11:15:12', 6, 1),
('MAVERICKS', '2b', 2, '#include<bits/stdc++.h>\nusing namespace std;\n\n#define NIL -1\n#define MAX 100\nint lookup[MAX];\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n  int i;\n  for (i = 0; i < MAX; i)\n    lookup[i] = NIL;\nlookup[0]=1;\nlookup[1]=1;\n}\n/* function for nth Fibonacci number */\nint fib(int n)\n{\nif(n<1)\nreturn 0;\n   if (lookup[n-1] == NIL)\n   {\n     int i;\nfor(i=n-1;lookup[i]=NIL;i--);\n\nfor(i=i+1;i<n;i++)\nlookup[i]=lookup[i-1]+lookup[i-2];\n   }\n   return lookup[n-1];\n}\nint main ()\n{\n  int n;\n  cin>>n;\n  _initialize();\n  cout<<"Fibonacci number is "<<fib(n);\n  return 0;\n}', '2016-10-22 11:39:43', 0, 0),
('MAVERICKS', '2b', 3, '#include<bits/stdc++.h>\nusing namespace std;\n\nint getMedian(int ar1[], int ar2[], int n)\n{\n    int i = 0;  \n    int j = 0; \n    int count;\n    int m1 = -1, m2 = -1;\n \n    for (count = 0; count <(2*n-1); count++)\n    {\n        if (i != n)\n        {\n            m1 = m2;\n            m2 = ar2[i];\n            break;\n        }\n        else if (j != n)\n        {\n            m1 = m2;\n            m2 = ar1[j];\n            break;\n        }\n \n        if (ar1[i] < ar2[j])\n        {\n            m1 = m2;\n            m2 = ar1[j];\n           j++;\n        }\n        else\n        {\n            m2 = m1;  \n            m1 = ar2[i];\n            i++;\n        }\n    }\n \n    return (m1 + m2)/2;\n}\nint main()\n{\n    int n1,n2,ar1[100],ar2[100];\n    int i;\n    cin>>n1;\n    for (i = 0; i < n1; ++i)\n    {\n        cin>>ar1[i];\n    }\n    cin>>n2;\n    for (i = 0; i < n2; ++i)\n    {\n        cin>>ar2[i];\n    }\n\n    if (n1 == n2)\n        printf("Median is %d", getMedian(ar1, ar2, n1));\n    else\n        printf("Doesn''t work for arrays of unequal size");\n    getchar();\n    return 0;\n}', '2016-10-22 11:43:39', 0, 0),
('MAVERICKS', '2b', 4, '\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n  #define TOTAL_ELEMENTS (sizeof(array) / sizeof(array[0]))\n  int array[] = {23,34,12,17,204,99,16};\n\n  int main()\n  {\n      int d;\n\n      for(d=0;d < (TOTAL_ELEMENTS);d++)\n          cout<<array[d]<<endl;\n\n      return 0;\n  }\n\n', '2016-10-22 11:11:54', 1, 1),
('MAVERICKS', '3b', 1, '#include <stdio.h> \n#include<iostream>\nusing namespace std;\nint isDivisibleBy7( int num )\n{\nif(num%7==0)\nreturn 1;\nelse\nreturn 0;\n}\nint main()\n{\nint num,i;\nscanf("%d",&num);\ni= isDivisibleBy7(num);\nif( i )\ncout<< "Divisible" ;\nelse\ncout<< "Not Divisible" ;\nreturn 0;\n}', '2016-10-22 12:26:34', 4, 1),
('MAVERICKS', '3b', 3, '#include<bits/stdc++.h>\nusing namespace std;\n\nvoid main()\n{\n\n        cout << "YES";\n\n    return 0;\n}', '2016-10-22 12:54:22', 0, 0),
('MILU', '1b', 1, '#include<iostream>\n#include<vector>\nvoid bucketSort(int arr[],int n)\n{\n    vector<float> b[n];\n    for (int i=0; i<n; i++);{\n    int bi = n*arr[i]; \n    b[bi]-push_back(arr[i]);\n    } for (int i=0; i<n; i++)\n       sort((b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++)for (int j = 0; j < b[i].size(); j++)\n          arr(index++) = b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ";\n    return 0;\n}\n', '2016-10-22 07:36:13', 0, 0),
('MILU', '1b', 2, 'using namespace std;\n#include<iostream>\nvoid cyclicSwap(int *a,int *b,int *c);\nint main()\n{\n    int a,b,c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(&a,&b,&c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    // swapping in cyclic order\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = temp;\n}', '2016-10-22 07:16:11', 8, 1),
('MILU', '1b', 5, 'using namespace std;\n#include<iostream>\n#include<math>\nvoid displaySteppingNumbers(int n, int m);\nboolean isStepNum(int n);\nint main()\n{\n    int n,m;\n    cin>>n>>m;\n    displaySteppingNumbers(n,m);\n    return 0;\n}\nint isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n       { if (isStepNum(i))\n            cout << i <<" ";\n        }\n}', '2016-10-22 07:27:42', 0, 0),
('MILU', '2b', 1, '#include<bits/stdc++.h>\nusing namespace std;\nint fact(int j);\n\nint main()\n{\n    int i;\n    cin>>i;\n    i=fact(i);\n    cout<<i<<endl;\n    return 0;\n}\nint fact(int j)\n{\n  static int s=1;\n    if(j!=1)\n    {\n        s = s*(j);\n        j--;\n        fact(j);\n    }\n   return s;\n}', '2016-10-22 11:42:37', 6, 1),
('MILU', '2b', 2, '#include<bits/stdc++.h>\nusing namespace std;\n\n#define NIL -1\n#define MAX 100\nint lookup[MAX];\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n  int i;\n  for (i = 0; i < MAX; i++)\n    lookup[i] = NIL;\n}\n/* function for nth Fibonacci number */\nint fib(int n)\n{\n   if (lookup[n]== NIL)\n   {\n      if (n < 1)\n         lookup[n] = n;\n      else\n         lookup[n] = fib(n) + fib(n-1);\n   }\n   return lookup[n+1];\n}\nint main ()\n{\n  int n;\n  cin>>n;\n  _initialize();\n  cout<<"Fibonacci number is "<<fib(n);\n  return 0;\n}', '2016-10-22 11:35:33', 0, 0),
('MILU', '2b', 4, '\n\n#include<iostream>\nusing namespace std;\n int array[] = {23,34,12,17,204,99,16};\n#define TOTAL_ELEMENTS (sizeof(array)/sizeof(array[0]))\n \n  int main()\n  {\n      int d;\n\n      for(d=0;d<(TOTAL_ELEMENTS);d++)\n          cout<<array[d]<<endl;\n\n      return 0;\n  }\n\n', '2016-10-22 11:20:38', 4, 1),
('miracle', '1a', 1, '#include <stdio.h>\n#include <stdllib.h>\n\nint max(int a[] ,int n)\n{\n  int max=0,i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_srt(int a[] ,int n)\n{\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[[a[i]]+1];\n  	}	\n   	for(i=0;i< =bucket;i++)	   \n        {\n	      for(k=b[i];k>0;--k)\n               {\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main()\n{\n   int i,n;\n   scanf("%d",&n);\n \n   for(i=0;i<n;i++)\n       scanf("%d",a[i]):\n   bucket_srt(a,n);\n   for(i=0;i<n;i++)\n        printf(" %d",a[i]);\nreturn 0;\n}\n', '2016-10-22 07:30:28', 0, 0),
('miracle', '1a', 2, '#include<stdio.h>\n\n\nvoid main()\n{\n    int a, b, c;\n\n    pritnf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n\n    printf("Value before swapping:");\n    printf("a = %d b = %d c = %d",a,b,c);\n\n    cyclicSwap(&a,& b, &c);\n\n    printf("Value after swapping:");\n    printf("a = %d b = %d c = %d",a, b, c);\n\n    \n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    temp = *a;\n    *a = *b;\n    *b =*c;\n    *c = temp;\n}', '2016-10-22 07:41:04', 0, 0),
('muhsinayak', '1a', 1, '#include <stdio.h>\n#include <stdllib.h>\n\nint max(int a[30],int n)\n{\n  int max=0,i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int a[30],int n){\n  int bucket=max(a,n);\n  int b[30],i,k,j=0;=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[a[i]]+1;\n  	}	\n   	for(i=0;i<=bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nint a[30];\nscanf("%d",&n);\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]);\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', '2016-10-22 07:37:20', 0, 0),
('muhsinayak', '1a', 2, '#include<stdio.h>\n#include<stdlib.h>\nvoid cyclicSwap(int*,int*,int*);\nint main()\n{\n    int a,b,c;\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n\n    printf("Value before swapping:");\n    printf("a = %d b = %d c = %d ",a,b,c);\n\n    cyclicSwap(&a,&b,&c);\n\n    printf("Value after swapping:");\n    printf("a = %d b = %d c = %d",a,b,c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = temp;\n}', '2016-10-22 07:27:17', 0, 0),
('muhsinayak', '1a', 5, '#include<stdlib.h>\n#include<stdio.h>\n#include<math.h>\nint isStepNum(int);\nvoid displaySteppingNumbers(int, int);\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(int n)\n{  int curDigit;\n    int prevDigit = -1;\n    while (n)\n    {\n       curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n/= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\nint i;\n    for (i=n; i<=m; i++)\n{\n        if (isStepNum(i))\n            printf("%d ",i);\n}\n}', '2016-10-22 07:34:08', 7, 1),
('muhsinayak', '2a', 1, '#include<stdio.h>\n#include<stdlib.h>\nvoid fact(int*);\n\nint main()\n{\n    int i;\n    scanf("%d",&i);\n    fact(&i);\n    printf("%d\\n", i);\n    return 0;\n}\nvoid fact(int *j)\n{\n    static int s=0;\nif(s==0)s=1;\n    if((*j)!=1)\n    {\n        s = s*(*j);\n        (*j)= (*j)-1;\n         fact(j);\n    }\nelse *j=s;\n}', '2016-10-22 11:38:20', 5, 1),
('muhsinayak', '2a', 2, '#include<stdio.h>\n#include<stdlib.h>\n#define NIL -1\n#define MAX 100\nint lookup[MAX];\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n  int i;\n  for (i = 0; i < MAX; i--)\n    lookup[i] = NIL;\n}\n/* function for nth Fibonacci number */\nint fib(int n)\n{\n   if (lookup[n] == NIL)\n   {\n      if (n ==1)\n        { lookup[n] = 0;}\n     if (n ==2)\n        { lookup[n] = 1;}\n      else\n         lookup[n] = fib(n-1) + fib(n-2);\n   }\n   return lookup[n];\n}\nint main ()\n{\n  int n;\n  scanf("%d",&n);\n  _initialize();\n  printf("Fibonacci number is %d ", fib(n));\n  return 0;\n}', '2016-10-22 11:52:30', 0, 0),
('muhsinayak', '2a', 4, ' #include<stdio.h>\n #include<stdlib.h>\n  #define TOTAL_ELEMENTS 7\n  int array[] = {23,34,12,17,204,99,16};\n\n  int main()\n  {\n      int d;\n\n      for(d=-1;d <= (TOTAL_ELEMENTS-2);d++)\n          printf("%d\\n",array[d+1]);\n\n      return 0;\n  }\n', '2016-10-22 11:33:58', 1, 1),
('muhsinayak', '3a', 1, '#include <stdio.h>\n #include<stdlib.h>\nint isDivisibleBy7( int num )\n{\nif( num < 0 )\nreturn isDivisibleBy7( --num );\nif( num = = 0 | | num = = 7 )\nreturn 1;\nif( num > 10 )\nreturn 0;\nreturn isDivisibleBy7( num * 10 + 2 / ( num + num *10 ) - 10 ) );\n}\nint main(){\nint num;\nscanf("%d",&num);\nif( isDivisibleBy7(num ) )\nprintf( "Divisible" );\nelse\nprintf( "Not Divisible" );\nreturn 0;}', '2016-10-22 12:47:55', 0, 0),
('muhsinayak', '3a', 2, '#include <stdio.h>\n#include <stdlib.h>\nstruct node{\n    int data;\n    struct node *next;\n};\n \nvoid deleteNode(node *head, node *n){\nstruct node prev = head;\n    if(head == n){\n        if(head->next== NULL){\n            printf("There is only one node.");\n            return;\n        }\n        head->data = head->next->data;\n        head->next = head->next->next;\n        free(n);	// free memory\n        return;\n    }\n    \n    while(prev->next != NULL && prev->next != n)\n        prev = prev->next;\n    if(prev->next == NULL){\n        printf("\\n Given node is not present in Linked List");\n        return;\n    }\n      prev->next = prev->next->next;\n    free(n);\n    return; \n}\n \n/* Utility function to insert a node at the begining */\nvoid push(struct node **head_ref, int new_data)\n{\n    struct node *new_node = (struct node*)malloc(sizeof(struct node));\n    new_node->data = new_data;\n    new_node->next = *head_ref;\n    *head_ref = new_node;\n}\n \n/* Utility function to print a linked list */\nvoid printList(struct node *head)\n{\n    while(head!=NULL)\n    {\n        printf("%d ",head->data);\n        head=head->next;\n    }\n    printf("\\n");\n}\n \nint main(){\n    struct node *head = NULL;\n    push(&head,3);\n    push(&head,2);\n    push(&head,6);\n    push(&head,5);\n    push(&head,11);\n    push(&head,10);\n    push(&head,15);\n    push(&head,12);\n    printf("Given Linked List: ");\n    printList(head);\n    /* Let us delete the node with value 10 */\n    printf("\\nDeleting node %d: ", head->next->next->data);\n    deleteNode(head, head->next->next);\n    printf("\\nModified Linked List: ");\n    printList(head);\n    /* Let us delete the the first node */\n    printf("\\nDeleting first node ");\n    deleteNode(head, head);\n    printf("\\nModified Linked List: ");\n    printList(head);\n    return 0;\n}\n\n\n\n', '2016-10-22 12:54:08', 0, 0),
('ni', '3b', 1, '#include<bits/stdc++.h>\nusing namespace std;\nint isDivisibleBy7( int num ){\nif( num < 0 )\nreturn isDivisibleBy7( -num );\nif( num == 0 || num == 7 )\nreturn 1;\nif( num < 10 )\nreturn 0;\nreturn isDivisibleBy7( num / 10 - 2 * ( num - num / 10 * 10 ) );}\nint main(){\nint num;\nscanf("%d",&num);\nif( isDivisibleBy7(num ) )\ncout<< "Divisible" ;\nelse\ncout<< "Not Divisible" ;\nreturn 0;}', '2016-10-22 10:43:02', 5, 1),
('ni', '3b', 2, '#include <iostream>\n#include <stdlib.h>\nusing namespace std;\n\nclass node{\n    public:\n    int data;\n    node *next;\n};\n void deleteNode( node *head, node *n)\n    {\n        // When node to be deleted is head node\n        if(head == n)\n        {\n            if(head->next == NULL)\n            {\n                cout << "There is only one node. The list can''t be made empty ";\n                return;\n            }\n     \n            /* Copy the data of next node to head */\n            head->data = head->next->data;\n     \n            // store address of next node\n            n = head->next;\n     \n            // Remove the link of next node\n            head->next = head->next->next;\n     \n            // free memory\n            free(n);\n     \n            return;\n        }\n     \n     \n        // When not first node, follow the normal deletion process\n     \n        // find the previous node\n        node *prev = head;\n        while(prev->next != NULL && prev->next != n)\n            prev = prev->next;\n     \n        // Check if node really exists in Linked List\n        if(prev->next == NULL)\n        {\n            cout << "\\n Given node is not present in Linked List";\n            return;\n        }\n     \n        // Remove node from Linked List\n        prev->next = prev->next->next;\n     \n        // Free memory\n        free(n);\n     \n        return; \n    }\n \n/* Utility function to insert a node at the begining */\nvoid push( node **head_ref, int new_data)\n{\n     node *new_node = ( node *)malloc(sizeof( node));\n    new_node->data = new_data;\n    new_node->next = *head_ref;\n    *head_ref = new_node;\n}\n \n/* Utility function to print a linked list */\nvoid printList( node *head)\n{\n    while(head!=NULL)\n    {\n        cout << head->data;\n        head=head->next;\n    }\n    cout << "\\n";\n}\n \nint main(){\n     node *head = NULL;\n    push(&head,3);\n    push(&head,2);\n    push(&head,6);\n    push(&head,5);\n    push(&head,11);\n    push(&head,10);\n    push(&head,15);\n    push(&head,12);\n     cout << "Given Linked List: ";\n    printList(head);\n    /* Let us delete the node with value 10 */\n    cout << "\\nDeleting node :" << head->next->next->data;\n    deleteNode(head, head->next->next);\n    cout << "\\nModified Linked List: ";\n    printList(head);\n    /* Let us delete the the first node */\n     cout << "\\nDeleting first node ";\n    deleteNode(head, head);\n    cout << "\\nModified Linked List: ";\n    printList(head);\n    return 0;\n}\n\n\n\n', '2016-10-22 11:28:35', 14, 1),
('ni', '3b', 3, '#include<bits/stdc++.h>\nusing namespace std;\n bool leftRight(int arr[],int n)\n{\n    int visited[n] ;\n    for (int i=0; i<n; i++)\n    	visited[i]=0;\n    for (int i=0; i<n; i++)\n    {\n        if (arr[i] < n)\n        {\n            if (visited[arr[i]] == 0)\n                visited[arr[i]] = 1;\n            else\n                visited[n-arr[i]-1] = 1;\n        }\n    }\n    for (int i=0; i<n; i++)\n        if (visited[i] == 0)\n            return false;\n \n    return true;\n}\nint main()\n{\n    int arr[] = {2, 1, 5, 2, 1, 5};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    if (leftRight(arr, n) == true)\n        cout << "YES";\n    else\n        cout << "NO";\n    return 0;\n}', '2016-10-22 10:52:19', 4, 1),
('PSYKOS!!!', '1b', 1, 'void bucketSort(arr[], n)\n{\n    Vector<float> b[n];\n    for (int i=0; i<n; i++)\n    {\n    int bi = n*arr[i]; \n    b[bi]-push_back(arr[i]);\n    } for (int i=0; i<n; i++)\n       sort(b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++)\n\n    for (int j = 0; j < b[i].size(); j++)\n          arr(index++) = b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr[], n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ";\n    return 0\n}\n', '2016-10-22 07:25:16', 0, 0),
('PSYKOS!!!', '1b', 2, '#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int a, b, c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a,b,c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(a, b, c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    // swapping in cyclic order\n    temp = *b;\n   *b = *a;\n    *a = *c;\n    *c = temp;\n}', '2016-10-22 07:39:56', 0, 0),
('PSYKOS!!!', '1b', 4, '#inlcude<bits/stdc++.h>\nusing namespace std;\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2,j = n-1;\nfor (int num=1; num <= n*n )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2,i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\n{\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n}\n    cout<<"The Magic Square for n="<<n<<":\\nSum of each row or column :"<<n*(n*(n+1))/2<<endl;\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            cout<< magicSquare[i][j]<<" ";\n        cout<<endl;\n    }\n}\n \nint main()\n{\n    int n;\n    cin>>n;\n    generateSquare(n);\n    return 0;\n}\n', '2016-10-22 07:33:13', 0, 0),
('PSYKOS!!!', '1b', 5, '#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int n , m ;\n    cin>>n>>m;\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nbool isStepNum(n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return false;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return true;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n        if (isStepNum(i))\n            cout << i <<" ";\n}', '2016-10-22 07:36:06', 0, 0),
('Pwnage', '1b', 1, 'void bucketSort(float arr[],int n)\n{\n    vector<float> b[n];\n    for (int i=0; i<n; i++)\n    {\n         b[i] = n*arr[i]; \n         b[i]->push_back(arr[i]);\n    } \n    for (int i=0; i<n; i++)\n       sort(b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++)\nfor (int j = 0; j < b[i].size(); j++)\n          arr[index++] = b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ";\n    return 0;\n}\n', '2016-10-22 08:22:33', 0, 0),
('Pwnage', '1b', 2, '#include<bits/stdc++.h>\nusing namespace std;\nvoid cyclicSwap(int *a,int *b,int *c);\n\nint main()\n{\n    int a, b, c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(&a,&b,&c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    // swapping in cyclic order\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = temp;\n}', '2016-10-22 08:37:09', 7, 1),
('Pwnage', '1b', 5, '#include<bits/stdc++.h>\nusing namespace std;\n\nvoid displayStepingNumbers(int n, int m);\n\nint main()\n{\n    int n , m ;\n    cin>>n>>m;\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nbool isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n            if (abs(prevDigit - curDigit) != 1)\n                 return false;\n        \n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return true;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n        if (isStepNum(i))\n            cout << i <<" ";\n}', '2016-10-22 08:42:12', 0, 0),
('Pwnage', '2b', 1, '#include<bits/stdc++.h>\nusing namespace std;\nvoid fact(int);\n\nint main()\n{\n    int i;\n    cin>>i;\n    i=fact(i);\n    cout<<i<<endl;\n    return 0;\n}\nint fact(int j)\n{\nint f=1;    \n    \n    for(;j>1;--j)\n{f*=j;}\nreturn f;\n}', '2016-10-22 11:44:55', 0, 0),
('Pwnage', '2b', 2, '#include<bits/stdc++.h>\nusing namespace std;\n\n#define NIL -1\n#define MAX 100\nint lookup[MAX];\n/* Function to initialize NIL values in lookup table */\nvoid _initialize()\n{\n  int i;\n  for (i = 1; i <= MAX; i++)\n    lookup[i] = NIL;\n}\n/* function for nth Fibonacci number */\nint fib(int n)\n{\n   if (lookup[n] == NIL)\n   {\n      if (n <= 1)\n         lookup[n] = n;\n      else\n         lookup[n] = fib(n-1) + fib(n-2);\n   }\n   return lookup[n];\n}\nint main ()\n{\n  int n;\n  cin>>n;\n  _initialize();\n  cout<<"Fibonacci number is "<<fib(n);\n  return 0;\n}', '2016-10-22 11:35:08', 5, 1),
('Pwnage', '2b', 4, '\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n  #define TOTAL_ELEMENTS 7\n  int array[] = {23,34,12,17,204,99,16};\n\n  int main()\n  {\n      int d;\n\n      for(d=-1;d <= (TOTAL_ELEMENTS-2);d++)\n          cout<<array[d+1]<<endl;\n\n      return 0;\n  }\n\n', '2016-10-22 11:27:39', 1, 1),
('Pwnage', '3b', 1, '#include <bits/stdc++.h>\nusing namespace std; \nint isDivisibleBy7( int num ){\nif( num < 0 )\nreturn isDivisibleBy7( -num );\nif( num == 0 | | num == 7 )\nreturn 1;\nif( num > 10 )\nreturn isDivisibleBy7( (num/10) - 2*(num%10) );\nreturn 0;}\nint main(){\nint num;\ncin>>num;\nif( isDivisibleBy7(num ) )\ncout<< "Divisible" ;\nelse\ncout<< "Not Divisible" ;\nreturn 0;}', '2016-10-22 12:51:37', 0, 0),
('Pwnage', '3b', 2, '#include <iostream>\n#include <stdlib.h>\nusing namespace std;\nclass node{\n    public:\n    int data;\n    node *next;\n};\n \nvoid deleteNode(node *head, node *n){\n    if(head == n){\n        if(head->next->next == NULL){\n            cout << "There is only one node. The list can''t be made empty ";\n            return;\n        }\n        head->data = head- >next->data;\n        n = head->next;\n        head->next = head-next->next;\n        free(n);	// free memory\n        return;\n    }\n    node prev = head;\n    while(prev->next != NULL && prev->next != n)\n        prev = prev->next;\n    if(prev->next == NULL){\n        cout << "\\n Given node is not present in Linked List";\n        return;\n    }\n     prev->next = n->next;\n    free(n);\n    return; \n}\n \n/* Utility function to insert a node at the begining */\nvoid push( node *head_ref, int new_data)\n{\n     node *new_node = new node;\n    new_node->data = new_data;\n    new_node->next = head_ref;\n    head_ref = new_node;\n}\n \n/* Utility function to print a linked list */\nvoid printList( node *head)\n{\n    while(head!=NULL)\n    {\n        cout << head->data;\n        head=head->next;\n    }\n    cout << "\\n";\n}\n \nint main(){\n     node *head = NULL;\n    push(&head,3);\n    push(&head,2);\n    push(&head,6);\n    push(&head,5);\n    push(&head,11);\n    push(&head,10);\n    push(&head,15);\n    push(&head,12);\n     cout << "Given Linked List: ";\n    printList(&head);\n    /* Let us delete the node with value 10 */\n    cout << "\\nDeleting node :" << head->next->next->data;\n    deleteNode(&head, head->next->next);\n    cout << "\\nModified Linked List: ";\n    printList(&head);\n    /* Let us delete the the first node */\n     cout << "\\nDeleting first node ";\n    deleteNode(&head, &head);\n    cout << "\\nModified Linked List: ";\n    printList(&head);\n    return 0;\n}\n\n\n\n', '2016-10-22 12:53:36', 0, 0),
('rahman', '1b', 1, 'void bucketSort(arr[], n)\n{\n    Vector<float> b[n];\n    for ( i=0; i<n; i++)\n    int bi = n*arr[i]; \n    b[bi]-push_back(arr[i]);\n    }\n for (int i=0; i<n; i+)\n       sort((b[i].begin(), b[i].end)); \n     int index = 0;\n    for (int i = 0; i < n; )for (int j = 0; j < b[i].size(); j+)\n          arr(index+) = b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ;\n    return 0;\n}\n', '2016-10-22 08:08:35', 0, 0),
('rahman', '1b', 2, '#include<studio.h>\nusing namespace std;\n\nint main()\n{\n    int a. b, c:\n\n    cout<<"Enter a, b and c respectively: ";\n    int=a,b,c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = <<a<<"\\nb = "<<b<<"\\nc = <<c;\n\n    cyclicSwap(a, b, c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return O;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    // swapping in cyclic order\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = temp;\n}', '2016-10-22 08:08:38', 0, 0),
('rahman', '1b', 3, '\n#include<bits/stdc++.h>\nusing namespace std;\n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], bool splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == false && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\ncout<<"Vertex   Distance from Source\\n";\nfor (int i = 0; i < V; i ++)\ncout<<i<<"		 "<<dist[i]<<"\\n";\n// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nbool sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = false;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = true;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', '2016-10-22 08:08:18', 0, 0),
('rahman', '1b', 4, '#inlcude<bits/stdc++.h>\nusing namespace std:\n \nvoid generateSquare(int* n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare);\nint i = n/2;j = n-1;\nfor (int num=1; num <= n*n);\nif (i==-1 && j==n) //3rd condition\n{j = n-2:i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j =- 2;\ni++;\ncontinue;\n}\nelse()\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n{\n    cout<<"The Magic Square for n="<<n<<":\\"nSum of each row or column :"<<n*(n=n+1)/2<<endl;\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            cout<< magicSquare[i][j]<<" ";\n        cout<<endl;\n    }\n}\n \nint main()\n{\n    int n ;\n    cin>>n;\n    generateSquare (n);\n    return 0;\n}\n', '2016-10-22 08:08:15', 0, 0);
INSERT INTO `submissions` (`teamname`, `stageid`, `questionid`, `ans`, `time`, `changes`, `accept`) VALUES
('rahman', '1b', 5, '#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int n=1 , m=2 ;\n    cin>>n>>m;\n    displaySteppingNumbers(1, 2);\n    return 0;\n}\nbool isStepNum(n=1)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit) != 1)\n                 return false;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return true;\n}\nvoid displayStepingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (iStepNum(i))\n            cout << i <<" ";\n}', '2016-10-22 08:07:53', 0, 0),
('rofix', '1a', 1, '#include <stdio.h>\n#include <stdlib.h>\n\nint max(inta[],int n)\n{\n  int max=0,*i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(inta[],int n)\n{\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b(a[i])=b([a[i]++);\n  	}	\n   	for(i=0;i< =bucket;i++)	  \n  {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  	\n	} \n}\n\nint main()\n{\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]);\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', '2016-10-22 07:31:03', 0, 0),
('rofix', '1a', 2, '#include<stdio.h>\n\n\nvoid main()\n{\n    int a, b, c;\n\n    pritnf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n\n    printf("Value before swapping");\n    printf("a = %d, b = %d ,c = %d",a,b,c);\n\n    cyclicSwap(&a,& b,& c);\n\n    printf("Value after swapping:");\n    printf("a = %d, b = %d ,c = %d",a, b, c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    temp = *b;\n    *b = *a;\n    *a =* c;\n    *c = temp;\n}', '2016-10-22 07:40:11', 0, 0),
('rofix', '1a', 4, '#include<stdio.h> \n#include<string.h>\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2,j = n-1;\nint num;\nfor (num=1; num <= n*n; )\n{\nif (i==-1 && j==n) //3rd condition\n{\nj = n-2:i = 0;\n    }\nelse\n{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{\nj -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', '2016-10-22 07:30:35', 0, 0),
('rofix', '1a', 5, '#include<stdlib.h>\n#include<stdio.h>\nint main()\n{\n    int n , m ;\n    scanf("%d%d",n,m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n =n/ 10;\n    }\n    return 0;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (StepNum(i))\n            printf("%d ",i);\n}', '2016-10-22 07:30:27', 0, 0),
('rofl', '1a', 1, '#include<stdio.h>\n#include<stdlib.h>\n\nint max(int[] a,int n)\n{\n  int max=0,*i;\n  for(i=0;i<n;i++)\n  {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n	    }\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int[] a,int n){\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[a[i]]+1;\n  	}	\n   	for(i=0;i<=bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++k]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",a[i]);\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf("%d",a[i]);\nreturn 0;\n}\n', '2016-10-22 07:29:53', 0, 0),
('rofl', '1a', 2, '#include<stdio.h>\n\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n    int *temp;\n    *temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = *temp;\n}\n\nint main()\n{\n    int a,b,c;\n    printf("Enter a, b and c respectively:");\n    scanf("%d %d %d",a,b,c);\n    printf("Value before swapping:");\n    printf("a = %d b = %d c = %d",a,b,c);\n    cyclicSwap(a,b,c);\n    printf("Value after swapping:");\n    printf("a = %d b = %d c = %d",a,b,c);\n    return 0;\n}\n', '2016-10-22 07:39:09', 0, 0),
('SHAN', '1a', 1, '#include <stdio.h>\n#include <stdllib.h>\n\nint max(int[] a,int n)\n{\n  int max=0,*i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int[] a,int n){\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[[a[i]]+1;\n  	}	\n   	for(i=0;i< =bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]):\nbucket_srt(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', '2016-10-22 07:52:47', 0, 0),
('SHAN', '1a', 2, '#include<stdio.h>\n\n\nint main()\n{\n    int a. b, c:\n\n    pritnf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",a,b,c);\n\n    printf("Value before swapping:\\n");\n    printf("a = %d\\nb = %d\\nc = %d\\n",a,b,c);\n\n    cyclicSwap(a, b, c);\n\n    printf("Value after swapping:\\n");\n    printf("a = %d \\nb = %d\\nc = %d\\n",a, b, c);\n\n    return (0);\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    temp = *b;\n    *b = *a;\n    *a = c;\n    *c = temp;\n}', '2016-10-22 08:07:01', 0, 0),
('solo', '1b', 1, 'void bucketSort(arr[], n)\n{:\n    Vector<float> b[n];\n    for (int i=0; i<n; i++);{\n    int bi = n*arr[bi]; \n    b[bi]-push_back(arr[i]);\n    } for (int i=0; i<n; i++)\n       sort((b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++)for (int j = 0; j < b[i].size(); j++)\n          arr(index++) = b[i][j];\n}\n\n\nint main()\n{float:\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ";\n    return 0;\n}\n', '2016-10-22 07:43:30', 0, 0),
('solo', '1b', 2, '#include<bits/stdc++.h>\nusing namespace std;\n\nint main():\n{while:\n    int a. b, c:\n\n    cuot<<"Enter a, b and c respectively: ";\n    cin>>a,b,c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c";\n\n    cyclicSwap(a, b, c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c";\n\n    return O;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    // swapping in cyclic order\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = temp;\n}', '2016-10-22 07:44:55', 0, 0),
('solo', '1b', 3, '\n#include<bits/stdc++.h>\nusing namespace std;\n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n/ the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], bool splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++)\nif (sptSet[v] == false && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\ncout<<"Vertex   Distance from Source\\n";\nfor (int i = 0; i < V; i ++)\ncout<<i<<"		 "<<dist[i]<<"\\n";\n// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nbool sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = false;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = true;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', '2016-10-22 07:47:31', 0, 0),
('solo', '1b', 5, '#include<bits/stdc++>\nusing namespace std;\n\n\nbool isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit== -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return false;\n        }\n        prevDigit = curDigit;\n        n = n/10;\n    }\n    return true;\n}\nvoid displayStepingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if ( isStepNum(i))\n            cout<<i<<" ";\n}\nint main()\n{\n    int n,m ;\n    cin>>n>>m;\n    displayStepingNumbers(n, m);\n    return 0;\n}', '2016-10-22 08:04:36', 0, 0),
('soorya_alka', '1b', 1, '#include<bits/stdc++.h>\n#include<vector.h>\nusing namespace std;\nvoid bucketSort(arr[], n)\n{\n    vector<float> b[n];\n    for (int i=0; i<n; i++){\n    int bi = n*arr[i]; \n    b[bi]-push_back(arr[i]);\n    } \nfor (int i=0; i<n; i++)\n       sort((b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < b[i].size(); j++)\n          arr[index++] = b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ";\n    return 0;\n}\n', '2016-10-22 07:30:30', 0, 0),
('soorya_alka', '1b', 2, '#include<bits/stdc++.h>\nusing namespace std;\nvoid cyclicSwap(int *,int *,int *);\nint main()\n{\n    int a, b, c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(&a,&b,&c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    // swapping in cyclic order\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c =temp;\n}', '2016-10-22 07:32:30', 7, 1),
('soorya_alka', '1b', 4, '#include<bits/stdc++.h>\nusing namespace std;\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2;j = n-1;\nfor (int num=1; num <= n*n; )\n{\nif (i==-1 && j==n) //3rd condition\n{\n    j = n-2;\n    i = 0;\n }\nelse\n{\n    if(j = = n)\n       j = 0;\n    if (i < 0)\n        i=n-1;\n }\nif (magicSquare[i][j]) //2nd condition\n{\n     j -= 2;\n     i++;\n    continue;\n}\nelse\n   magicSquare[i][j] = num++; //set number\n j++; \n i--; //1st condition\n}\n    cout<<"The Magic Square for n="<<n<<":\\nSum of each row or column :"<<n*(n*n+1)/2<<endl;\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            cout<< magicSquare[i][j]<<" ";\n        cout<<endl;\n    }\n}\n \nint main()\n{\n    int n ;\n    cin>>n;\n    generateSquare (n);\n    return 0;\n}\n', '2016-10-22 07:38:01', 0, 0),
('soorya_alka', '1b', 5, '#include<bits/stdc++.h>\nusing namespace std;\nvoid displayStepingNumbers(int n, int m);\nbool isStepNum(int);\nint main()\n{\n    int n , m ;\n    cin>>n>>m;\n    displayStepingNumbers(n, m);\n    return 0;\n}\nbool isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n%10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if ((abs(prevDigit - curDigit)) != 1)\n                 return false;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return true;\n}\nvoid displayStepingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n        if (isStepNum(i))\n            cout << i <<" ";\n}', '2016-10-22 07:36:23', 5, 1),
('SpEcHiDe', '1a', 1, '#include <stdio.h>\n#include <stdllib.h>\n\nint fmax(int[] a,int n)\n{\n  int max=0,i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int[] a,int n){\n  int bucket=fmax(a,n);\nint b[bucket] = { 0 };\n  int i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[[a[i]]+1;\n  	}	\n   	for(i=0;i< =bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint *a = (int*) malloc(n*sizeof(int));\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]):\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', '2016-10-22 07:26:43', 0, 0),
('SpEcHiDe', '1a', 2, '#include<stdio.h>\n\nvoid cyclicSwap(int *a,int *b,int *c);\n\nint main()\n{\n    int a, b, c;\n\n    pritnf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n\n    printf("Value before swapping:");\n    printf("a = %d b = %d c = %d",a,b,c);\n\n    cyclicSwap(a, b, c);\n\n    printf("Value after swapping:");\n    printf("a = %d b = %d c = %d",a, b, c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = temp;\n}', '2016-10-22 07:17:10', 0, 0),
('SpEcHiDe', '1a', 3, '\n#include <stdio.h>\n#include <limits.h>  \n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], int splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(v = 0; v < V; v++){\nif (sptSet[v] == 0 && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index; }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\nprintf("Vertex   Distance from Source");\nfor (int i = 0; i < V; i ++)\nprintf("%d 		 %d", i, dist[i]);}// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nint sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = 0;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = 1;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX && dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', '2016-10-22 07:19:25', 0, 0),
('SpEcHiDe', '1a', 4, '#include<stdio> \n#include<string>\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2,j = n-1;\nint num;\nfor (num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2,i = 0;\n    }\nelse{\nif(j == n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare(n);\n    return 0;\n}', '2016-10-22 07:29:41', 0, 0),
('SpEcHiDe', '1a', 5, '#include<stdlib.h>\n#include<stdio.h>\nvoid displaySteppingNumbers(int n, int m);\nint isStepNum(int n);\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (isStepNum(i) == 0)\n            printf("%d ",i);\n}', '2016-10-22 07:22:42', 0, 0),
('stark', '1b', 1, '#include<iostream.h>\n#include<limits.h>\nvoid bucketSort(float arr[], int n)\n{\n    float b[INT_MAX][INT_MAX];\n    for (int i=0; i<n; i++);\n    {\n      int bi = n*arr[i]; \n      b[bi]-push_back(arr[i]);\n    }\n    for (int i=0; i<n; i++)\n      sort(b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++)\n      for (int j = 0; j < b[i].size(); j++)\n          arr[index++] = b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ";\n    return 0;\n}\n', '2016-10-22 07:40:05', 0, 0),
('stark', '1b', 2, '\n#include<iostream.h>\nusing namespace std;\n\nvoid cyclicSwap(int *a, int *b, int *c)\n{\n\n    int *temp;\n\n    // swapping in cyclic order\n    temp = b;\n    *b = *a;\n    *a = *c;\n    *c = *temp;\n}\n\nint main()\n{\n    int a, b, c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(&a, &b, &c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}\n', '2016-10-22 07:26:14', 0, 0),
('starz', '1a', 1, '#include <stdio.h>\n#include <stdllib.h>\n\nint max(int[] a,int n)\n{\n  int max=0,i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int[] a,int n){\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[[a[i]]+1;\n  	}	\n   	for(i=0;i<=bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]):\nbucket_srt(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', '2016-10-22 07:41:23', 0, 0),
('starz', '1a', 2, '#include<stdio.h>\n\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = temp;\n}\nint main()\n{\n    int a, b, c;\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n\n    printf("Value before swapping:");\n    printf("a = %d, b = %d, c = %d",a,b,c);\n\n    cyclicSwap(&a, &b,&c);\n\n    printf("Value after swapping:");\n    printf("a = %d ,b = %d, c = %d",a, b, c);\n\n    return 0;\n}\n\n', '2016-10-22 07:39:48', 0, 0),
('starz', '1a', 5, '#include<stdlib.h>\n#include<stdio.h>\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit)!= 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n=10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (iStepNum(i))\n            printf("%d ",i);\n}', '2016-10-22 07:41:20', 0, 0),
('starz', '2a', 1, '#include<stdio.h>\nvoid fact(int *);\n\nint main()\n{\n    int i;\n    scanf("%d",&i);\n    fact(&i);\n    printf("%d\\n", i);\n    return 0;\n}\nvoid fact(int *j)\n{\n    static int s=1;\n    if(j!=1)\n    {\n        s = s**j;\n        *j--;\n       fact(&j);\n   }\n}', '2016-10-22 11:29:42', 0, 0),
('starz', '2a', 3, '#include <stdio.h>\n \nint getMedian(int ar1[], int ar2[], int n)\n{\n    int i = 0;  \n    int j = 0; \n    int count;\n    int m1 = -1, m2 = -1;\n \n    for (count = 0; count <= 2*n; count++)\n    {\n        if (i != n)\n        {\n            m1 = m2;\n            m2 = ar2[0];\n            break;\n        }\n        else if (j != n)\n        {\n            m1 = m2;\n            m2 = ar1[0];\n            break;\n        }\n\n \n      if (ar1[i] < ar2[j])\n        {\n            m1 = m2;\n            m2 = ar1[i];\n            j++;\n        }\n        else\n        {\n            m2 = m1;  \n            m1 = ar2[j];\n            i++;\n        }\n    }\n \n    return (m1 + m2)/2;\n}\nint main()\n{\n    int n1,n2,ar1[100],ar2[100];\n    int i;\n    scanf("%d",&n1);\n    for (i = 0; i < n1; ++i)\n    {\n        scanf("%d",&ar1[i]);\n    }\n    scanf("%d",&n2);\n    for (i = 0; i < n2; ++i)\n    {\n        scanf("%d",&ar2[i]);\n    }\n\n    if (n1 == n2)\n        printf("Median is %d", getMedian(ar1, ar2, n1));\n    else\n        printf("Doesn''t work for arrays of unequal size");\n    getchar();\n    return 0;\n}', '2016-10-22 11:45:23', 0, 0),
('starz', '2a', 4, ' #include<stdio.h>\n\n  #define TOTAL_ELEMENTS (sizeof(array) / sizeof(array[0]))\n  int array[] = {23,34,12,17,204,99,16};\n\n  int main()\n  {\n      int d;\n\n      for(d=-1;d <= (TOTAL_ELEMENTS);d++)\n          printf("%d\\n",array[d+1]);\n\n      return 0;\n  }\n', '2016-10-22 11:45:27', 0, 0),
('STNEO', '1b', 2, '#include<bits/stdc++.h>\n#include<iostream.h>\nusing namespace std;\n\nint main()\n{\n    int a,b,c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(&a,&b,&c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    // swapping in cyclic order\n    temp =*b;\n *b =*a;\n    *a = *c;\n    *c =temp;\n}', '2016-10-22 07:40:06', 0, 0),
('STNEO', '1b', 5, '#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int n , m ;\n    cin>>n>>m;\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nbool isStepNum(n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n%10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit-curDigit)!=1)\n                 return false;\n        }\n        prevDigit=curDigit;\n        n/=10;\n    }\n    return true;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n        if (isStepNum(i))\n            cout << i <<" ";\n}', '2016-10-22 07:30:29', 0, 0),
('TEAM JJ', '1a', 1, '#include <stdio.h>\n#include <stdlib.h>\n\nint max(int a[] ,int n)\n{\n  int max=0,i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int a[],int n){\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[a[i]]+1;\n  	}	\n   	for(i=0;i<=bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]);\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', '2016-10-22 07:26:18', 0, 1),
('TEAM JJ', '1a', 2, '#include<stdio.h>\n#include<stdlib.h>\n\nint main()\n{\n    int a, b, c;\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d %d %d",&a,&b,&c);\n\n    printf("Value before swapping:\n");\n    printf("a = %d \nb = %d \nc = %d\n",a,b,c);\n\n    cyclicSwap(&a, &b, &c);\n\n    printf("Value after swapping:\n");\n    printf("a = %d \nb = %d \nc = %d",a, b, c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    temp = b;\n     b = a;\n     a = c;\n     c = temp;\n}', '2016-10-22 07:26:55', 0, 0),
('TEAM JJ', '1a', 5, '#include<stdlib.h>\n#include<stdio.h>\n#include<math.h>\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(int n)\n{\n    int prevDigit = -1;\n    while(n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return 0;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    int i;\n    for(i=n; i<=m; i++);\n        if(isStepNum(i))\n            printf("%d ",i);\n}', '2016-10-22 07:40:08', 0, 0),
('TEAM JJ', '2a', 1, '#include<stdio.h>\n#include<stdlib.h>\n\nvoid fact(int *);\n int s=1;\nint main()\n{\n    int i;\n    scanf("%d",&i);\n    fact(&i);\n    printf("%d\\n", i);\n    return 0;\n}\nvoid fact(int *j)\n{\n    \n    if((*j)!=0)\n    {\n        s = s*(*j);\n        (*j)--;\n        fact(&j);   \n    }\n *j=s;\n}', '2016-10-22 11:43:54', 0, 0),
('TEAM JJ', '2a', 4, ' #include<stdio.h>\n#include<stdlib.h>\n \n  int array[] = {23,34,12,17,204,99,16};\n  #define TOTAL_ELEMENTS 1\n  int main()\n  {\n      int d;\n\n      for(d=-1;d <= (TOTAL_ELEMENTS+4);d++)\n          printf("%d\\n",array[d+1]);\n\n      return 0;\n  }\n', '2016-10-22 11:40:52', 0, 1),
('the bug', '1a', 1, '#include <stdio.h>\n#include <stdllib.h>\n\nint max(int a[],int n)\n{\n  int max1=0*i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max1)	\n            {\n            	max1=a[i];\n			}\n	   }\n	   return max1;	\n}\n\nvoid bucket_sort(int a[],int n){\n  int bucket1=max(a[],n);\n  int b[bucket1],i,k,j=-1;\n  for(i=0;i<=bucket1;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[a[i]]+1;\n  	}	\n   	for(i=0;i<=bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n	} \n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]):\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf("%d",a[i]);\nreturn 0;\n}\n', '2016-10-22 07:25:17', 0, 0),
('the bug', '1a', 2, '#include<stdio.h>\n#include<stdllib.h>\n\n\nint main()\n{\n    int a,b,c;\n\n    pritnf("Enter a, b and c respectively: ");\n    scanf("%d%d%d",&a,&b,&c);\n\n    printf("Value before swapping:");\n    printf("%d%d%d",a,b,c);\n\n    cyclicSwap(a,b,c);\n\n    printf("Value after swapping:\n");\n    printf(%d%d%d",a, b, c);\n\n    return O;\n}\nvoid cyclicSwap(int c,int d,int e)\n{\n\n    int temp;\n\n    temp=b;\n    d=c;\n    c=e;\n    e=temp;\n}', '2016-10-22 07:40:38', 0, 0),
('the bug', '1a', 4, '#include<stdio> \n#include<string>\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare,0,sizeof(magicSquare));\nint i=n/2;j=n-1;\nint num;\nfor (num=0;num<=n*n; )\n{if (i==-1&& j==n) //3rd condition\n{j=n-2:i =0;\n    }\nelse{\nif(j==n)\nj=0;\nif (i<0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j-=2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j]=num++; //set number\nj++; i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<n;j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', '2016-10-22 07:37:20', 0, 0),
('the bug', '1a', 5, '#include<stdlib.h>\n#include<stdio.h>\nint main()\n{\n    int n,m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n,m);\n    return 0;\n}\nint isStepNum(n)\n{\n    int prevDigit=-1;\n    while (n>0)\n    {\n        int curDigit=n% 10;\n        if (prevDigit==-1)\n            prevDigit=curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit=curDigit;\n        n\\= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n,int m)\n{\n    for (int i=n;i<=m;i++);\n        if (iStepNum(i))\n            printf("%d ",i);\n}', '2016-10-22 07:39:54', 0, 0),
('The Debuggers', '1a', 1, '#include <stdio.h>\n#include <stdlib.h>\n\nint max(int a[],int n)\n{\n  int max=0,i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\n\nvoid bucket_sort(int a[],int n){\n  int bucket=max(a,n);\n  int b[bucket],i,k,j=-1;\n  for(i=0;i<bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[a[i]]+1;\n  	}	\n   	for(i=0;i<bucket;i++)	    {\n	      for(k=b[i];k>0;--k){\n		       	a[++j]=i;\n			  }   	\n}\n}\n\nint main(){\nint i,n;\nscanf("%d",&n);\nint a[n];\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]);\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', '2016-10-22 07:15:43', 0, 1),
('The Debuggers', '1a', 2, '#include<stdio.h>\nvoid cyclicSwap(int *a,int *b,int *c);\n\nint main()\n{\n    int a, b, c;\n\n    printf("Enter a, b and c respectively: ");\n    scanf("%d%d%d",&a,&b,&c);\n\n    printf("Value before swapping:");\n    printf("a = %d b = %d c = %d",a,b,c);\n\n    cyclicSwap(&a,&b,&c);\n\n    printf("Value after swapping:");\n    printf("a = %d b = %d c = %d",a, b, c);\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n    *temp=*b;\n    *b = *a;\n    *a = *c;\n    *c = *temp;\n}', '2016-10-22 07:38:10', 0, 0),
('The Debuggers', '1a', 4, '#include<stdio.h> \n#include<string.h>\n \nvoid generateSquare(int n)\n{\nint magicSquare[n][n];\n\nint i = n/2,j = n-1;\nint num;\nfor (num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2;i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n,n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', '2016-10-22 07:30:21', 0, 0),
('The Debuggers', '1a', 5, '#include<stdlib.h>\n#include<stdio.h>\n\nvoid displaySteppingNumbers(int n, int m);\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs(prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return 1;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n     {   if (isStepNum(i))\n            printf("%d ",i);}\n}', '2016-10-22 07:35:08', 0, 1),
('The Debuggers', '2a', 1, '#include<stdio.h>\nvoid fact(int *j,int *s);\n\nint main()\n{\n    int i,s=1;\n    scanf("%d",&i);\n    fact(&i,&s);\n    printf("%d\\n", s);\n    return 0;\n}\nvoid fact(int *j,int *s)\n{\n    if(*j>0)\n    {\n        *s = *s * *j;\n        *j--;        \n         fact(&j,&s);\n}\n}', '2016-10-22 11:45:43', 0, 0),
('The Debuggers', '2a', 3, '#include <stdio.h>\n \nfloat getMedian(int ar1[], int ar2[], int n)\n{\n    int i = 0;  \n    int j = 0; \n    int count;\n    int m1 = -1, m2 = -1;\n \n    for (count = 0; count <= 2*n; count++)\n    {\n        if (i != n)\n        {\n            m1 = m2;\n            m2 = ar2[j];\n            \n        }\n        else if (j != n)\n        {\n            m1 = m2;\n            m2 = ar1[i];\n           \n        }\n \n        if (ar1[i] < ar2[j])\n        {\n            m1 = m2;\n            m2 = ar1[i];\n            j++;\n        }\n        else\n        {\n            m2 = m1;  \n            m1 = ar2[j];\n            i++;\n        }\n    }\n \n    return (m1 + m2)/2.0;\n}\nint main()\n{\n    int n1,n2,ar1[100],ar2[100];\n    int i;\n    scanf("%d",&n1);\n    for (i = 0; i < n1; ++i)\n    {\n        scanf("%d",&ar1[i]);\n    }\n    scanf("%d",&n2);\n    for (i = 0; i < n2; ++i)\n    {\n        scanf("%d",&ar2[i]);\n    }\n\n    if (n1 == n2)\n        printf("Median is %f", getMedian(ar1, ar2, n1));\n    else\n        printf("Doesn''t work for arrays of unequal size");\n    return 0;\n}', '2016-10-22 11:40:24', 0, 0),
('The Debuggers', '2a', 4, ' #include<stdio.h>\n\n \n  int main()\n  {\n       int array[] = {23,34,12,17,204,99,16};\nint TOTAL_ELEMENTS = (sizeof(array) / sizeof(array[0]));\n\n      int d;\n\n      for(d=-1;d <= (TOTAL_ELEMENTS-2);d++)\n          printf("%d\\n",array[d+1]);\n\n      return 0;\n  }\n', '2016-10-22 11:18:06', 0, 1),
('tkmc', '1b', 1, 'void bucketSort(arr[], n)\n{\n    float b[n];\n    for (int i=0; i<n; i++){\n    int bi = n*arr[i]; \n    b[bi]-push_back(arr[i]);\n    } for (int i=0; i<n; i++)\n       sort((b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++)\n         for (int j = 0; j < b[i].size(); j++)\n             arr[index++] = b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ";\n    return 0;\n}\n', '2016-10-22 08:10:04', 0, 0),
('tkmc', '1b', 2, '#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int a, b, c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(a, b, c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    // swapping in cyclic order\n    temp =b;\n    b = a;\n    a = c;\n    c =temp;\n}', '2016-10-22 08:12:10', 0, 0),
('tkmc', '1b', 3, '\n#include<bits/stdc++.h>\nusing namespace std;\n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], bool splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(int v = 0; v < V; v++)\n{\nif ((sptSet[v] == false) && (dist[v] <= min)){\n min = dist[v];\n min_index = v;\n}\nreturn min_index ;\n}\n// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\ncout<<"Vertex   Distance from Source\\n";\nfor (int i = 0; i < V; i ++)\ncout<<i<<"		 "<<dist[i]<<"\\n";\n\n// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\n\nvoid dijkstra(int graph[V][V], int src)\n{\nint dist[V];    \n\n // The output array.  dist[i] will hold the shortest\n// distance from src to i\n\nbool sptSet[V];\n // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\n\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = false;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\n\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = true;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n\n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\n\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n\n// driver program to test above function\n\nint main(){\n/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n} ;\ndijkstra(graph, 0);\nreturn 0;\n}', '2016-10-22 08:12:38', 0, 0),
('tkmc', '1b', 4, '#inlcude<bits/stdc++.h>\nusing namespace std;\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2;\nint j = n-1;\nfor (int num=1; num <= n*n; i++)\n{if ((i==-1) && (j==n)) //3rd condition\n{\nj = n-2;\ni = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    cout<<"The Magic Square for n="<<n<<":\\nSum of each row or column :"<<n*(n*n+1)/2<<endl;\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            cout<< magicSquare[i][j]<<" ";\n        cout<<endl;\n    }\n}\n \nint main()\n{\n    int n ;\n    cin>>n;\n    generateSquare (n);\n    return 0;\n}\n', '2016-10-22 08:12:46', 0, 0),
('tkmc', '1b', 5, '#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int n , m ;\n    cin>>n>>m;\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nbool isStepNum(n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit)) != 1)\n                 return false;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return true;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++){\n        if (isStepNum(i))\n            cout << i <<" ";\n}\n}', '2016-10-22 08:12:48', 0, 0),
('TKMCE2', '1b', 1, 'void bucketSort(arr[], n)\n{\n    vector<float> b[n][];\n    for (int i=0; i<n; i++){\n    int bi = n*arr[i]; \n    b[bi]=push_back(arr[i]);\n    } for (int i=0; i<n; i++)\n       sort((b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++){for (int j = 0; j < b[i].sizeof(); j++)\n          arr(index++) = b[i][j];}\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ";\n    return 0;\n}\n', '2016-10-22 07:38:13', 0, 0),
('TKMCE2', '1b', 2, '#include<bits/stdc++.h>\nusing namespace std;\n\nvoid cyclicSwap(int*,int*,int*);\nint main()\n{\n    int a, b, c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(a, b, c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    //swapping in cyclic order\n    *temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = *temp;\n}', '2016-10-22 07:34:21', 0, 0),
('TKMCE2', '1b', 4, '#include<bits/stdc++.h>\nusing namespace std:\n \nvoid generateSquare(int n)\n{\nint magicSquare[][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2;j = n-1;\nfor (int num=1; num <= n*n; )\n{if (i==-1 && j==n) //3rd condition\n{j = n-2:i = 0;\n    }\nelse{\nif(j = = n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    cout<<"The Magic Square for n="<<n<<":\\nSum of each row or column :"<<n*(n*n+1)/2<<endl;\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            cout<< magicSquare[i][j]<<" ";\n        cout<<endl;\n    }\n}\n \nint main()\n{\n    int n ;\n    cin>>n;\n    generateSquare (n);\n    return 0;\n}\n', '2016-10-22 07:29:58', 0, 0),
('TKMCE2', '1b', 5, '#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int n , m ;\n    cin>>n>>m;\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nbool is StepNum(n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit) != 1)\n                 return false;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return true;\n}\nvoid displayStepingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (!StepNum(i))\n            cout << i <<" ";\n}', '2016-10-22 07:40:10', 0, 0),
('TVS ROCKERS', '1a', 1, '#include <stdio.h>\n#include <stdlib.h>\n\nint max(int a[] ,int n)\n{\n  int max=0,i;\n   for(i=0;i<n;i++)\n       {\n         if(a[i]>max)	\n            {\n            	max=a[i];\n			}\n	   }\n	   return max;	\n}\nint bucket_sort(int a,int n)\n{\n  int bucket=max(a,n);\n  int b[bucket],i,k;\n  for(i=0;i<=bucket;i++)\n     b[i]=0;\n for(i=0;i<n;i++)\n      {\n       	b[a[i]]=b[a[i]]+1;\n  	}	\n   	for(i=0;i<=bucket;i++)	    \n{\n	      for(k=b[i];k>0;--k)\n{\n		       	a[++j]=i;\n			  }   	\n	}\n} \n\nint main()\n{\nint i,n;\nscanf("%d",&n);\nfor(i=0;i<n;i++)\nscanf("%d",&a[i]);\nbucket_sort(a,n);\nfor(i=0;i<n;i++)\nprintf(" %d",a[i]);\nreturn 0;\n}\n', '2016-10-22 08:17:32', 0, 0),
('TVS ROCKERS', '1a', 2, '#include<stdio.h>\n\n\nint main()\n{\n    int a,b,c,temp;\n\n    pritnf("Enter a, b and c respectively: ");\n    scanf("%d%d%d",&a,&b,&c);\n\n    printf("Value before swapping:\\n");\n    printf("a = %d\\nb = %d\\nc = %d\\n",a,b,c);\n    cyclicSwap(*a,*b,*c,*temp);\n    printf("Value after swapping:\\n");\n    printf("a =%d\\nb =%d\\nc=%d\\n",a,b,c);\n\n    return 0;\n}\nint cyclicSwap(int *a,int *b,int *c,int *temp)\n{\n\n    int *temp;\n    temp = *b;\n    *b = *a;\n    *a = c;\n    *c = temp;\n}', '2016-10-22 08:07:24', 0, 0),
('TVS ROCKERS', '1a', 4, '#include<stdio.h> \n#include<string.h>\n \nvoid generateSquare(int n)\n{\nint magicSquare[n][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2;j = n-1;\nint num;\nfor (num=1; num <= n*n)\n{if (i==-1 && j==n) //3rd condition\n{j = n-2;i = 0;\n    }\nelse{\nif(j == n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -= 2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    printf("The Magic Square for n=%d:\\nSum of each row or column %d:\\n\\n",n*(n*n+1)/2);\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf("%3d ", magicSquare[i][j]);\n        printf("\\n");\n    }\n}\n \nint main()\n{\n    int n;\n    scanf("%d",&n); // Works only when n is odd\n    generateSquare (n);\n    return 0;\n}', '2016-10-22 08:12:36', 0, 0),
('TVS ROCKERS', '1a', 5, '#include<stdlib.h>\n#include<stdio.h>\nvoid displaySteppingNumbers(int n, int m);\nint main()\n{\n    int n , m ;\n    scanf("%d%d",&n,&m);\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nint isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit) != 1)\n                 return 0;\n        }\n        prevDigit = curDigit;\n        n = 10;\n    }\n    return 0;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n        if (iStepNum[i])\n            printf("%d ",i);\n}', '2016-10-22 08:20:09', 0, 0),
('Wolverine', '1b', 1, 'void bucketSort(arr[], n)\n{\n    Vector<float> b[n];\n    for (int i=0; i<n; i++);{\n    int b[i] = n*arr[i]; \n    b[b[i]]-push_back(arr[i]);\n    } for (int i=0; i<n; i++)\n       sort(b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++)\n      for (int j = 0; j < b[i].size(); j++)\n          arr[index++] = b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = [0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434];\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ";\n    return 0;\n}\n', '2016-10-22 07:17:43', 0, 0),
('Wolverine', '1b', 2, '#include<bits/stdc++.h>\nusing namespace std;\nvoid cyclicSwap(int *a,int *b,int *c);\nint main()\n{\n    int a, b, c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(&a, &b, &c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    // swapping in cyclic order\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = temp;\n}', '2016-10-22 07:24:00', 7, 1),
('Wolverine', '1b', 4, '#inlcude<bits/stdc++.h>\nusing namespace std;\n \nvoid generateSquare(int n)\n{\nint magicSquare[n][n];\nmemset(magicSquare, 0, sizeof(magicSquare));\nint i = n/2; int j = n-1;\nfor (int num=1; num<= n*n; )\n{if (i==-1 && j==n) //3rd condition\n   {j = n-2;i = 0;\n    }\nelse{\nif(j == n)\nj = 0;\nif (i < 0)\ni=n-1;\n}\nif (magicSquare[i][j]) //2nd condition\n{j -=2;\ni++;\ncontinue;\n}\nelse\nmagicSquare[i][j] = num++; //set number\nj++;  i--; //1st condition\n}\n    cout<<"The Magic Square for n="<<n<<":\\nSum of each row or column :"<<n*(n*n+1)/2<<endl;\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            cout<< magicSquare[i][j]<<" ";\n        cout<<endl;\n    }\n}\n \nint main()\n{\n    int n ;\n    cin>>n;\n    generateSquare(n);\n    return 0;\n}\n', '2016-10-22 07:39:53', 0, 0),
('Wolverine', '1b', 5, '#include<bits/stdc++.h>\nusing namespace std;\nvoid displaySteppingNumbers(int n, int m);\n\nint main()\n{\n    int n , m ;\n    cin>>n>>m;\n    displaySteppingNumbers(n, m);\n    return 0;\n}\nbool isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit)) != 1)\n                 return false;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return true;\n}\nvoid displaySteppingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++)\n        if (isStepNum(i))\n            cout << i <<" ";\n}', '2016-10-22 07:32:46', 5, 1);
INSERT INTO `submissions` (`teamname`, `stageid`, `questionid`, `ans`, `time`, `changes`, `accept`) VALUES
('Wolverine', '2b', 1, '#include<bits/stdc++.h>\nusing namespace std;\nvoid fact(int *j);\n\nint main()\n{\n    int i;\n    cin>>i;\n    fact(&i);\n    cout<<i<<endl;\n    return 0;\n}\nvoid fact(int *j)\n{\n    static int s=*j;\n    if(*j!=1)\n    {   \n        (*j)--;\n        s = s**j;\n       \n        fact(j);\n    }\n   *j=s;\n}', '2016-10-22 11:41:45', 5, 1),
('Wolverine', '2b', 4, '\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n  #define TOTAL_ELEMENTS sizeof(array) / sizeof(array[0])\n  int array[] = {23,34,12,17,204,99,16};\n\n  int main()\n  {\n      int d;\n\n      for(d=-1;d < (TOTAL_ELEMENTS-2);d++)\n          cout<<array[d+1]<<endl;\n\n      return 0;\n  }\n\n', '2016-10-22 11:45:00', 0, 0),
('yogi', '1b', 1, 'void bucketSort(float arr[],int  n)\n{\n    Vector<float> b[n];\n    for (int i=0; i<n; i++){\n    int bi = n*arr[i]; \n    b[bi]-push_back(arr[i]);\n    } for (int i=0; i<n; i++)\n       sort((b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++)for (int j = 0; j < b[i].size(); j++)\n          arr(index++) = b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << "  ";\n    return 0;\n}\n', '2016-10-22 07:43:27', 0, 0),
('yogi', '1b', 2, ' #include<bits/stdc++.h>\n#include<iostream>\nusing namespace std;\n\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int *temp;\n\n    // swapping in cyclic order\n * temp = *b;\n    *b = *a;\n    *a = *c;\n    *c =* temp;\n}\nint main()\n{\n    int a, b, c ;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\n c = "<<c;\n\n    cyclicSwap(a, b, c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n    return 0;\n}', '2016-10-22 07:57:20', 0, 0),
('yogi', '1b', 3, '\n#include<bits/stdc++.h>\nusing namespace std;\n// Number of vertices in the graph\n#define V 9\n// A utility function to find the vertex with minimum distance value, from\n// the set of vertices not yet included in shortest path tree\nint minDistance(int dist[], bool splSet[]){  // Initialize min value\nint min = INT_MAX, min_index; \nfor(int v = 0; v < V; v++){\nif (sptSet[v] == false && dist[v] <= min)\nmin = dist[v], min_index = v;\nreturn min_index }// A utility function to print the constructed distance array\nint printSolution(int dist[], int n){\ncout<<"Vertex   Distance from Source\\n";\nfor (int i = 0; i < V; i ++)\ncout<<i<<"		 "<<dist[i]<<"\\n";\n// Funtion that implements Dijkstra''s single source shortest path algorithm\n// for a graph represented using adjacency matrix representation\nvoid dijkstra(int graph[V][V], int src){\nint dist[V];     // The output array.  dist[i] will hold the shortest\n// distance from src to i\nbool sptSet[V]; // sptSet[i] will true if vertex i is included in shortest\n// path tree or shortest distance from src to i is finalized\n// Initialize all distances as INFINITE and stpSet[] as false\nfor (int i = 0; i < V; i++)\ndist[i] = INT_MAX, sptSet[i] = false;    // Distance of source vertex from itself is always 0\ndist[src] = 0;     // Find shortest path for all vertices\nfor (int count = 0; count < V-1; count++){\n// Pick the minimum distance vertex from the set of vertices not\n// yet processed. u is always equal to src in first iteration.\nint u = minDistance(dist, sptSet);// Mark the picked vertex as processed\nsptSet[u] = true;// Update dist value of the adjacent vertices of the picked vertex.\nfor (int v = 0; v < V; v++)// Update dist[v] only if is not in sptSet, there is an edge from \n// u to v, and total weight of path from src to  v through u is \n// smaller than current value of dist[v]\nif (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \n&& dist[u]+graph[u][v] < dist[v]))\ndist[v] = dist[u] + graph[u][v];}// print the constructed distance array\nprintSolution(dist, V);}\n// driver program to test above function\nint main(){/* Let us create the example graph discussed above */\nint graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\n{4, 0, 8, 0, 0, 0, 0, 11, 0},\n{0, 8, 0, 7, 0, 4, 0, 0, 2},\n{0, 0, 7, 0, 9, 14, 0, 0, 0},\n{0, 0, 0, 9, 0, 10, 0, 0, 0},\n{0, 0, 4, 14, 10, 0, 2, 0, 0},\n{0, 0, 0, 0, 0, 2, 0, 1, 6},\n{8, 11, 0, 0, 0, 0, 1, 0, 7},\n{0, 0, 2, 0, 0, 0, 6, 7, 0},\n};dijkstra(graph, 0);\nreturn 0;}', '2016-10-22 07:57:57', 0, 0),
('yoyo', '1b', 1, 'void bucketSort(float arr[],int n)\n{\n    float b[n];\n    for (int i=0; i<n; i++)\n    {\n    int bi = n*arr[i]; \n    b[bi]-push_back(arr[i]);\n    } \n    for (int i=0; i<n; i++)\n       sort((b[i].begin(), b[i].end()); \n     int index = 0;\n    for (int i = 0; i < n; i++)\n         for (int j = 0; j < b[i].size(); j++)\n              arr[index++]= b[i][j];\n}\n\n\nint main()\n{\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    cout << "Sorted array is "<<endl;\n    for (int i=0; i<n; i++)\n       cout << arr[i] << " ";\n    return 0;\n}\n', '2016-10-22 07:18:38', 0, 0),
('yoyo', '1b', 2, '#include<bits/stdc++.h>\nusing namespace std;\nvoid cyclicSwap(int *,int *,int *);\nint main()\n{\n    int a,b,c;\n\n    cout<<"Enter a, b and c respectively: ";\n    cin>>a>>b>>c;\n\n    cout<<"Value before swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    cyclicSwap(&a, &b,&c);\n\n    cout<<"Value after swapping:\\n";\n    cout<<"a = "<<a<<"\\nb = "<<b<<"\\nc = "<<c;\n\n    return 0;\n}\nvoid cyclicSwap(int *a,int *b,int *c)\n{\n\n    int temp;\n\n    // swapping in cyclic order\n    temp = *b;\n    *b = *a;\n    *a = *c;\n    *c = temp;\n}\n', '2016-10-22 07:34:17', 7, 1),
('yoyo', '1b', 5, '#include<bits/stdc++.h>\nusing namespace std;\nbool isStepNum(int n);\nvoid displayStepingNumbers(int n, int m);\nint main()\n{\n    int n ,m ;\n    cin>>n>>m;\n    displayStepingNumbers(n,m);\n    return 0;\n}\nbool isStepNum(int n)\n{\n    int prevDigit = -1;\n    while (n)\n    {\n        int curDigit = n % 10;\n        if (prevDigit == -1)\n            prevDigit = curDigit;\n        else\n        {\n            if (abs((prevDigit - curDigit) != 1)\n                 return false;\n        }\n        prevDigit = curDigit;\n        n /= 10;\n    }\n    return true;\n}\nvoid displayStepingNumbers(int n, int m)\n{\n    for (int i=n; i<=m; i++);\n        if (isStepNum(i))\n            cout << i <<" ";\n}', '2016-10-22 07:40:25', 0, 0),
('yoyo', '2b', 1, '#include<bits/stdc++.h>\nusing namespace std;\nvoid fact(int *);\n\nint main()\n{\n    int i;\n    cin>>i;\n    int f=fact(i);\n    cout<<f<<endl;\n    return 0;\n}\nint fact(int j)\n{\n if(j==1)\n return 1;\nelse\nreturn fact(j)*fact(j-1);\n}\n  ', '2016-10-22 11:45:44', 0, 0),
('yoyo', '2b', 4, '\n\n#include<bits/stdc++.h>\nusing namespace std;\n int array[] = {23,34,12,17,204,99,16};\n\n  #define TOTAL_ELEMENTS (sizeof(array) / sizeof(array[0]))\n \n  int main()\n  {\n      int d;\n\n      for(d=0;d <(TOTAL_ELEMENTS);d++)\n          cout<<array[d]<<endl;\n\n      return 0;\n  }\n\n', '2016-10-22 11:42:06', 3, 1);

-- --------------------------------------------------------

--
-- Table structure for table `teams`
--

CREATE TABLE IF NOT EXISTS `teams` (
  `contestant1` text NOT NULL,
  `contestant2` text NOT NULL,
  `teamname` varchar(16) NOT NULL,
  `password` text NOT NULL,
  `status` int(11) NOT NULL,
  `stage` varchar(2) NOT NULL,
  `language` int(11) NOT NULL,
  PRIMARY KEY (`teamname`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

--
-- Dumping data for table `teams`
--

INSERT INTO `teams` (`contestant1`, `contestant2`, `teamname`, `password`, `status`, `stage`, `language`) VALUES
('John', '', '12345678', '12345678', 3, '3a', 1),
('abc', 'def', 'abcdef', 'VISAKHAPATNAM', 1, '1a', 1),
('Rishabh', 'John', 'Aces95', 'rishabharora', 2, '1b', 2),
('ann maria alex', 'ann maria stanley', 'Ann''s', 'annmaria', 0, '0', 0),
('ann maria alex', 'ann maria stanley', 'anns', 'annmaria', 3, '2a', 1),
('S.Jashwanth', 'N.Prashanth', 'Anonymous', '19961997', 6, '3a', 1),
('Arpan Kundu', '', 'Arpan Kundu', 'champu1997', 2, '1b', 2),
('avnish', 'mohd. arsh', 'arsh_avn', 'avnmnksnk', 2, '1a', 1),
('bhanu prakash', 'chandra sai', 'asdf', 'b150593cs', 2, '2a', 1),
('abhijith', 'joel', 'avial', 'avial1234', 2, '1a', 1),
('Jayakrishna Menon', 'Gokul Krishna P', 'b4d_s3ct0r', 'amritabi0s', 3, '1a', 1),
('Sathyanarayanan G', 'Ashfaq J', 'BigBang', 'sathya2001', 2, '1a', 1),
('Balaji', '', 'bigbangtheory', 'admin123', 2, '1b', 2),
('Harish Rithish S', 'Venkkatesh S', 'bits_please', 'foolprajwal', 3, '2b', 2),
('A Sachin', 'Soorya Narayan J M', 'bits_please_', 'lolcatlol', 4, '3b', 2),
('Balaji', 'Munishvhar', 'breakingbad', 'admin123', 3, '1a', 1),
('Balarubinan N', 'Mohamed abid M', 'casino royale', 'shan12345', 2, '1a', 1),
('John', 'Ashiq', 'Chocolate Buster', 'eatmychocolate', 0, '0', 0),
('Hashim N A', 'Johns Mathew', 'Codeblooded', 'hashim@123', 6, '3a', 1),
('Gokul Krishna M', 'Abin Shoby', 'Codecreators', 'codeagtkm', 3, '1b', 2),
('debug', 'debuging', 'debug', 'debugger', 5, '3a', 1),
('SANJAY P', 'SREEHARI A', 'ELECTRICA', 'SREEHARI', 2, '1b', 2),
('Shreayaas', 'Jyothiswaruban', 'ENIGMA', 'Mi0412@@', 2, '1a', 1),
('abhiji', 'joel', 'eye', 'eye12345', 2, '1a', 1),
('karishma elsa johns', 'alan jacob', 'fruitbeer', 'fruitbeer', 4, '3a', 1),
('KEERTHI V', 'AROMAL S', 'HACKERS', 'HACKERS12', 4, '3a', 1),
('hia', 'mia', 'hello', 'tathva16', 1, '1a', 1),
('Sreelakshmi S', 'Archana N', 'inferno', 'tathva16', 4, '3a', 1),
('Ananthu.S.Ajayan', 'Jayakrishnan.KP', 'Jayanthu', 'password', 2, '1a', 1),
('kumar', '', 'kumarteam', '12345678', 3, '1b', 2),
('dona sunny', 'jovial j', 'markups', 'donajovial', 2, '1a', 1),
('VISHNU POOTHERY', 'VISAKH S', 'MAVERICKS', 'MAVERICKS@123', 5, '3b', 2),
('Mithun Lal', 'Lulu Basheer', 'MILU', 'mithunlulu', 4, '2b', 2),
('Amanta Sunny', 'Annie Elizabeth', 'miracle', 'anuamanta', 2, '1a', 1),
('muhsina', 'vinayak', 'muhsinayak', 'shilpa123', 5, '3a', 1),
('ni', 'ni', 'ni', 'qwertyuiop', 15, '3b', 2),
('ANAGHA VINOD', 'SRUTHI SURESH', 'PSYKOS!!!', 'DEBUGGER', 2, '1b', 2),
('Ali Akbar S', '', 'Pwnage', 'loligaggin', 4, '3b', 2),
('imthiaz rahman K', 'yeganathan S', 'rahman', 'qwertyuiop', 2, '1b', 2),
('elsa mary thomas', 'shalet mathew', 'rofix', 'rofix343', 2, '1a', 1),
('Shivkrishna A', '', 'rofl', '!@#$%^', 3, '1a', 1),
('BARATH', 'RAJAGURU', 'SHAN', '1234567890', 3, '1a', 1),
('sarin nsreedharan', '', 'solo', 'knightz79', 2, '1b', 2),
('alka kumari', 'soorya e', 'soorya_alka', 'soorya_alka', 2, '2b', 2),
('Shrimadhav U K', '', 'SpEcHiDe', 'password', 2, '1a', 1),
('Arun A', 'Aswin A', 'stark', '60321327@', 3, '1b', 2),
('Honey Mol Sebastian', 'Anju Abraham', 'starz', 'honeymol12', 3, '2a', 1),
('SHAUN THAYIL', 'SREERAG S ', 'STNEO', '123456789', 2, '1b', 2),
('JOSEPH MATHEW', 'JOEL JACOB', 'TEAM JJ', 'joeljoseph', 3, '2a', 1),
('Johan V', 'Vineesh K', 'the bug', 'bugofwar', 2, '1a', 1),
('Kenil Shah', 'Bharat reddy', 'The Debuggers', 'computer', 5, '2a', 1),
('Subash baby', 'akmar nafi', 'tkmc', 'akmar123', 6, '1b', 2),
('Rohith P', 'P.A Mohamed Zameel', 'TKMCE2', '12345678', 2, '1b', 2),
('T.T.Sibi vishtan', 'T.J.Aumrudh lal kumar', 'TVS ROCKERS', 'TVSMHSS123456', 2, '1a', 1),
('Gowrisankar', '', 'Wolverine', 'moonlight', 3, '2b', 2),
('Yogendra', '', 'yogi', 'yogi1993', 2, '1b', 2),
('muhammed jawad', 'shilpa mathew', 'yoyo', '12345yoyo', 3, '2b', 2),
('yea', 'yeayea', 'yoyoyo', 'testing2', 0, '0', 0);

--
-- Constraints for dumped tables
--

--
-- Constraints for table `answers`
--
ALTER TABLE `answers`
  ADD CONSTRAINT `answers_ibfk_2` FOREIGN KEY (`stageid`) REFERENCES `stages` (`stageid`),
  ADD CONSTRAINT `answers_ibfk_1` FOREIGN KEY (`teamname`) REFERENCES `teams` (`teamname`);

--
-- Constraints for table `questions`
--
ALTER TABLE `questions`
  ADD CONSTRAINT `questions_ibfk_1` FOREIGN KEY (`stageid`) REFERENCES `stages` (`stageid`);

--
-- Constraints for table `quiz2`
--
ALTER TABLE `quiz2`
  ADD CONSTRAINT `quiz2_ibfk_2` FOREIGN KEY (`teamname`) REFERENCES `teams` (`teamname`),
  ADD CONSTRAINT `quiz2_ibfk_1` FOREIGN KEY (`stageid`) REFERENCES `stages` (`stageid`);

--
-- Constraints for table `solutions`
--
ALTER TABLE `solutions`
  ADD CONSTRAINT `solutions_ibfk_1` FOREIGN KEY (`stageid`) REFERENCES `stages` (`stageid`);

--
-- Constraints for table `submissions`
--
ALTER TABLE `submissions`
  ADD CONSTRAINT `submissions_ibfk_2` FOREIGN KEY (`stageid`) REFERENCES `stages` (`stageid`),
  ADD CONSTRAINT `submissions_ibfk_1` FOREIGN KEY (`teamname`) REFERENCES `teams` (`teamname`);

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
